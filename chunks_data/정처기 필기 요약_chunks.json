{
  "chunks": [
    "[페이지 1] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 1과목·데이터베이스 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 11.8, 11.6, 10.9, 10.5, 10.3, 09.8, 09.5, 08.3, 07.9, 07.5, 99.8 003 데이터베이스의 특징 •실\u0007 시간 접근성(Real Time Accessibility) :\u0007수시적이고\u0007비정 핵심 06.5, 05.3, 03.8, 01.3, 00.7 001 정보 시스템 형적인\u0007질의(조회)에\u0007대하여\u0007실시간\u0007처리(Real-Time\u0007 Processing)에\u0007의한\u0007응답이\u0007가능함 정보 시스템 • 계속적인 변화(Continuous Evolution) :\u0007새로운\u0007데이터의\u0007 •조\u0007 직체에\u0007필요한\u0007Data를\u0007수집,\u0007저장해\u0007두었다가\u0007필요\u0007 삽입(Insertion),\u0007삭제(Deletion),\u0007갱신(Update)으로\u0007 시에\u0007처리해서\u0007의사\u0007결정에\u0007유용한\u0007정보를\u0007생성하고\u0007분 항상\u0007최신의\u0007데이터를\u0007유지함 배하는\u0007수단이다. •동\u0007 시 공유(동시 공용)(Concurrent Sharing) :\u0007여러\u0007사용자가\u0007 •사\u0007 용하는\u0007목적에\u0007따라\u0007경영\u0007정보\u0007시스템,\u0007군사\u0007정보\u0007시 동시에\u0007자기가\u0007원하는\u0007데이터를\u0007이용할\u0007수\u0007있음 스템,\u0007인사\u0007행정\u0007정보\u0007시스템,\u0007의사\u0007결정\u0007지원\u0007시스템\u0007등 •\u0007내용에 의한 참조(Content Reference) :\u0007데이터베이스에\u0007 으로\u0007사용된다. 있는\u0007데이터를\u0007참조할\u0007때\u0007데이터\u0007주소나\u0007위치에\u0007의해 정보와 자료 서가\u0007아니라\u0007사용자가\u0007요구하는\u0007데이터\u0007내용으로\u0007데이 •\u0007자료(Data) :\u0007현실\u0007세계에서\u0007관찰이나\u0007측정을\u0007통해\u0007수집한\u0007 터를\u0007찾음 단순한\u0007사실이나\u0007결과값으로,\u0007가공되지\u0007않은\u0007상태 • 정보(Information) :\u0007의사\u0007결정에\u0007도움을\u0007줄\u0007수\u0007있는\u0007유용한\u0007 핵심 05.5 형태로,\u0007자료를\u0007가공(처리)해서\u0007얻는\u0007결과물 004 DBMS(DataBase Management System)의 정의 자료 처리 시스템 •사\u0007 용자와\u0007데이터베이스\u0007사이에서\u0007사용자의\u0007요구에\u0007따 자료  가공(처리)  정보 라\u0007정보를\u0007생성해\u0007주고,\u0007데이터베이스를\u0007관리해\u0007주는\u0007 소프트웨어이다. •자\u0007 료 처리 시스템\u0007:\u0007정보\u0007시스템이\u0007사용할\u0007자료를\u0007처리 •\u0007기존의\u0007파일\u0007시스템이\u0007갖는\u0007데이터의\u0007종속성과\u0007중복성 하는\u0007정보\u0007시스템의\u0007서브\u0007시스템으로,\u0007처리\u0007형태에\u0007따 의\u0007문제를\u0007해결하기\u0007위해\u0007제안된\u0007시스템으로,\u0007모든\u0007응 라\u0007일괄\u0007처리\u0007시스템,\u0007온라인\u0007실시간\u0007처리\u0007시스템,\u0007분 용\u0007프로그램들이\u0007데이터베이스를\u0007공용할\u0007수\u0007있도록\u0007관 산\u0007처리\u0007시스템으로\u0007분류\u0007 리해\u0007준다. •데\u0007 이터웨어 하우스(DataWare House)\u0007:\u0007조직이나\u0007기업체 •데\u0007 이터베이스의\u0007구성,\u0007접근\u0007방법,\u0007유지관리에\u0007대한\u0007모 의\u0007중심이\u0007되는\u0007주요\u0007업무\u0007시스템에서\u0007추출되어\u0007새로 든\u0007책임을\u0007진다. 이\u0007생성된\u0007데이터베이스로서\u0007의사\u0007결정\u0007지원\u0007시스템을\u0007 지원하는\u0007주체적,\u0007통합적,\u0007시간적\u0007데이터의\u0007집합체 핵심 06.5, 02.5, 00.3 005 기존의 파일 처리 방식에서의 문제점 핵심 14.8, 14.3, 13.8, 13.6, 13.3, 12.3, 10.5, 09.3, 08.9, 08.5, 07.5, 07.3, 05.4 종속성으로 인한 문제점 002 데이터베이스의 정의 •종\u0007 속성이란\u0007응용\u0007프로그램과\u0007데이터\u0007파일이\u0007상호\u0007의존 •통\u0007 합된 데이터(Integrated Data) :\u0007자료의\u0007중복을\u0007배제한\u0007 적인\u0007관계를\u0007말한다. 데이터의\u0007모임 •데\u0007 이터\u0007파일이\u0007보조기억장치에\u0007저장되는\u0007방법이나\u0007저 •저\u0007 장된 데이터(Stored Data) :\u0007컴퓨터가\u0007접근할\u0007수\u0007있는\u0007 장된\u0007데이터의\u0007접근\u0007방법을\u0007변경할\u0007때는\u0007응용\u0007프로그 저장\u0007매체에\u0007저장된\u0007자료 램도\u0007같이\u0007변경해야\u0007한다. • 운영 데이터(Operational Data) :\u0007조직의\u0007업무를\u0007수행하는\u0007 중복성으로 인한 문제점 데\u0007있어서\u0007존재\u0007가치가\u0007확실하고\u0007없어서는\u0007안\u0007될\u0007반드 •일\u0007 관성 :\u0007중복된\u0007데이터\u0007간에\u0007내용이\u0007일치하지\u0007않는\u0007상 시\u0007필요한\u0007자료 황이\u0007발생하여\u0007일관성이\u0007없어짐 •공\u0007 용 데이터(Shared Data) :\u0007여러\u0007응용\u0007시스템들이\u0007공동 으로\u0007소유하고\u0007유지하는\u0007자료 4 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 2] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •보\u0007 안성 :\u0007중복되어\u0007있는\u0007모든\u0007데이터에\u0007동등한\u0007보안\u0007수 핵심 09.5, 06.3, 04.3, 01.9, 99.10 007 DBMS의 장·단점 준을\u0007유지하기가\u0007어려움 • 경제성 :\u0007저장공간의\u0007낭비와\u0007동일한\u0007데이터의\u0007반복\u0007작업 장 점 단 점 으로\u0007인한\u0007비용의\u0007증가 •\u0007\u0007데이터의\u0007중복을\u0007피할\u0007수\u0007있음 •\u0007데이터베이스\u0007전문가\u0007부족 •무\u0007 결성 :\u0007제어의\u0007분산으로\u0007인해\u0007데이터의\u0007정확성을\u0007유지 \u0007•\u0007저장된\u0007자료를\u0007공동으로\u0007이용할\u0007•\u0007전산화\u0007비용이\u0007증가함 할\u0007수\u0007없음 수\u0007있음 •\u0007대용량\u0007디스크로의\u0007집중적인\u0007 •\u0007데이터의\u0007일관성을\u0007유지할\u0007수\u0007있음 Access로\u0007과부하(Overhead)가\u0007 •\u0007데이터의\u0007무결성을\u0007유지할\u0007수\u0007있음 발생함 핵심 12.8, 11.8, 11.6, 10.5, 09.3, 08.5, 06.9, 05.4, 04.9, 04.5, 03.8, 03.5, 02.9, 00.7, 99.8, 99.4 •\u0007보안을\u0007유지할\u0007수\u0007있음 •\u0007파일의\u0007예비(Backup)와\u0007회복 006 DBMS의 필수 기능 •\u0007데이터를\u0007표준화할\u0007수\u0007있음 (Recovery)이\u0007어려움 •\u0007시스템이\u0007복잡함 •\u0007데이터를\u0007통합하여\u0007관리할\u0007수\u0007있음 • 정의(조직)(Definition) •\u0007항상\u0007최신의\u0007데이터를\u0007유지함 -\u0007데이터의\u0007형(Type)과\u0007구조,\u0007데이터가\u0007DB에\u0007저장될\u0007 •\u0007데이터의\u0007실시간\u0007처리가\u0007가능함 때의\u0007제약조건\u0007등을\u0007명시하는\u0007기능이다. •\u0007데이터의\u0007논리적·물리적\u0007독립성 이\u0007보장\u0007 -\u0007데이터와\u0007데이터의\u0007관계를\u0007명확하게\u0007명세할\u0007수\u0007있어 야\u0007하며,\u0007원하는\u0007데이터\u0007연산은\u0007무엇이든\u0007명세할\u0007수\u0007 논리적 독립성과 물리적 독립성 있어야\u0007한다.\u0007 • 논리적 독립성 :\u0007응용\u0007프로그램과\u0007데이터베이스를\u0007독립 •\u0007조작(Manipulation) :\u0007데이터\u0007검색(요청),\u0007갱신(변경),\u0007삽 시킴으로써,\u0007데이터의\u0007논리적\u0007구조를\u0007변경시키더라도\u0007 입,\u0007삭제\u0007등을\u0007체계적으로\u0007처리하기\u0007위해\u0007데이터\u0007접근\u0007 응용\u0007프로그램은\u0007변경되지\u0007않음 수단\u0007등을\u0007정하는\u0007기능 •물\u0007 리적 독립성 :\u0007응용\u0007프로그램과\u0007보조기억장치\u0007같은\u0007물 • 제어(Control) 리적\u0007장치를\u0007독립시킴으로써,\u0007데이터베이스\u0007시스템의\u0007 성능\u0007향상을\u0007위해\u0007새로운\u0007디스크를\u0007도입하더라도\u0007응용\u0007 -\u0007데이터베이스를\u0007접근하는\u0007갱신,\u0007삽입,\u0007삭제\u0007작업이\u0007 프로그램에는\u0007영향을\u0007주지\u0007않고\u0007데이터의\u0007물리적\u0007구조 정확하게\u0007수행되어\u0007데이터의\u0007무결성이\u0007유지되도록\u0007 만을\u0007변경함 제어해야\u0007한다. -\u0007정당한\u0007사용자가\u0007허가된\u0007데이터만\u0007접근할\u0007수\u0007있도록\u0007 보안(Security)을\u0007유지하고\u0007권한(Authority)을\u0007검사 핵심 14.8, 14.3, 13.3, 12.8, 11.3, 10.9, 09.8, 07.9, 05.9, 00.7, 00.3 008 스키마(Schema)의 정의 할\u0007수\u0007있어야\u0007한다. -\u0007여러\u0007사용자가\u0007데이터베이스를\u0007동시에\u0007접근하여\u0007데 •데\u0007 이터베이스의\u0007구조와\u0007제약조건에\u0007관한\u0007전반적인\u0007명 이터를\u0007처리할\u0007때\u0007처리\u0007결과가\u0007항상\u0007정확성을\u0007유지 세(Specification)를\u0007기술(Description)한다. 하도록\u0007병행\u0007제어(Concurrency\u0007Control)를\u0007할\u0007수\u0007있 •\u0007데이터베이스를\u0007구성하는\u0007데이터\u0007개체(Entity),\u0007속성 어야\u0007한다. (Attribute),\u0007관계(Relationship)\u0007및\u0007데이터\u0007조작\u0007시\u0007데이터\u0007 값들이\u0007갖는\u0007제약조건\u0007등에\u0007관해\u0007전반적으로\u0007정의한다. •\u0007스키마는\u0007사용자의\u0007관점에\u0007따라\u0007외부(External)\u0007스키 마,\u0007개념(Conceptual)\u0007스키마,\u0007내부(Internal)\u0007스키마 로\u0007나뉜다. •스\u0007 키마(Schema)는\u0007데이터\u0007사전에\u0007저장되며,\u0007다른\u0007이 름으로\u0007메타\u0007데이터(Meta-Data)라고도\u0007한다.\u0007 5 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 3] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 03.3, 02.9, 02.5, 01.9, 99.8 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 12.8, 12.5, 12.3, 11.3, 10.9, 10.5, 10.3, 09.8, 06.9, 06.3, 05.4, 05.3, 04.9, 04.5, 04.3, 03.8, 핵심 08.9, 07.9, 07.3, 06.9, 06.5, 05.3, 03.8, 03.5, 02.9, 02.3, 01.9, 01.6, 01.3, 99.8 009 스키마의 3계층 010 데이터베이스 언어(Database Language) 외부 스키마(External Schema) = 서브 스키마 = 사용자 뷰 데이터 정의 언어(DDL ; Data Definition Language) (View) •D\u0007 B\u0007구조,\u0007데이터\u0007형식,\u0007접근\u0007방식\u0007등\u0007DB를\u0007구축하거나\u0007 •사\u0007 용자나\u0007응용\u0007프로그래머가\u0007각\u0007개인의\u0007입장에서\u0007필요 수정할\u0007목적으로\u0007사용하는\u0007언어이다. 로\u0007하는\u0007데이터베이스의\u0007논리적\u0007구조를\u0007정의한다. •번\u0007 역한\u0007결과가\u0007데이터\u0007사전(Data-Dictionary)이라는\u0007 •전\u0007 체\u0007데이터베이스의\u0007한\u0007논리적인\u0007부분으로\u0007볼\u0007수\u0007있 특별한\u0007파일에\u0007여러\u0007개의\u0007테이블로\u0007저장된다. 으므로\u0007서브\u0007스키마(Subschema)라고도\u0007한다. •데\u0007 이터 정의 언어의 기능 •하\u0007 나의\u0007데이터베이스\u0007시스템에는\u0007여러\u0007개의\u0007외부\u0007스키 \u0007\u0007\u0007-외부\u0007스키마\u0007명세\u0007정의 마가\u0007존재할\u0007수\u0007있으며,\u0007하나의\u0007외부\u0007스키마를\u0007여러\u0007개 \u0007\u0007\u0007-\u0007데이터베이스의\u0007논리적\u0007데이터\u0007구조와\u0007물리적\u0007데이 의\u0007응용\u0007프로그램이나\u0007사용자가\u0007공용할\u0007수\u0007있다. 터\u0007구조의\u0007정의\u0007및\u0007수정 \u0007\u0007\u0007-\u0007논리적\u0007데이터\u0007구조와\u0007물리적\u0007데이터\u0007구조\u0007간의\u0007사상\u0007 •\u0007같은\u0007데이터베이스에\u0007대해서도\u0007서로\u0007다른\u0007관점을\u0007정의 정의 할\u0007수\u0007있도록\u0007허용한다. \u0007\u0007\u0007-스키마에\u0007사용되는\u0007제약조건에\u0007대한\u0007명세\u0007정의 •일\u0007 반\u0007사용자는\u0007질의어(SQL)를\u0007사용하여\u0007DB를\u0007사용한다. \u0007\u0007\u0007-데이터의\u0007물리적\u0007순서\u0007규정 개념 스키마(Conceptual Schema) = 전체적인 뷰(View) 데이터 조작 언어(DML ; Data Manipulation Language) •데\u0007 이터베이스의\u0007전체적인\u0007논리적\u0007구조로서,\u0007모든\u0007응용\u0007 = 서브 언어 프로그램이나\u0007사용자들이\u0007필요로\u0007하는\u0007데이터를\u0007통합 •사\u0007 용자로\u0007하여금\u0007데이터를\u0007처리할\u0007수\u0007있게\u0007하는\u0007도구로 한\u0007조직\u0007전체의\u0007데이터베이스로\u0007하나만\u0007존재한다. 서\u0007사용자(응용\u0007프로그램)와\u0007DBMS\u0007간의\u0007인터페이스를\u0007 •\u0007개념\u0007스키마는\u0007개체\u0007간의\u0007관계와\u0007제약조건을\u0007나타내고\u0007 제공한다. 데이터베이스의\u0007접근\u0007권한,\u0007보안\u0007및\u0007무결성\u0007규칙에\u0007관 •응\u0007 용\u0007프로그램을\u0007통하여\u0007사용자가\u0007DB의\u0007데이터를\u0007실질 한\u0007명세를\u0007정의한다. 적으로\u0007조작할\u0007수\u0007있도록\u0007하기\u0007위해\u0007C,\u0007COBOL\u0007등의\u0007 •단\u0007 순히\u0007스키마(Schema)라고\u0007하면\u0007개념\u0007스키마를\u0007의미 호스트\u0007언어에\u0007DB\u0007기능을\u0007추가시켜\u0007만든\u0007언어이다. 한다. •대\u0007 표적인\u0007데이터\u0007조작어(DML)에는\u0007질의어가\u0007있으며,\u0007 •기\u0007 관이나\u0007조직체의\u0007관점에서\u0007데이터베이스를\u0007정의한\u0007 질의어는\u0007터미널에서\u0007주로\u0007이용하는\u0007비절차적(Non\u0007 것이다. Procedural)\u0007데이터\u0007언어이다. •데\u0007 이터베이스\u0007관리자에\u0007의해서\u0007구성된다. 데이터 제어 언어(DCL ; Data Control Language) 내부 스키마(Internal Schema) •무\u0007 결성,\u0007보안\u0007및\u0007권한\u0007제어,\u0007회복\u0007등을\u0007하기\u0007위한\u0007언어이다. •\u0007물리적\u0007저장장치의\u0007입장에서\u0007본\u0007데이터베이스\u0007구조로,\u0007 •\u0007데이터를\u0007보호하고\u0007데이터를\u0007관리하는\u0007목적으로\u0007사용 물리적인\u0007저장장치와\u0007밀접한\u0007계층이다. 된다. •\u0007실제로\u0007데이터베이스에\u0007저장될\u0007레코드의\u0007물리적인\u0007구 •\u0007데이터 제어 언어의 기능 조를\u0007정의하고,\u0007저장\u0007데이터\u0007항목의\u0007표현\u0007방법,\u0007내부\u0007 \u0007\u0007\u0007-\u0007불법적인\u0007사용자로부터\u0007데이터를\u0007보호하기\u0007위한\u0007데 레코드의\u0007물리적\u0007순서\u0007등을\u0007나타낸다. 이터\u0007보안(Security) •\u0007시스템\u0007프로그래머나\u0007시스템\u0007설계자가\u0007보는\u0007관점의\u0007스 \u0007\u0007\u0007-데이터의\u0007정확성을\u0007위한\u0007무결성(Integrity)\u0007유지 키마이다. \u0007\u0007\u0007-시스템\u0007장애에\u0007대비한\u0007데이터\u0007회복과\u0007병행수행\u0007제어 •데\u0007 이터베이스의\u0007물리적\u0007구조를\u0007정의한다. •데\u0007 이터의\u0007실제\u0007저장\u0007방법을\u0007기술한다. •\u0007물리적인\u0007저장장치와\u0007밀접한\u0007계층이다. 6 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 4] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 11.6, 10.9, 09.3, 06.5, 05.9, 05.5, 05.4, 05.3, 04.9, 03.8, 03.3, 01.9, 01.6, 01.3, 00.3, 99.10, 99.8, 99.4 핵심 05.3, 04.3, 02.3, 01.9, 00.7, 99.10 011 데이터베이스 사용자 012 데이터 모델의 정의 DBA(DataBase Administrator) •현\u0007 실\u0007세계의\u0007정보들을\u0007컴퓨터에\u0007표현하기\u0007위해\u0007단순 화,\u0007추상화하여\u0007체계적으로\u0007표현한\u0007개념적\u0007모형이다. \u0007데이터베이스\u0007시스템의\u0007모든\u0007관리와\u0007운영에\u0007대한\u0007책임을\u0007 지고\u0007있는\u0007사람이나\u0007그룹을\u0007의미한다. •데\u0007 이터,\u0007데이터의\u0007관계,\u0007데이터의\u0007의미\u0007및\u0007일관성,\u0007제약 조건\u0007등을\u0007기술하기\u0007위한\u0007개념적\u0007도구들의\u0007모임이다. •\u0007데이터베이스\u0007구성\u0007요소\u0007결정 •현\u0007 실\u0007세계를\u0007데이터베이스에\u0007표현하는\u0007중간\u0007과정,\u0007즉\u0007 •개\u0007 념\u0007스키마\u0007및\u0007내부\u0007스키마\u0007정의 데이터베이스\u0007설계\u0007과정에서\u0007데이터의\u0007구조를\u0007논리적 •데\u0007 이터베이스의\u0007저장\u0007구조\u0007및\u0007접근\u0007방법\u0007정의 으로\u0007표현하기\u0007위해\u0007사용되는\u0007도구이다. •보\u0007 안\u0007및\u0007데이터베이스의\u0007접근\u0007권한\u0007부여\u0007정책\u0007수립 •장\u0007 애에\u0007대비한\u0007예비(Back\u0007Up)\u0007조치와\u0007회복(Recovery) 핵심 03.3, 01.9, 99.10, 99.8 에\u0007대한\u0007전략\u0007수립 013 데이터 모델의 종류 •\u0007무결성을\u0007위한\u0007제약조건의\u0007지정 개념적 데이터 모델 •데\u0007 이터\u0007사전의\u0007구성과\u0007유지관리 •현\u0007 실\u0007세계에\u0007대한\u0007인간의\u0007이해를\u0007돕기\u0007위하여\u0007현실\u0007세 •사\u0007 용자의\u0007요구와\u0007불평의\u0007청취\u0007및\u0007해결 계에\u0007대한\u0007인식을\u0007추상적\u0007개념으로\u0007표현하는\u0007과정이다. •변\u0007 화\u0007요구에\u0007대한\u0007적응과\u0007성능\u0007향상에\u0007대한\u0007감시 •속\u0007 성들로\u0007기술된\u0007개체\u0007타입과\u0007이\u0007개체\u0007타입들\u0007간의\u0007관 •\u0007시스템\u0007감시\u0007및\u0007성능\u0007분석 계를\u0007이용하여\u0007현실\u0007세계를\u0007표현하는\u0007방법이다. •\u0007데이터\u0007사용\u0007추세,\u0007이용\u0007형태\u0007및\u0007각종\u0007통계\u0007등을\u0007종합,\u0007분석 •현\u0007 실\u0007세계에\u0007존재하는\u0007개체를\u0007인간이\u0007이해할\u0007수\u0007있는\u0007 응용 프로그래머 정보\u0007구조로\u0007표현하기\u0007때문에\u0007정보\u0007모델이라고도\u0007한다. •\u0007응용\u0007프로그래머는\u0007일반\u0007호스트\u0007언어로\u0007프로그램을\u0007작 •\u0007대표적으로\u0007개체-관계(E-R)\u0007모델이\u0007있다. 성할\u0007때\u0007데이터\u0007조작어를\u0007삽입해서\u0007일반\u0007사용자가\u0007응 논리적 데이터 모델 용\u0007프로그램을\u0007사용할\u0007수\u0007있게,\u0007인터페이스를\u0007제공할\u0007 •개\u0007 념적\u0007모델링\u0007과정에서\u0007얻은\u0007개념적\u0007구조를\u0007컴퓨터가\u0007 목적으로\u0007데이터베이스를\u0007접근하는\u0007사람들이다. 이해하고\u0007처리할\u0007수\u0007있는\u0007컴퓨터\u0007세계의\u0007환경에\u0007맞도 •\u0007응용\u0007프로그래머는\u0007C,\u0007COBOL,\u0007PASCAL\u0007등의\u0007호스트\u0007 록\u0007변환하는\u0007과정이다. 언어와\u0007DBMS가\u0007지원하는\u0007데이터\u0007조작어에\u0007능숙한\u0007컴 •필\u0007 드로\u0007기술된\u0007데이터\u0007타입과\u0007이\u0007데이터\u0007타입들\u0007간의\u0007 퓨터\u0007전문가이다. 관계를\u0007이용하여\u0007현실\u0007세계를\u0007표현하는\u0007방법이다. 일반 사용자 •단\u0007 순히\u0007데이터\u0007모델이라고\u0007하면\u0007논리적\u0007데이터\u0007모델을\u0007 일반\u0007사용자는\u0007보통\u0007터미널을\u0007이용하여\u0007데이터베이스에\u0007 의미한다. 있는\u0007자원을\u0007활용할\u0007목적으로\u0007질의어나\u0007응용\u0007프로그램을\u0007 •논\u0007 리적\u0007데이터\u0007모델은\u0007데이터\u0007간의\u0007관계를\u0007어떻게\u0007표 사용하여\u0007데이터베이스에\u0007접근하는\u0007사람들이다. 현하느냐에\u0007따라\u0007관계\u0007모델,\u0007계층\u0007모델,\u0007네트워크\u0007모델 로\u0007구분한다. 7 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 5] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.5, 14.3, 12.8, 12.5, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.3, 07.9, 05.5, 05.3, 04.9, 00.10, 00.3 014 데이터 모델에 표시할 사항 •구\u0007 조(Structure) :\u0007논리적으로\u0007표현된\u0007개체\u0007타입들\u0007간의\u0007 관계로서\u0007데이터\u0007구조\u0007및\u0007정적\u0007성질을\u0007표현함 •연\u0007 산(Operation) :\u0007데이터베이스에\u0007저장된\u0007실제\u0007데이터를\u0007 처리하는\u0007방법을\u0007표시하는\u0007것으로서\u0007데이터베이스를\u0007 조작하는\u0007기본\u0007도구임 •교수 개체의 구성 요소 •제\u0007 약조건(Constraint) :\u0007데이터베이스에\u0007저장될\u0007수\u0007있는\u0007 \u0007\u0007\u0007-\u0007속성\u0007:\u0007개체가\u0007가지고\u0007있는\u0007특성,\u0007교수번호,\u0007성명,\u0007전 실제\u0007데이터의\u0007논리적인\u0007제약조건을\u0007표시함 공,\u0007소속 \u0007\u0007\u0007-개체\u0007타입\u0007:\u0007속성으로만\u0007기술된\u0007개체의\u0007정의 핵심 13.8, 07.3, 05.9, 03.8, 02.3, 00.10, 99.10 015 데이터 모델의 구성 요소 \u0007\u0007\u0007-\u0007개체\u0007인스턴스\u0007:\u0007개체를\u0007구성하고\u0007있는\u0007각\u0007속성들이\u0007 값을\u0007가져\u0007하나의\u0007개체를\u0007나타내는\u0007것으로\u0007개체\u0007어 개체(Entity) 커런스(Occurence)\u0007라고도\u0007함 •데\u0007 이터베이스에\u0007표현하려는\u0007것으로,\u0007사람이\u0007생각하는\u0007 \u0007\u0007\u0007-개체\u0007세트\u0007:\u0007개체\u0007인스턴스의\u0007집합\u0007 개념이나\u0007정보\u0007단위\u0007같은\u0007현실\u0007세계의\u0007대상체이다. •\u0007유형,\u0007무형의\u0007정보로서\u0007서로\u0007연관된\u0007몇\u0007개의\u0007속성으로\u0007 핵심 14.3, 13.3, 12.8, 11.6, 09.8, 09.5, 09.3, 08.9, 08.3, 05.3, 04.5, 03.5, 01.6, 00.3, 99.8 구성된다. 016 개체-관계(Entity-Relationship) 모델 •\u0007파일\u0007시스템의\u0007레코드에\u0007대응하는\u0007것으로,\u0007어떤\u0007정보 •\u0007개념적\u0007데이터\u0007모델의\u0007가장\u0007대표적인\u0007것으로,\u00071976년\u0007 를\u0007제공하는\u0007역할을\u0007수행한다. Peter\u0007Chen에\u0007의해\u0007제안되었다. •실\u0007 세계에\u0007독립적으로\u0007존재하거나\u0007그\u0007자체로서도\u0007구별이\u0007 •개\u0007 체\u0007타입(Entity\u0007Type)과\u0007이들\u0007간의\u0007관계\u0007타입 가능하다. (Relationship\u0007Type)을\u0007이용해\u0007현실\u0007세계를\u0007개념적으 속성(Attribute) 로\u0007표현한다. •데\u0007 이터의\u0007가장\u0007작은\u0007논리적\u0007단위로서\u0007파일\u0007구조의\u0007데 •데\u0007 이터를\u0007개체(Entity),\u0007관계(Relationship),\u0007속성 이터\u0007항목\u0007또는\u0007데이터\u0007필드에\u0007해당된다. (Attribute)으로\u0007묘사한다. •개\u0007 체를\u0007구성하는\u0007항목이다. •E\u0007-R\u0007다이어그램으로\u0007표현한다. •\u0007특정\u0007DBMS를\u0007고려한\u0007것이\u0007아니기\u0007때문에\u0007관계\u0007표현 (cid:2264)(cid:2239) (cid:1104)(cid:2899)(cid:1)(cid:2241)(cid:3167)(cid:9)(cid:1768)(cid:3023)(cid:1624)(cid:1)(cid:3083)(cid:2641)(cid:10) 에\u0007제한이\u0007없다. (cid:1198)(cid:2299)(cid:2019)(cid:3344) (cid:2239)(cid:1914) (cid:2681)(cid:1173) (cid:2263)(cid:2264) } 02.5, 02.3, 01.9, 01.6, 01.3, 00.10, 00.7, 99.4 (cid:18)(cid:21)(cid:21)(cid:17)(cid:17)(cid:18) (cid:2705)(cid:2239)(cid:2771) (cid:1164)(cid:2941) (cid:2441)(cid:2193)(cid:1536) 핵심 14.3, 13.3, 12.8, 12.5, 11.6, 09.8, 09.3, 08.9, 08.5, 07.9, 07.5, 07.3, 06.9, 06.5, 04.9, 04.5, 04.3, 03.8, 03.5, 03.3, 02.9, (cid:1104)(cid:2899) (cid:18)(cid:21)(cid:22)(cid:17)(cid:17)(cid:19) (cid:1989)(cid:2606)(cid:2516) (cid:1975)(cid:2212)(cid:1947) (cid:1098)(cid:2583)(cid:1536) 017 E-R 다이어그램 (cid:2241)(cid:3167) (cid:18)(cid:21)(cid:23)(cid:17)(cid:17)(cid:18) (cid:1098)(cid:3333)(cid:2739) (cid:2343)(cid:1947) (cid:2226)(cid:2574)(cid:1536) • E-R\u0007모델의\u0007기본적인\u0007아이디어를\u0007시각적으로\u0007표현하\u0007 (cid:1198)(cid:2299)(cid:1)(cid:1104)(cid:2899) (cid:1104)(cid:2899)(cid:1)(cid:2635)(cid:2333)(cid:3106)(cid:2333) 기\u0007위한\u0007도구이다. • 개체\u0007간의\u0007관계는\u0007물론\u0007시스템\u0007내의\u0007역할을\u0007하는\u0007모든\u0007 관계(Relationship) 개체들,\u0007즉\u0007조직,\u0007부서,\u0007사용자,\u0007프로그램,\u0007데이터를\u0007 •개\u0007 체\u0007간의\u0007관계\u0007또는\u0007속성\u0007간의\u0007관계 모두\u0007표시한다. •다\u0007 음\u0007그림의\u0007관계는\u0007교수가\u0007학생을\u0007지도하는\u0007관계이다. 8 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 6] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 기 호 기호 이름 의 미 핵심 12.3, 02.3, 01.6, 00.7, 99.10, 99.8 019 계층형 데이터 모델 사각형 개체(Entity)\u0007타입 •데\u0007 이터의\u0007논리적\u0007구조도가\u0007트리\u0007형태이며,\u0007개체가\u0007트 리를\u0007구성하는\u0007노드\u0007역할을\u0007한다. 마름모 관계(Relationship)\u0007타입 •개\u0007 체\u0007집합에\u0007대한\u0007속성\u0007관계를\u0007표시하기\u0007위해\u0007개체를\u0007 노드로\u0007표현하고\u0007개체\u0007집합들\u0007사이의\u0007관계를\u0007링크로\u0007 타원 속성(Attribute) 연결한다. •개\u0007 체\u0007간의\u0007관계를\u0007부모와\u0007자식\u0007간의\u0007관계로\u0007표현한다. 밑줄\u0007타원 기본키\u0007속성 •개\u0007 체\u0007타입\u0007간에는\u0007상위와\u0007하위\u0007관계가\u0007존재하며,\u0007일\u0007대\u0007 다(1:N)\u0007대응\u0007관계만\u0007존재한다. 복합\u0007속성 •레\u0007 코드\u0007삭제\u0007시\u0007연쇄\u0007삭제(Triggered\u0007Delete)가\u0007된다.\u0007 (cid:79) (cid:78) 복수\u0007타원 \u0007\u0007성명은\u0007성과\u0007이름으로\u0007구 (cid:79) (cid:78) •개\u0007 체\u0007타입들\u0007간에는\u0007사이클(Cycle)이\u0007허용되지\u0007않는다. 성 (cid:79) (cid:78) (cid:79) (cid:78) •계\u0007 층형\u0007모델에서는\u0007개체(Entity)를\u0007세그먼트(Segment) (cid:79) (cid:78) 라\u0007부른다. 1:1,\u00071:N,\u0007N:M\u0007등의\u0007개체\u0007관계 (cid:79) (cid:78) 관계 에\u0007대해\u0007선\u0007위에\u0007대응수\u0007기술 •대\u0007 표적인\u0007DBMS는\u0007IMS이다. 선,\u0007링크 개체\u0007타입과\u0007속성\u0007연결 핵심 14.8, 10.9, 05.5, 02.5 020 망(그래프, 네트워크)형 데이터 모델 •C\u0007ODASYL이\u0007제안한\u0007것으로,\u0007CODASYL\u0007DBTG\u0007모델 핵심 04.5, 00.10 018 관계형 데이터 모델 이라고도\u0007한다. •그\u0007 래프를\u0007이용해서\u0007데이터\u0007논리\u0007구조를\u0007표현한\u0007데이터\u0007 •계\u0007 층\u0007모델과\u0007망\u0007모델의\u0007복잡한\u0007구조를\u0007단순화시킨\u0007모 모델이다. 델이다. •상\u0007 위와\u0007하위\u0007레코드\u0007사이에서\u0007다\u0007대\u0007다(N:M)\u0007대응\u0007관 •표\u0007 (Table)를\u0007이용해서\u0007데이터\u0007상호\u0007관계를\u0007정의하는\u0007 계를\u0007만족하는\u0007구조이다. DB\u0007구조를\u0007말한다. •\u0007상위의\u0007레코드를\u0007Owner,\u0007하위의\u0007레코드를\u0007Member라\u0007 •데\u0007 이터\u0007간의\u0007관계를\u0007기본키(Primary\u0007Key)와\u0007이를\u0007참 하여\u0007Owner-Member\u0007관계라고도\u0007한다. 조하는\u0007외래키(Foreign\u0007Key)로\u0007표현한다. •레코드\u0007타입\u0007간의\u0007관계는\u00071:1,\u00071:N,\u0007N:M이\u0007될\u0007수\u0007있다. •대\u0007 표적인 DBMS :\u0007Oracle,\u0007MS-SQL,\u0007Informix\u0007등 •대표적인 DBMS\u0007:\u0007DBTG,\u0007EDBS,\u0007TOTAL\u0007등 •1\u0007:1,\u00071:N,\u0007M:N\u0007관계를\u0007자유롭게\u0007표현할\u0007수\u0007있다. • 장점 :\u0007간결하고,\u0007보기\u0007편리하며,\u0007다른\u0007데이터베이스로 06.3, 05.9, 05.5, 05.4, 04.9, 01.9, 00.3, 99.4 의\u0007변환이\u0007용이함 핵심 14.8. 14.3, 13.8, 13.6, 12.8, 12.5, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.3, 06.9, 021 데이터베이스 설계 • 단점 :\u0007성능이\u0007다소\u0007떨어짐 데이터베이스 설계 시 고려사항 •데\u0007 이터의 무결성 유지 :\u0007삽입,\u0007삭제,\u0007갱신\u0007등의\u0007연산\u0007후에 도\u0007데이터베이스에\u0007저장된\u0007데이터가\u0007정해진\u0007제약조건 을\u0007항상\u0007만족해야\u0007함 •데\u0007 이터의 일관성 유지 :\u0007데이터베이스에\u0007저장된\u0007데이터들\u0007 사이나,\u0007특정\u0007질의에\u0007대한\u0007응답이\u0007처음부터\u0007끝까지\u0007변 9 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 7] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 함없이\u0007일정해야\u0007함 •트\u0007 랜잭션을\u0007작성한다. •데\u0007 이터의 회복성 유지 :\u0007시스템에\u0007장애가\u0007발생했을\u0007때\u0007장 •물\u0007 리적\u0007설계\u0007단계에\u0007꼭\u0007포함되어야\u0007할\u0007것은\u0007저장\u0007레코 애\u0007발생\u0007직전의\u0007상태로\u0007복구할\u0007수\u0007있어야\u0007함 드의\u0007양식\u0007설계,\u0007레코드\u0007집중의\u0007분석\u0007및\u0007설계,\u0007접근\u0007경 로\u0007등이다. •데\u0007 이터의 보안성 유지 :\u0007불법적인\u0007데이터의\u0007노출\u0007또는\u0007변 경이나\u0007손실로부터\u0007보호할\u0007수\u0007있어야\u0007함 •물\u0007 리적 설계 시 고려사항 •데\u0007 이터의 효율성 유지 :\u0007응답시간의\u0007단축,\u0007시스템의\u0007생산 \u0007\u0007\u0007-\u0007인덱스의\u0007구조 성,\u0007저장\u0007공간의\u0007최적화\u0007등이\u0007가능해야\u0007함 \u0007\u0007\u0007-\u0007레코드의\u0007크기\u0007및\u0007개수 •데\u0007 이터베이스의 확장성 유지 :\u0007데이터베이스\u0007운영에\u0007영향 \u0007\u0007\u0007-\u0007파일에\u0007대한\u0007트랜잭션의\u0007갱신과\u0007참조\u0007성향 을\u0007주지\u0007않으면서\u0007지속적으로\u0007데이터를\u0007추가할\u0007수\u0007있어 \u0007\u0007\u0007-\u0007성능\u0007향상을\u0007위한\u0007개념\u0007스키마의\u0007변경\u0007여부\u0007검토 야\u0007함 \u0007\u0007\u0007-\u0007빈번한\u0007질의와\u0007트랜잭션들의\u0007수행속도를\u0007높이기\u0007위 개념적 설계(정보 모델링, 개념화) 한\u0007고려 •정\u0007 보의\u0007구조를\u0007얻기\u0007위하여\u0007현실\u0007세계의\u0007무한성과\u0007계속 \u0007\u0007\u0007-\u0007시스템\u0007운용\u0007시\u0007파일\u0007크기의\u0007변화\u0007가능성 성을\u0007이해하고,\u0007다른\u0007사람과\u0007통신하기\u0007위하여\u0007현실\u0007세 •물\u0007 리적 설계 옵션 선택 시 고려 사항 계에\u0007대한\u0007인식을\u0007추상적\u0007개념으로\u0007표현하는\u0007과정이다. \u0007\u0007\u0007-\u0007반응시간(Response\u0007Time)\u0007:\u0007트랜잭션\u0007수행을\u0007요구 •스\u0007 키마\u0007모델링과\u0007트랜잭션\u0007모델링을\u0007병행하여\u0007수행한다. 한\u0007시점부터\u0007처리\u0007결과를\u0007얻을\u0007때까지의\u0007경과시간 •요\u0007 구\u0007분석\u0007단계에서\u0007나온\u0007결과(요구\u0007조건\u0007명세)를\u0007DBMS에\u0007 \u0007\u0007\u0007-\u0007공간\u0007활용도(Space\u0007Utilization)\u0007:\u0007데이터베이스\u0007파일 독립적인\u0007E-R\u0007다이어그램(개체\u0007관계도)으로\u0007작성한다. 과\u0007액세스\u0007경로\u0007구조에\u0007의해\u0007사용되는\u0007저장공간의\u0007양 •\u0007DBMS에\u0007독립적인\u0007개념\u0007스키마를\u0007설계한다.\u0007 \u0007\u0007\u0007-\u0007트랜잭션\u0007처리량(Transaction\u0007Throughput)\u0007:\u0007단위 논리적 설계(데이터 모델링) 시간\u0007동안\u0007데이터베이스\u0007시스템에\u0007의해\u0007처리될\u0007수\u0007있 •현\u0007 실\u0007세계에서\u0007발생하는\u0007자료를\u0007컴퓨터가\u0007처리할\u0007수\u0007 는\u0007트랜잭션의\u0007평균\u0007개수 있는\u0007물리적\u0007저장장치에\u0007저장할\u0007수\u0007있도록\u0007변환하기\u0007 위해\u0007특정\u0007DBMS가\u0007지원하는\u0007논리적\u0007자료\u0007구조로\u0007변 02.5, 01.9, 00.7 핵심 14.8, 14.5, 13.6, 13.3, 12.5, 12.3, 11.6, 09.5, 08.9, 06.9, 06.5, 05.9, 05.5, 05.4, 04.9, 04.5, 04.3, 03.8, 03.5, 03.3, 02.9, 환시키는\u0007과정이다. 022 데이터베이스 설계 순서 •개\u0007 념\u0007세계의\u0007데이터를\u0007필드로\u0007기술된\u0007데이터\u0007타입과\u0007 요구\u0007분석 요구\u0007조건\u0007명세서\u0007작성 이\u0007데이터\u0007타입들\u0007간의\u0007관계로\u0007표현되는\u0007논리적\u0007구조 의\u0007데이터로\u0007모델화한다. ↓ 개념적\u0007설계 개념\u0007스키마,\u0007트랜잭션\u0007모델링,\u0007E-R\u0007모델 •개\u0007 념적\u0007설계가\u0007개념\u0007스키마를\u0007설계하는\u0007단계라면\u0007논리적\u0007 ↓ 설계에서는\u0007개념\u0007스키마를\u0007평가\u0007및\u0007정제하고\u0007특정\u0007 목표\u0007DBMS에\u0007맞는\u0007스키마\u0007설계,\u0007트랜잭션\u0007인터페이 논리적\u0007설계 DBMS에\u0007종속적인\u0007논리적\u0007스키마를\u0007설계하는\u0007단계이다. 스\u0007설계 ↓ •트\u0007 랜잭션의\u0007인터페이스를\u0007설계한다. 물리적\u0007설계 목표\u0007DBMS에\u0007맞는\u0007물리적\u0007구조의\u0007데이터로\u0007변환 •관\u0007 계형\u0007데이터베이스라면\u0007테이블을\u0007설계하는\u0007단계이다. ↓ 특정\u0007DBMS의\u0007DDL로\u0007데이터베이스\u0007생성,\u0007트랜잭션\u0007 물리적 설계(데이터 구조화) 구현 작성 •논\u0007 리적\u0007설계\u0007단계에서\u0007논리적\u0007구조로\u0007표현된\u0007데이터를\u0007 디스크\u0007등의\u0007물리적\u0007저장장치에\u0007저장할\u0007수\u0007있는\u0007물리 적\u0007구조의\u0007데이터로\u0007변환하는\u0007과정이다. •데\u0007 이터베이스\u0007파일의\u0007저장\u0007구조,\u0007레코드의\u0007형식,\u0007접근\u0007 경로와\u0007같은\u0007정보를\u0007사용하여\u0007데이터가\u0007컴퓨터에\u0007저장 되는\u0007방법을\u0007묘사한다. 10 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 8] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 01.9, 01.6, 00.10, 00.3 06.3, 05.9, 05.5, 05.3, 04.9 핵심 14.8, 14.3, 12.5, 12.3, 11.8, 09.5, 08.5, 08.3, 07.3, 06.9, 06.5, 06.3, 05.4, 05.3, 04.5, 04.3, 03.5, 03.3, 02.9, 02.5, 02.3, 핵심 14.5, 14.3, 13.8, 13.6, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.3, 08.9, 08.3, 07.9, 07.3, 06.9, 06.5, 023 관계 데이터베이스의 Relation 구조 024 릴레이션의 특징 릴레이션은\u0007데이터들을\u0007표(Table)의\u0007형태로\u0007표현한\u0007것으 <학생> 릴레이션 로,\u0007구조를\u0007나타내는\u0007릴레이션\u0007스키마와\u0007실제\u0007값들인\u0007릴레 이션\u0007인스턴스로\u0007구성된다. 학번 이름 학년 신장 학과 89001 홍길동 2 170 CD <학생> 릴레이션 (cid:1854)(cid:1768)(cid:2633)(cid:2252)(cid:1)(cid:2333)(cid:3075)(cid:1859) (cid:2264)(cid:2239) 89002 이순신 1 169 CD (cid:29)(cid:3295)(cid:2212)(cid:31)(cid:1)(cid:1854)(cid:1768)(cid:2633)(cid:2252) 87012 임꺽정 2 180 ID (cid:1)(cid:3295)(cid:2019)(cid:1) (cid:2633)(cid:1844)(cid:1) (cid:3295)(cid:1433)(cid:1) (cid:2344)(cid:2658)(cid:1) (cid:3295)(cid:1175) 86032 장보고 4 174 ED (cid:1)(cid:25)(cid:26)(cid:17)(cid:17)(cid:18)(cid:1) (cid:3352)(cid:1249)(cid:1586)(cid:1) (cid:19)(cid:1) (cid:18)(cid:24)(cid:17)(cid:1) (cid:36)(cid:37) (cid:3162)(cid:3282) (cid:1)(cid:25)(cid:26)(cid:17)(cid:17)(cid:19)(cid:1) (cid:2633)(cid:2301)(cid:2344)(cid:1) (cid:18)(cid:1) (cid:18)(cid:23)(cid:26)(cid:1) (cid:36)(cid:37) •한\u0007릴레이션에\u0007포함된\u0007튜플들은\u0007모두\u0007상이하다. (cid:1)(cid:25)(cid:24)(cid:17)(cid:18)(cid:19)(cid:1) (cid:2640)(cid:1282)(cid:2687)(cid:1) (cid:19)(cid:1) (cid:18)(cid:25)(cid:17)(cid:1) (cid:42)(cid:37)  <학생> 릴레이션을 구성하는 홍길동 레코드는 홍길동에 대한 학 (cid:1)(cid:25)(cid:23)(cid:17)(cid:20)(cid:19)(cid:1) (cid:2658)(cid:2049)(cid:1162)(cid:1) (cid:21)(cid:1) (cid:18)(cid:24)(cid:21)(cid:1) (cid:38)(cid:37) 적사항을 나타내는 것으로 <학생> 릴레이션 내에서는 유일하다. (cid:1854)(cid:1768)(cid:2633)(cid:2252)(cid:1)(cid:2635)(cid:2333)(cid:3106)(cid:2333) •한\u0007릴레이션에\u0007포함된\u0007튜플\u0007사이에는\u0007순서가\u0007없다. (cid:3295)(cid:1433)(cid:2628)(cid:1)(cid:1576)(cid:1899)(cid:2635)  < 학생> 릴레이션에서 홍길동 레코드와 임꺽정 레코드의 위치가 튜플(Tuple) 바뀌어도 상관없다. •릴\u0007 레이션을\u0007구성하는\u0007각각의\u0007행 •튜\u0007 플들의\u0007삽입,\u0007삭제\u0007등의\u0007작업으로\u0007인해\u0007릴레이션은\u0007 •속\u0007 성의\u0007모임으로\u0007구성된다. 시간에\u0007따라\u0007변한다. •파\u0007 일\u0007구조에서\u0007레코드와\u0007같은\u0007의미이다.  < 학생> 릴레이션에 새로운 학생의 레코드를 삽입하거나 기존 학 •튜\u0007 플의\u0007수\u0007=\u0007카디널리티(Cardinality)\u0007=\u0007기수\u0007=\u0007대응수 생에 대한 레코드를 삭제함으로써 테이블은 내용 면에서나 크기 면에서 변하게 된다. 속성(Attribute, 애트리뷰트) •릴\u0007 레이션\u0007스키마를\u0007구성하는\u0007속성들\u0007간의\u0007순서는\u0007중요 •릴\u0007 레이션을\u0007구성하는\u0007각각의\u0007열 하지\u0007않다. •데\u0007 이터베이스를\u0007구성하는\u0007가장\u0007작은\u0007논리적\u0007단위이다.  학 번, 이름 등의 속성을 나열하는 순서가 이름, 학번 순으로 바뀌 •파\u0007 일\u0007구조\u0007상의\u0007데이터\u0007항목\u0007또는\u0007데이터\u0007필드에\u0007해당된다. 어도 데이터 처리에는 아무런 영향을 미치지 않는다. •개\u0007 체의\u0007특성을\u0007기술한다. •속\u0007 성의\u0007유일한\u0007식별을\u0007위해\u0007속성의\u0007명칭은\u0007유일해야\u0007하 •속성의\u0007수\u0007=\u0007디그리(Degree)\u0007=\u0007차수 지만,\u0007속성을\u0007구성하는\u0007값은\u0007동일한\u0007값이\u0007있을\u0007수\u0007있다. 도메인(Domain)  각 학생의 학년을 기술하는 속성인 ‘학년’은 다른 속성명들과 구 •하\u0007 나의\u0007애트리뷰트가\u0007취할\u0007수\u0007있는\u0007같은\u0007타입의\u0007원자 분되어 유일해야 하지만 ‘학년’ 속성에는 2, 1, 2, 4 등이 입력된 것 (Atomic)값들의\u0007집합 처럼 동일한 값이 있을 수 있다. •실\u0007 제\u0007애트리뷰트\u0007값이\u0007나타날\u0007때\u0007그\u0007값의\u0007합법\u0007여부를\u0007 •릴\u0007 레이션을\u0007구성하는\u0007튜플을\u0007유일하게\u0007식별하기\u0007위해\u0007 시스템이\u0007검사하는\u0007데에도\u0007이용된다. 속성들의\u0007부분집합을\u0007키(Key)로\u0007설정한다.  성 별 애트리뷰트의 도메인은 ‘남’과 ‘여’로, 그 외의 값은 입력될  < 학생> 릴레이션에서는 ‘학번’이나 ‘이름’이 튜플들을 구분하는 유 수 없다. 일한 값인 키가 될 수 있다. 릴레이션 인스턴스(Relation Instance) •속\u0007 성은\u0007더\u0007이상\u0007쪼갤\u0007수\u0007없는\u0007원자값만을\u0007저장한다. 데이터\u0007개체를\u0007구성하고\u0007있는\u0007속성들에\u0007데이터\u0007타입이\u0007  ‘ 학년’에 저장된 1, 2, 4 등은 더 이상 세분화할 수 없다. 정의되어\u0007구체적인\u0007데이터\u0007값을\u0007갖고\u0007있는\u0007것을\u0007말한다.\u0007 11 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 9] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.5, 13.8, 13.6, 13.3, 12.8, 12.3, 11.3, 10.9, 10.5, 10.3, 09.5, 07.5, 06.9, 05.5, 02.5, 00.10, 99.4 •\u0007후보키가\u0007둘\u0007이상일\u0007때\u0007기본키를\u0007제외한\u0007나머지\u0007 025 키(Key)의 개념 및 종류 대체키 후보키들을\u0007말함 (Alternate •\u0007보조키라고도\u0007함 키(Key)는\u0007데이터베이스에서\u0007조건에\u0007만족하는\u0007튜플을\u0007찾 Key) \u0007\u0007\u0007<학생>\u0007릴레이션에서\u0007‘학번’을\u0007기본키로\u0007정의하 거나\u0007순서대로\u0007정렬할\u0007때\u0007다른\u0007튜플들과\u0007구별할\u0007수\u0007있는\u0007 면\u0007‘주민번호’는\u0007대체키가\u0007된다. 유일한\u0007기준이\u0007되는\u0007애트리뷰트(속성)이다. •\u0007슈퍼키는\u0007한\u0007릴레이션\u0007내에\u0007있는\u0007속성들의\u0007집합으 로\u0007구성된\u0007키로서\u0007릴레이션을\u0007구성하는\u0007모든\u0007튜플\u0007 <학생> 릴레이션 중\u0007슈퍼키로\u0007구성된\u0007속성의\u0007집합과\u0007동일한\u0007값은\u0007 학번 주민번호 성명 성별 슈퍼키 나타나지\u0007않는다. (Super •\u0007릴레이션을\u0007구성하는\u0007모든\u0007튜플에\u0007대해\u0007유일성은\u0007 1001 810429-1231457 김형석 남 Key) 만족시키지만,\u0007최소성은\u0007만족시키지\u0007못함 1002 800504-1546781 김현천 남 \u0007\u0007\u0007<학생>\u0007릴레이션에서는\u0007‘학번’,\u0007‘주민번호’,\u0007‘학번’ 1003 811215-2547842 류기선 여 +‘주민번호’,\u0007‘주민번호’+‘성명’,\u0007‘학번’+‘주민번 호’+‘성명’\u0007등으로\u0007슈퍼키를\u0007구성할\u0007수\u0007있다. 1004 801225-2201248 홍영선 여 •\u0007관계(Relationship)를\u0007맺고\u0007있는\u0007릴레이션\u0007R1,\u0007R2에 서\u0007릴레이션\u0007R1이\u0007참조하고\u0007있는\u0007릴레이션\u0007R2의\u0007 <수강> 릴레이션 기본키와\u0007같은\u0007R1\u0007릴레이션의\u0007속성 학번 과목명 •\u0007외래키는\u0007참조되는\u0007릴레이션의\u0007기본키와\u0007대응되 어\u0007릴레이션\u0007간에\u0007참조\u0007관계를\u0007표현하는데\u0007중요한\u0007 1001 영어 외래키 도구임 1001 전산 (Foreign •\u0007외래키로\u0007지정되면\u0007참조\u0007테이블의\u0007기본키에\u0007없는\u0007 1002 영어 Key) 값은\u0007입력할\u0007수\u0007없음 1003 수학 \u0007\u0007\u0007<수강>\u0007릴레이션이\u0007<학생>\u0007릴레이션을\u0007참조하고\u0007 있으므로\u0007<학생>\u0007릴레이션의\u0007‘학번’은\u0007기본키이 1004 영어 고,\u0007<수강>\u0007릴레이션의\u0007‘학번’은\u0007외래키이다. 1004 전산 \u0007\u0007\u0007<수강>\u0007릴레이션의\u0007‘학번’에는\u0007<학생>\u0007릴레이션 의\u0007‘학번’에\u0007없는\u0007값은\u0007입력할\u0007수\u0007없다. •\u0007릴레이션을\u0007구성하는\u0007속성들\u0007중에서\u0007튜플을\u0007유일 하게\u0007식별하기\u0007위해\u0007사용하는\u0007속성들의\u0007부분집합,\u0007 잠깐만요 ! \u0007 즉\u0007기본키로\u0007사용할\u0007수\u0007있는\u0007속성들을\u0007말함 널 값(NULL Value) •\u0007모든\u0007릴레이션은\u0007반드시\u0007하나\u0007이상의\u0007후보키를\u0007가 데이터베이스에서\u0007아직\u0007알려지지\u0007\u0007않았거나\u0007모르는\u0007값으로서\u0007“해당\u0007 후보키 져야\u0007함 없음”\u0007등의\u0007이유로\u0007정보\u0007부재를\u0007나타내기\u0007위해\u0007사용하는,\u0007이론적으로\u0007 (Candidate 아무것도\u0007없는\u0007특수한\u0007데이터입니다. •\u0007릴레이션에\u0007있는\u0007모든\u0007튜플에\u0007대해서\u0007유일성과\u0007최 Key) 소성을\u0007만족시켜야\u0007함 최소성과 유일성 \u0007 < 학생>\u0007릴레이션에서\u0007‘학번’이나\u0007‘주민번호’는\u0007 ‘학번’+‘주민번호’를\u0007사용하여\u0007슈퍼키를\u0007만들면\u0007다른\u0007튜플들과\u0007구분할\u0007 다른\u0007레코드를\u0007유일하게\u0007구별할\u0007수\u0007있는\u0007기본 수\u0007있는\u0007유일성은\u0007만족하지만,\u0007‘학번’이나\u0007‘주민번호’\u0007하나만\u0007가지고도\u0007 키로\u0007사용할\u0007수\u0007있으므로\u0007후보키이다. 다른\u0007튜플들을\u0007구분할\u0007수\u0007있으므로\u0007최소성은\u0007만족시키지\u0007못합니다. •\u0007후보키\u0007중에서\u0007선택한\u0007주키(Main\u0007Key) •\u0007한\u0007릴레이션에서\u0007특정\u0007튜플을\u0007유일하게\u0007구별할\u0007수\u0007 있는\u0007속성 핵심 13.6, 11.6, 10.3, 08.5, 08.3, 07.9, 07.5, 06.3, 05.5, 04.9, 04.3, 03.8, 02.5, 02.3, 01.6, 00.10, 99.8, 99.4 026 무결성(Integrity) •\u0007Null\u0007값을\u0007가질\u0007수\u0007없음 •\u0007기본키로\u0007정의된\u0007속성에는\u0007동일한\u0007값이\u0007중복되어\u0007 • 개체 무결성 :\u0007릴레이션에서\u0007기본키를\u0007구성하는\u0007속성은\u0007 기본키 저장될\u0007수\u0007없음 (Primary  < 학생>\u0007릴레이션에서는\u0007‘학번’이나\u0007‘주민번호’가\u0007 널(NULL)\u0007값이나\u0007중복값을\u0007가질\u0007수\u0007없음 Key) 기본키가\u0007될\u0007수\u0007있고,\u0007<수강>\u0007릴레이션에서는\u0007  <학생> 릴레이션에서 ‘학번’이 기본키로 정의되면 튜플을 추가할 ‘학번’+‘과목명’으로\u0007조합해야\u0007기본키가\u0007만들어 때 ‘주민번호’나 ‘성명’ 필드에는 값을 입력하지 않아도 되지만 ‘학 진다.  ‘ 학번’이\u0007<학생>\u0007릴레이션의\u0007기본키로\u0007정의되면\u0007 번’ 속성에는 반드시 값을 입력해야 한다. 또한 ‘학번’ 속성에는 이 이미\u0007입력된\u0007‘1001’은\u0007다른\u0007튜플의\u0007‘학번’\u0007속성의\u0007 미 한 번 입력한 속성값을 중복하여 입력할 수 없다. 값으로\u0007입력할\u0007수\u0007없다. •참\u0007 조 무결성 :\u0007외래키\u0007값은\u0007NULL이거나\u0007참조\u0007릴레이션 의\u0007기본키\u0007값과\u0007동일해야\u0007함,\u0007즉\u0007릴레이션은\u0007참조할\u0007수\u0007 12 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 10] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 없는\u0007외래키\u0007값을\u0007가질\u0007수\u0007없음 핵심 14.3, 13.6, 12.5, 10.5, 10.3, 09.8, 08.9, 06.5, 05.5, 04.9, 02.9, 00.3, 99.4 029 관계해석  <수강> 릴레이션의 ‘학번’ 속성에는 <학생> 릴레이션의 ‘학번’ 속성 에 없는 값은 입력할 수 없다. •\u0007코드(E.\u0007F.\u0007Codd)가\u0007수학의\u0007Predicate\u0007Calculus(술어\u0007해 • 도메인 무결성 :\u0007특정\u0007속성의\u0007값이\u0007그\u0007속성이\u0007정의된\u0007도 석)에\u0007기반을\u0007두고\u0007관계\u0007데이터베이스를\u0007위해\u0007제안했다. 메인에\u0007속한\u0007값이어야\u0007한다는\u0007규정 •\u0007관계해석은\u0007원하는\u0007정보가\u0007무엇이라는\u0007것만\u0007정의하는\u0007  성별 속성의 도메인은 ‘남’과 ‘여’로, 그 외의 값은 입력할 수 없다. 비절차적\u0007특성을\u0007지닌다. •원\u0007 하는\u0007정보를\u0007정의할\u0007때는\u0007계산\u0007수식을\u0007사용한다. 핵심 14.5, 11.8, 11.6, 11.3, 10.3, 09.8 •튜\u0007 플\u0007관계해석과\u0007도메인\u0007관계해석이\u0007있다. 027 관계대수의 개요 •기\u0007 본적으로\u0007관계해석과\u0007관계대수는\u0007관계\u0007데이터베이 • 관계형\u0007데이터베이스에서\u0007원하는\u0007정보와\u0007그\u0007정보를\u0007어 스를\u0007처리하는\u0007기능과\u0007능력\u0007면에서\u0007동등하다. 떻게\u0007유도하는가를\u0007기술하는\u0007절차적인\u0007언어이다. •질\u0007 의어로\u0007표현한다. • 릴레이션을\u0007처리하기\u0007위해\u0007연산자와\u0007연산규칙을\u0007제공하는\u0007 언어로\u0007피연산자가\u0007릴레이션이고,\u0007결과도\u0007릴레이션이다.\u0007 핵심 14.5, 13.8, 13.3, 12.5, 12.3, 11.8, 10.9, 10.5, 09.8, 09.3, 08.5, 07.5, 06.5, 05.3, 03.3 030 정규화(Normalization) • 질의에\u0007대한\u0007해를\u0007구하기\u0007위해\u0007수행해야\u0007할\u0007연산의\u0007순 서를\u0007명시한다. 정규화의 개요 • 순수\u0007관계\u0007연산자와\u0007일반\u0007집합\u0007연산자가\u0007있다. •함\u0007 수적\u0007종속성\u0007등의\u0007종속성\u0007이론을\u0007이용하여\u0007잘못\u0007설계 • 순수 관계 연산자\u0007:\u0007Select,\u0007Project,\u0007Join,\u0007Division 된\u0007관계형\u0007스키마를\u0007더\u0007작은\u0007속성의\u0007세트로\u0007쪼개어\u0007바 • 일반 집합 연산자\u0007:\u0007UNION(합집합),\u0007INTERSECTION\u0007 람직한\u0007스키마로\u0007만들어\u0007가는\u0007과정이다. (교집합),\u0007DIFFERENCE(차집합),\u0007Cartesian\u0007 •정\u0007 규형에는\u0007제1정규형,\u0007제2정규형,\u0007제3정규형,\u0007BCNF Product(교차곱) 형,\u0007제4정규형,\u0007제5정규형이\u0007있으며,\u0007차수가\u0007높아질수 록\u0007만족시켜야\u0007할\u0007제약\u0007조건이\u0007늘어난다. 핵심 14.8, 08.5, 07.5, 07.3, 05.3, 04.5, 03.8, 02.9, 02.5, 02.3, 00.3, 99.4 •\u0007정규화는\u0007데이터베이스의\u0007논리적\u0007설계\u0007단계에서\u0007수행 028 순수 관계 연산자 한다. 관계\u0007데이터베이스에\u0007적용할\u0007수\u0007있도록\u0007특별히\u0007개발된\u0007 •정\u0007 규화는\u0007논리적\u0007처리\u0007및\u0007품질에\u0007큰\u0007영향을\u0007미친다. 관계\u0007연산자이다. 정규화의 목적 •데\u0007 이터\u0007구조의\u0007안정성을\u0007최대화한다. 연산자 특 징 •어\u0007 떠한\u0007릴레이션이라도\u0007데이터베이스\u0007내에서\u0007표현\u0007가 •\u0007릴레이션에\u0007존재하는\u0007튜플\u0007중에서\u0007선택\u0007조건을\u0007만족하 는\u0007튜플의\u0007부분집합을\u0007구하여\u0007새로운\u0007릴레이션을\u0007만듦 능하게\u0007만든다. Select •\u0007릴레이션의\u0007행(가로)에\u0007해당하는\u0007튜플을\u0007구하는\u0007것이 •\u0007효과적인\u0007검색\u0007알고리즘을\u0007생성할\u0007수\u0007있다. 므로\u0007수평\u0007연산이라고도\u0007함 •\u0007연산자의\u0007기호는\u0007그리스\u0007문자\u0007시그마(σ)를\u0007사용함 •중\u0007 복을\u0007배제하여\u0007삽입,\u0007삭제,\u0007갱신\u0007이상의\u0007발생을\u0007방지 •\u0007주어진\u0007릴레이션에서\u0007속성\u0007List에\u0007제시된\u0007Attribute만을\u0007 한다. 추출하는\u0007연산 •\u0007데이터\u0007삽입\u0007시\u0007릴레이션을\u0007재구성할\u0007필요성을\u0007줄인다. Project •\u0007릴레이션의\u0007열(세로)에\u0007해당하는\u0007Attribute를\u0007추출하는\u0007 것이므로\u0007수직\u0007연산자라고도\u0007함 •\u0007연산자의\u0007기호는\u0007그리스\u0007문자\u0007파이(π)를\u0007사용함 •\u0007공통\u0007속성을\u0007중심으로\u00072개의\u0007릴레이션을\u0007하나로\u0007합쳐 Join 서\u0007새로운\u0007릴레이션을\u0007만드는\u0007연산 •\u0007연산자의\u0007기호는\u0007▷◁를\u0007사용함 •\u0007X\u0007⊃\u0007Y인\u00072개의\u0007릴레이션에서\u0007R(X)와\u0007S(Y)가\u0007있을\u0007때,\u0007 Division R의\u0007속성이\u0007S의\u0007속성값을\u0007모두\u0007가진\u0007튜플에서\u0007S가\u0007가 진\u0007속성을\u0007제외(분리)한\u0007속성만을\u0007구하는\u0007연산 13 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 11] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.3, 12.8, 11.8, 09.5, 07.5, 07.3, 06.3, 05.9, 05.4 031 Anomaly(이상)의 개념 및 종류 이행적\u0007함수\u0007종속\u0007제거 결정자이면서\u0007후보키가\u0007아닌\u0007것\u0007제거 이상(Anomaly)의 개념 다치\u0007종속\u0007제거 •정\u0007 규화(Normalization)를\u0007거치지\u0007않은\u0007데이터베이스\u0007 조인\u0007종속성\u0007이용 내에\u0007데이터들이\u0007불필요하게\u0007중복되어\u0007릴레이션\u0007조작\u0007 시\u0007발생하는\u0007예기치\u0007못한\u0007곤란한\u0007현상이다. 함수적 종속 관계 •애\u0007 트리뷰트들\u0007간에\u0007존재하는\u0007여러\u0007종속\u0007관계를\u0007하나의\u0007 어떤\u0007릴레이션\u0007R에서\u0007X와\u0007Y를\u0007각각\u0007R의\u0007애트리뷰트\u0007집 릴레이션에\u0007표현하기\u0007때문에\u0007이상이\u0007발생한다. 합의\u0007부분\u0007집합이라고\u0007할\u0007경우,\u0007애트리뷰트\u0007X의\u0007값\u0007각각 이상의 종류 에\u0007대해\u0007시간에\u0007관계없이\u0007항상\u0007애트리뷰트\u0007Y의\u0007값이\u0007오 직\u0007하나만\u0007연관되어\u0007있을\u0007때\u0007Y는\u0007X에\u0007함수\u0007종속적이라고\u0007 릴레이션에\u0007데이터를\u0007삽입할\u0007때\u0007의도와는\u0007 삽입 이상 하며,\u0007X→Y와\u0007같이\u0007표기한다. 관계없이\u0007원하지\u0007않은\u0007값들도\u0007함께\u0007삽입되는\u0007 (Insertion Anomaly) 현상 \u0007<수강>\u0007릴레이션이\u0007(학번,\u0007이름,\u0007과목명)으로\u0007되어\u0007있 을\u0007때,\u0007‘학번’이\u0007결정되면\u0007‘`과목명’에\u0007상관없이\u0007‘`학번’ 릴레이션에서\u0007한\u0007튜플을\u0007삭제할\u0007때\u0007의도와는\u0007 삭제 이상 관계없는\u0007값들도\u0007함께\u0007삭제되는\u0007연쇄\u0007삭제\u0007 에는\u0007항상\u0007같은\u0007이름이\u0007대응된다.\u0007‘`학번’에\u0007따라\u0007‘이름’ (Deletion Anomaly) 현상 이\u0007결정될\u0007때\u0007‘이름’을\u0007‘학번’에\u0007함수\u0007종속적이라고\u0007하 릴레이션에서\u0007튜플에\u0007있는\u0007속성값을\u0007갱신할\u0007 며\u0007‘`학번\u0007→\u0007이름’과\u0007같이\u0007표기한다. 갱신 이상 때\u0007일부\u0007튜플의\u0007정보만\u0007갱신되어\u0007정보에\u0007 (Update Anomaly) 모순이\u0007생기는\u0007현상 이행적 종속 관계\u0007 A\u0007→\u0007B이고\u0007B\u0007→\u0007C일\u0007때\u0007A\u0007→\u0007C를\u0007만족하는\u0007관계이다. 04.3, 03.5, 01.6, 01.3 핵심 14.8, 14.5, 14.3, 13.8, 13.3, 12.5, 12.3, 11.6, 11.3, 10.9, 10.3, 09.8, 09.5, 08.9, 08.3, 07.5, 07.3, 06.5, 06.3, 05.4, 05.3, 032 정규화 과정 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 11.8, 11.6, 11.3, 10.5, 10.3, 09.3, 08.9, 08.5, 08.3, 07.9, 07.3, 06.9, 06.3, 05.9, 05.5, 00.10 033 SQL의 분류 비정규 릴레이션  도메인이 원자값 DDL(데이터 정의어) 1NF •\u0007SCHEMA,\u0007DOMAIN,\u0007TABLE,\u0007VIEW,\u0007INDEX를\u0007정  부분적 함수 종속 제거 의하거나\u0007변경\u0007또는\u0007삭제할\u0007때\u0007사용하는\u0007언어이다. 2NF •\u0007데이터베이스\u0007관리자나\u0007데이터베이스\u0007설계자가\u0007사용한다.  이행적 함수 종속 제거 •\u0007데이터 정의어(DDL)의 3가지 유형 3NF  결정자이면서 후보키가 아닌 것 제거 명령어 기 능 BCNF CREATE SCHEMA,\u0007DOMAIN,\u0007TABLE,\u0007VIEW,\u0007INDEX를\u0007정의함  다치 종속 제거 ALTER TABLE에\u0007대한\u0007정의를\u0007변경하는\u0007데\u0007사용함 4NF DROP SCHEMA,\u0007DOMAIN,\u0007TABLE,\u0007VIEW,\u0007INDEX를\u0007삭제함  조인 종속성 이용 5NF DML(데이터 조작어) •\u0007데이터베이스\u0007사용자가\u0007응용\u0007프로그램이나\u0007질의어를\u0007 정규화 단계 암기 요령 통하여\u0007저장된\u0007데이터를\u0007실질적으로\u0007처리하는\u0007데\u0007사용 하는\u0007언어이다. 정규화라는\u0007출소자가\u0007말했다. •데\u0007 이터베이스\u0007사용자와\u0007데이터베이스\u0007관리\u0007시스템\u0007간 두부이겨다줘≒도부이결다조 의\u0007인터페이스를\u0007제공한다. 도메인이\u0007원자값 •데이터 조작어(DML)의 4가지 유형 부분적\u0007함수\u0007종속\u0007제거 14 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 12] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 \u0007\u0007\u0007-\u0007DISTINCT\u0007:\u0007중복된\u0007튜플이\u0007있으면\u0007그\u0007중\u0007첫\u0007번째\u0007 명령어 기 능 한\u0007개만\u0007검색함 SELECT 테이블에서\u0007조건에\u0007맞는\u0007튜플을\u0007검색함 \u0007\u0007\u0007-\u0007DISTINCTROW\u0007:\u0007중복된\u0007튜플을\u0007검색하지만\u0007선택 INSERT 테이블에\u0007새로운\u0007튜플을\u0007삽입함 된\u0007속성의\u0007값이\u0007아닌,\u0007튜플\u0007전체를\u0007대상으로\u0007함 DELETE 테이블에서\u0007조건에\u0007맞는\u0007튜플을\u0007삭제함 •속성명 :\u0007검색하여\u0007불러올\u0007속성(열)\u0007및\u0007수식들을\u0007지정함 UPDATE 테이블에서\u0007조건에\u0007맞는\u0007튜플의\u0007내용을\u0007변경함 \u0007\u0007\u0007-\u0007기본\u0007테이블을\u0007구성하는\u0007모든\u0007속성을\u0007지정할\u0007때는\u0007 DCL(데이터 제어어) ‘*’\u0007를\u0007기술한다. •\u0007데이터의\u0007보안,\u0007무결성,\u0007데이터\u0007회복,\u0007병행수행\u0007제어\u0007 \u0007\u0007\u0007-\u0007\u0007두\u0007개\u0007이상의\u0007테이블을\u0007대상으로\u0007검색할\u0007때는\u0007반드 등을\u0007정의하는\u0007데\u0007사용하는\u0007언어이다. 시\u0007테이블명.속성명으로\u0007표현해야\u0007한다. •데\u0007 이터베이스\u0007관리자가\u0007데이터\u0007관리를\u0007목적으로\u0007사용한다. 2. FROM절\u0007:\u0007질의에\u0007의해\u0007검색될\u0007데이터들을\u0007포함하는\u0007 \u0007데이터 제어어(DCL)의 종류 테이블명을\u0007기술함 3. WHERE절\u0007:\u0007검색할\u0007조건\u0007기술 명령어 기 능 4. GROUP BY절 명령에\u0007의해\u0007수행된\u0007결과를\u0007실제\u0007물리적\u0007디스크로\u0007저 COMMIT 장하고,\u0007데이터베이스\u0007조작\u0007작업이\u0007정상적으로\u0007완료 •특\u0007 정\u0007속성을\u0007기준으로\u0007그룹화하여\u0007검색할\u0007때\u0007그룹화\u0007 되었음을\u0007관리자에게\u0007알려줌 할\u0007속성을\u0007지정함 데이터베이스\u0007조작\u0007작업이\u0007비정상적으로\u0007종료되었을 •일반적으로\u0007GROUP\u0007BY절은\u0007그룹\u0007함수와\u0007함께\u0007사용된다. ROLLBACK 때\u0007원래의\u0007상태로\u0007복구함 •그룹 함수의 종류 GRANT 데이터베이스\u0007사용자에게\u0007사용\u0007권한을\u0007부여함 \u0007\u0007\u0007-\u0007COUNT(속성명)\u0007:\u0007그룹별\u0007튜플\u0007수를\u0007구하는\u0007함수 REVOKE 데이터베이스\u0007사용자의\u0007사용\u0007권한을\u0007취소함 \u0007\u0007\u0007-\u0007MAX(속성명)\u0007:\u0007그룹별\u0007최대값을\u0007구하는\u0007함수 \u0007\u0007\u0007-\u0007MIN(속성명)\u0007:\u0007그룹별\u0007최소값을\u0007구하는\u0007함수 핵심 14.3, 09.5, 08.5, 08.3, 05.9, 05.3, 04.9, 03.8, 03.5, 03.3, 02.9, 02.5, 01.6, 01.3, 00.7, 99.10, 99.8 \u0007\u0007\u0007-\u0007SUM(속성명)\u0007:\u0007그룹별\u0007합계를\u0007구하는\u0007함수 034 Select문 \u0007\u0007\u0007-\u0007AVG(속성명)\u0007:\u0007그룹별\u0007평균을\u0007구하는\u0007함수 5. HAVING절\u0007:\u0007GROUP\u0007BY와\u0007함께\u0007사용되며,\u0007그룹에\u0007대 테이블을\u0007구성하는\u0007튜플(행)들\u0007중에서\u0007전체\u0007또는\u0007조건을\u0007 한\u0007조건을\u0007지정함 만족하는\u0007튜플(행)을\u0007검색하여\u0007주기억장치\u0007상에\u0007임시\u0007테 이블로\u0007구성시키는\u0007명령문이다. 6. ORDER BY절 :\u0007특정\u0007속성을\u0007기준으로\u0007정렬하여\u0007검색할\u0007 때\u0007사용함 SELECT Predicate [테이블명.]속성명1, [테이블명.]속성명2, … •속성명 :\u0007정렬의\u0007기준이\u0007되는\u0007속성명을\u0007기술함 FROM 테이블명1, 테이블명2, … [WHERE 조건] • [ASC|DESC]\u0007:\u0007정렬\u0007방식으로서\u0007‘ASC’는\u0007오름차순,\u0007 [GROUP BY 속성명1, 속성명2, …] ‘`DESC`’는\u0007내림차순임,\u0007생략하면\u0007오름차순으로\u0007지정\u0007 [HAVING 조건] [ORDER BY 속성명 [ASC | DESC]]; 1. SELECT절 •Predicate\u0007:\u0007불러올\u0007튜플\u0007수를\u0007제한할\u0007명령어를\u0007기술함 \u0007\u0007\u0007-\u0007ALL\u0007:\u0007모든\u0007튜플을\u0007검색할\u0007때\u0007지정하는\u0007것으로,\u0007주 로\u0007생략함 15 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 13] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.3, 09.8, 07.9, 07.3, 05.5, 04.9, 03.3, 00.7, 99.8 핵심 08.3, 03.8, 02.3, 00.10 035 삽입, 삭제, 갱신문 036 내장 SQL(Embedded SQL) 삽입문(INSERT INTO ~ ) •응\u0007 용\u0007프로그램이\u0007실행될\u0007때\u0007함께\u0007실행되도록\u0007호스트\u0007 •기본\u0007테이블에\u0007새로운\u0007튜플을\u0007삽입할\u0007때\u0007사용한다. 프로그램\u0007언어로\u0007만든\u0007프로그램에\u0007삽입된\u0007SQL이다. •\u0007내장\u0007SQL\u0007실행문은\u0007호스트\u0007언어에서\u0007실행문이\u0007나타날\u0007수\u0007 INSERT 있는\u0007곳이면\u0007프로그램의\u0007어느\u0007곳에서나\u0007사용할\u0007수\u0007있다. INTO 테이블명(속성명1, 속성명2, … ) •\u0007일반\u0007SQL문은\u0007수행\u0007결과로\u0007여러\u0007개의\u0007튜플을\u0007반환하 VALUES (데이터1, 데이터2, … ); 는\u0007반면,\u0007내장\u0007SQL은\u0007단\u0007하나의\u0007튜플만을\u0007반환한다. •대\u0007 응하는\u0007속성과\u0007데이터는\u0007개수와\u0007데이터\u0007형식이\u0007일치 •\u0007내장\u0007SQL문에\u0007의해\u0007반환되는\u0007튜플은\u0007일반\u0007변수를\u0007사 해야\u0007한다. 용하여\u0007저장할\u0007수\u0007있다. •\u0007기본\u0007테이블의\u0007모든\u0007속성을\u0007사용할\u0007때는\u0007속성명을\u0007생략 •\u0007Host\u0007Program의\u0007컴파일\u0007시\u0007내장\u0007SQL문은\u0007선행\u0007처리 할\u0007수\u0007있다. 기에\u0007의해\u0007분리되어\u0007컴파일된다. •S\u0007ELECT문을\u0007사용하여\u0007다른\u0007테이블의\u0007검색\u0007결과를\u0007삽 •\u0007호스트\u0007변수와\u0007데이터베이스\u0007필드의\u0007이름은\u0007같아도\u0007된다. 입할\u0007수\u0007있다. •\u0007내장\u0007SQL문에\u0007사용된\u0007호스트\u0007변수의\u0007데이터\u0007타입은\u0007 삭제문(DELETE FROM ~ ) 이에\u0007대응하는\u0007데이터베이스\u0007필드의\u0007SQL\u0007데이터\u0007타입 •기\u0007 본\u0007테이블에\u0007있는\u0007튜플들\u0007중에서\u0007특정\u0007튜플을\u0007삭제할\u0007 과\u0007일치하여야\u0007한다. 때\u0007사용한다. •내\u0007 장\u0007SQL문이\u0007실행되면\u0007SQL의\u0007실행\u0007상태가\u0007SQL\u0007상 태\u0007변수에\u0007전달된다. DELETE FROM 테이블명 • 호스트 언어의 실행문과 SQL문을 구분시키는 방법 WHERE 조건; \u0007\u0007\u0007-\u0007명령문의\u0007구분\u0007:\u0007C/C++에서\u0007내장\u0007SQL문은\u0007$와\u0007세 미콜론(;)\u0007문자\u0007사이에\u0007기술하고,\u0007Visual\u0007BASIC에서 •\u0007모든\u0007레코드를\u0007삭제할\u0007때는\u0007WHERE절을\u0007생략한다. 는\u0007내장\u0007SQL문\u0007앞에\u0007‘EXEC\u0007SQL’을\u0007기술함 •\u0007모든\u0007레코드를\u0007삭제하더라도\u0007테이블\u0007구조는\u0007남아\u0007있기\u0007 \u0007\u0007\u0007-\u0007변수의\u0007구분\u0007:\u0007내장\u0007SQL에서\u0007사용하는\u0007호스트\u0007변수 때문에\u0007디스크에서\u0007테이블을\u0007완전히\u0007제거하는\u0007DROP 는\u0007변수\u0007앞에\u0007콜론(:)\u0007문자를\u0007붙임 과는\u0007다르다. 갱신문(UPDATE ~ SET ~ ) 05.4, 04.9, 04.3, 03.8, 03.5, 02.9, 02.5, 01.9, 01.6, 00.10, 00.7, 00.3, 99.10, 99.4 기본\u0007테이블에\u0007있는\u0007튜플들\u0007중에서\u0007특정\u0007튜플의\u0007내용을\u0007 핵심 14.8, 14.5, 13.8, 13.6, 13.3, 12.5, 12.3, 11.8, 11.6, 10.9, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.3, 06.9, 06.5, 06.3, 037 뷰(View) 변경할\u0007때\u0007사용한다. •사\u0007 용자에게\u0007접근이\u0007허용된\u0007자료만을\u0007제한적으로\u0007보여 UPDATE 테이블명 주기\u0007위해\u0007하나\u0007이상의\u0007기본\u0007테이블로부터\u0007유도된\u0007가 SET 속성명1 = 데이터1[, 속성명2 = 데이터2] 상\u0007테이블이다. WHERE 조건; •저\u0007 장장치\u0007내에\u0007물리적으로\u0007존재하지\u0007않지만,\u0007사용자에 게는\u0007있는\u0007것처럼\u0007간주된다. •데\u0007 이터\u0007보정작업,\u0007처리과정\u0007시험\u0007등\u0007임시적인\u0007작업을\u0007 위한\u0007용도로\u0007활용된다. 뷰(View)의 특징 •\u0007기본\u0007테이블로부터\u0007유도된\u0007테이블이기\u0007때문에\u0007기본\u0007테 이블과\u0007같은\u0007형태의\u0007구조를\u0007가지며,\u0007조작도\u0007기본\u0007테이 블과\u0007거의\u0007같다. 16 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 14] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007가상\u0007테이블이기\u0007때문에\u0007물리적으로\u0007구현되어\u0007있지\u0007 취소됨 않다. •C\u0007ASCADE :\u0007뷰를\u0007참조하는\u0007다른\u0007뷰나\u0007제약\u0007조건까지\u0007모 •필\u0007 요한\u0007데이터만\u0007뷰로\u0007정의해서\u0007처리할\u0007수\u0007있기\u0007때문 두\u0007삭제됨 에\u0007관리가\u0007용이하고\u0007명령문이\u0007간단해진다. •조\u0007 인문의\u0007사용을\u0007최소화하여\u0007사용상의\u0007편의성을\u0007최대 05.4, 04.9, 04.3, 03.8, 03.5, 03.3, 02.9, 02.3, 01.9, 01.6, 01.3, 00.7, 99.4 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.3, 08.9, 08.5, 08.3, 06.3, 05.9, 05.5, 화한다.\u0007 038 시스템 카탈로그 •\u0007뷰를\u0007통해서만\u0007데이터에\u0007접근하게\u0007하면\u0007뷰에\u0007나타나지\u0007 •\u0007시스템\u0007그\u0007자체에\u0007관련이\u0007있는\u0007스키마\u0007및\u0007다양한\u0007객체 않는\u0007데이터를\u0007안전하게\u0007보호할\u0007수\u0007있다. 에\u0007관한\u0007정보를\u0007포함하는\u0007시스템\u0007데이터베이스이다. •\u0007기본\u0007테이블의\u0007기본키를\u0007포함한\u0007속성(열)\u0007집합으로\u0007뷰 •데\u0007 이터베이스에\u0007포함되는\u0007모든\u0007데이터\u0007객체에\u0007대한\u0007정의 를\u0007구성해야만\u0007삽입,\u0007삭제,\u0007갱신\u0007연산이\u0007가능하다. 나\u0007명세에\u0007관한\u0007정보를\u0007유지관리하는\u0007시스템\u0007테이블이다. •\u0007정의된\u0007뷰는\u0007다른\u0007뷰의\u0007정의에\u0007기초가\u0007될\u0007수\u0007있다. •\u0007데이터\u0007정의어의\u0007결과로\u0007구성되는\u0007기본\u0007테이블,\u0007뷰,\u0007인 •하\u0007 나의\u0007뷰를\u0007삭제하면\u0007그\u0007뷰를\u0007기초로\u0007정의된\u0007다른\u0007뷰 덱스,\u0007패키지,\u0007접근\u0007권한\u0007등의\u0007데이터베이스\u0007구조\u0007및\u0007 도\u0007자동으로\u0007삭제된다. 통계\u0007정보를\u0007저장한다. 뷰의 장점 •\u0007카탈로그들이\u0007생성되면\u0007자료\u0007사전(Data\u0007Dictionary)에\u0007 •\u0007논리적\u0007데이터\u0007독립성을\u0007제공한다. 저장되기\u0007때문에\u0007좁은\u0007의미로는\u0007카탈로그를\u0007자료\u0007사전 이라고도\u0007한다. •동\u0007 일\u0007데이터에\u0007대해\u0007동시에\u0007여러\u0007사용자의\u0007상이한\u0007응 용이나\u0007요구를\u0007지원해준다. •\u0007카탈로그에\u0007저장된\u0007정보를\u0007메타\u0007데이터(Meta-Data) 라고\u0007한다. •\u0007사용자의\u0007데이터\u0007관리를\u0007간단하게\u0007해준다. 시스템 카탈로그의 특징 •\u0007접근\u0007제어를\u0007통한\u0007자동\u0007보안이\u0007제공된다. •카\u0007 탈로그\u0007자체도\u0007시스템\u0007테이블로\u0007구성되어\u0007있어\u0007일반\u0007 뷰의 단점 이용자도\u0007SQL을\u0007이용하여\u0007내용을\u0007검색해\u0007볼\u0007수\u0007있다. •\u0007독립적인\u0007인덱스를\u0007가질\u0007수\u0007없다. •\u0007INSERT,\u0007DELETE,\u0007UPDATE문으로\u0007갱신하는\u0007것은\u0007 •뷰\u0007 의\u0007정의를\u0007변경할\u0007수\u0007없다. 허용하지\u0007않는다. •뷰\u0007 로\u0007구성된\u0007내용에\u0007대한\u0007삽입,\u0007삭제,\u0007갱신\u0007연산에\u0007제 •\u0007DBMS가\u0007스스로\u0007생성하고\u0007유지한다. 약이\u0007따른다. •\u0007카탈로그는\u0007사용자가\u0007SQL문을\u0007실행시켜\u0007기본\u0007테이블,\u0007뷰,\u0007 뷰 정의문 인덱스\u0007등에\u0007변화를\u0007주면\u0007시스템이\u0007자동으로\u0007갱신된다. CREATE VIEW 뷰이름[(속성이름[,속성이름])] AS SELECT문; 핵심 14.8, 13.6, 12.5, 09.3, 08.9, 07.5, 02.9, 00.7 039 트랜잭션의 정의 •S\u0007ELECT문을\u0007부질의로\u0007사용하여\u0007SELECT문의\u0007결과로 서\u0007뷰를\u0007생성한다. •\u0007데이터베이스의\u0007상태를\u0007변환시키는\u0007하나의\u0007논리적\u0007기 •부\u0007 질의로서의\u0007SELECT문에는\u0007UNION이나\u0007ORDER\u0007 능을\u0007수행하기\u0007위한\u0007작업의\u0007단위\u0007또는\u0007한꺼번에\u0007모두\u0007 BY절을\u0007사용할\u0007수\u0007없다. 수행되어야\u0007할\u0007일련의\u0007연산들을\u0007의미한다. •속\u0007 성\u0007이름을\u0007기술하지\u0007않으면\u0007SELECT문의\u0007속성\u0007이름 •데\u0007 이터베이스\u0007시스템에서\u0007복구\u0007및\u0007병행\u0007수행\u0007시\u0007처리되 이\u0007자동으로\u0007사용된다. 는\u0007작업의\u0007논리적\u0007단위이다. •\u0007하나의\u0007트랜잭션은\u0007Commit되거나\u0007Rollback된다. 뷰 삭제문 •\u0007트랜잭션은\u0007일반적으로\u0007회복의\u0007단위가\u0007된다. DROP VIEW 뷰이름 {RESTRICT | CASCADE}; •R\u0007ESTRICT :\u0007뷰를\u0007다른\u0007곳에서\u0007참조하고\u0007있으면\u0007삭제가\u0007 17 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 15] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 06.9, 06.5, 05.5, 05.4, 05.3, 04.5, 04.3, 03.8, 03.5, 03.3, 02.9, 02.5, 02.3, 01.9, 01.6, 01.3 핵심 14.8, 14.5, 13.8, 13.6, 13.3, 12.8, 12.5, 11.8, 11.6, 11.3, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 07.3, 까지\u0007실행했지만,\u0007Commit\u0007연산이\u0007실행되기\u0007직전의\u0007\u0007 040 트랜잭션의 특성 상태 • Committed(완료)\u0007:\u0007트랜잭션이\u0007성공적으로\u0007종료되어\u0007 •\u0007트랜잭션의\u0007연산은\u0007데이터베이스에\u0007모두\u0007반영 되든지\u0007아니면\u0007전혀\u0007반영되지\u0007않아야\u0007함 Commit\u0007연산을\u0007실행한\u0007후의\u0007상태 Atomicity •\u0007트랜잭션\u0007내의\u0007모든\u0007명령은\u0007반드시\u0007완벽히\u0007수행 (원자성) 되어야\u0007하며,\u0007모두가\u0007완벽히\u0007수행되지\u0007않고\u0007어 느\u0007하나라도\u0007에러가\u0007발생하면\u0007트랜잭션\u0007전부가\u0007 핵심 12.3, 10.9, 01.6, 01.3, 99.10 취소되어야\u0007함 043 회복(Recovery) •\u0007트랜잭션이\u0007그\u0007실행을\u0007성공적으로\u0007완료하면\u0007언 •회\u0007 복은\u0007트랜잭션들의\u0007처리를\u0007수행하는\u0007도중\u0007장애가\u0007발 제나\u0007일관성\u0007있는\u0007데이터베이스\u0007상태로\u0007변환함 Consistency •\u0007시스템이\u0007가지고\u0007있는\u0007고정\u0007요소는\u0007트랜잭션\u0007수 생하여\u0007데이터베이스가\u0007손상되었을\u0007때\u0007손상되기\u0007이전 (일관성) 행\u0007전과\u0007트랜잭션\u0007수행\u0007완료\u0007후의\u0007상태가\u0007같아 의\u0007정상\u0007상태로\u0007복구시키는\u0007작업이다. 야\u0007함 •장\u0007 애의 유형 •\u0007둘\u0007이상의\u0007트랜잭션이\u0007동시에\u0007병행\u0007실행되는\u0007경 Isolation 우\u0007어느\u0007하나의\u0007트랜잭션\u0007실행중에\u0007다른\u0007트랜잭 \u0007\u0007\u0007-\u0007트랜잭션\u0007장애\u0007:\u0007입력\u0007데이터\u0007오류,\u0007불명확한\u0007데이터,\u0007 (독립성, 션의\u0007연산이\u0007끼어들\u0007수\u0007없음 시스템\u0007자원\u0007요구의\u0007과다\u0007등\u0007트랜잭션\u0007내부의\u0007비정상 격리성) •\u0007수행중인\u0007트랜잭션은\u0007완전히\u0007완료될\u0007때까지\u0007다 적인\u0007상황으로\u0007인하여\u0007프로그램\u0007실행이\u0007중지되는\u0007현상 른\u0007트랜잭션에서\u0007수행\u0007결과를\u0007참조할\u0007수\u0007없음 Durability 성공적으로\u0007완료된\u0007트랜잭션의\u0007결과는\u0007영구적으 \u0007\u0007\u0007-\u0007시스템\u0007장애\u0007:\u0007데이터베이스에\u0007손상을\u0007입히지는\u0007않 (영속성, 지속성) 로\u0007반영되어야\u0007함 으나\u0007하드웨어\u0007오동작,\u0007소프트웨어의\u0007손상,\u0007교착\u0007상 태\u0007등에\u0007의해\u0007모든\u0007트랜잭션의\u0007연속적인\u0007수행에\u0007장 애를\u0007주는\u0007현상 핵심 05.9, 03.3, 99.4 041 Commit, Rollback 연산 \u0007\u0007\u0007-\u0007미디어\u0007장애\u0007:\u0007저장장치인\u0007디스크\u0007블록의\u0007손상이나\u0007 디스크\u0007헤드의\u0007충돌\u0007등에\u0007의해\u0007데이터베이스의\u0007일부\u0007 •\u0007Commit 연산\u0007:\u0007하나의\u0007논리적\u0007단위(트랜잭션)에\u0007대한\u0007 또는\u0007전부가\u0007물리적으로\u0007손상된\u0007상태 작업이\u0007성공적으로\u0007끝났고,\u0007데이터베이스가\u0007다시\u0007일관 • 회복 관리기(Recovery Management) 된\u0007상태에\u0007있을\u0007때\u0007이\u0007트랜잭션이\u0007행한\u0007갱신\u0007연산이\u0007완 \u0007\u0007\u0007-DBMS의\u0007구성\u0007요소이다. 료된\u0007것을\u0007트랜잭션\u0007관리자에게\u0007알려주는\u0007연산 \u0007\u0007\u0007-\u0007트랜잭션\u0007실행이\u0007성공적으로\u0007완료되지\u0007못하면\u0007트랜 •\u0007Rollback 연산\u0007:\u0007하나의\u0007트랜잭션\u0007처리가\u0007비정상적으로\u0007 잭션이\u0007데이터베이스에\u0007만들었던\u0007모든\u0007변화를\u0007취소 종료되어\u0007데이터베이스의\u0007일관성을\u0007깨뜨렸을\u0007때,\u0007이\u0007 (Undo)시키고\u0007트랜잭션\u0007수행\u0007이전의\u0007원래\u0007상태로\u0007 트랜잭션의\u0007일부가\u0007정상적으로\u0007처리되었더라도\u0007트랜 복구하는\u0007역할을\u0007담당한다. 잭션의\u0007원자성을\u0007구현하기\u0007위해\u0007이\u0007트랜잭션이\u0007행한\u0007 모든\u0007연산을\u0007취소(Undo)시키는\u0007연산으로,\u0007해당\u0007트랜 \u0007\u0007\u0007-메모리\u0007덤프,\u0007로그(Log)를\u0007이용하여\u0007수행한다. 잭션을\u0007재시작하거나\u0007폐기함 • 회복 기법의 종류 \u0007\u0007\u0007-\u0007연기\u0007갱신\u0007기법(Deferred\u0007Update) 핵심 05.3, 01.3 \u0007\u0007\u0007-\u0007즉각\u0007갱신\u0007기법(Immediate\u0007Update) 042 트랜잭션의 상태 \u0007\u0007\u0007-\u0007그림자\u0007페이지\u0007대체\u0007기법(Shadow\u0007Paging) • Active(활동)\u0007:\u0007트랜잭션이\u0007실행중에\u0007있는\u0007상태 \u0007\u0007\u0007-\u0007검사점\u0007기법(Check\u0007Point) • Failed(장애) :\u0007트랜잭션\u0007실행에\u0007오류가\u0007발생하여\u0007중단된\u0007 상태 • Aborted(철회)\u0007:\u0007트랜잭션이\u0007비정상적으로\u0007종료되어\u0007 Rollback\u0007연산을\u0007수행한\u0007상태 • Partially Committed(부분 완료)\u0007:\u0007트랜잭션의\u0007마지막\u0007연산 18 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 16] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.3, 07.5, 07.3, 03.5 핵심 13.6, 12.3, 11.8, 11.3, 09.5, 08.3, 07.5, 06.3, 03.5, 02.5, 02.3, 00.10 044 병행 제어(Concurrency Control) 045 보안(Security) •\u0007다중\u0007프로그램의\u0007이점을\u0007활용하여\u0007동시에\u0007여러\u0007개의\u0007트 데이터베이스 보안의 개요 랜잭션을\u0007병행\u0007수행시킬\u0007때,\u0007동시에\u0007실행되는\u0007트랜잭션 •\u0007데이터베이스의\u0007일부분\u0007또는\u0007전체에\u0007대해서\u0007권한이\u0007없 들이\u0007데이터베이스의\u0007일관성을\u0007파괴하지\u0007않도록\u0007트랜 는\u0007사용자가\u0007액세스를\u0007수행하는\u0007것을\u0007금지하기\u0007위해\u0007사 잭션\u0007간의\u0007상호작용을\u0007제어하는\u0007것이다. 용되는\u0007기술이다. •\u0007병행 수행의 문제점 •\u0007데이터베이스\u0007사용자들은\u0007일반적으로\u0007서로\u0007다른\u0007객체 \u0007\u0007\u0007-\u0007갱신\u0007분실(Lost\u0007Update)\u0007:\u00072개\u0007이상의\u0007트랜잭션이\u0007같 에\u0007대하여\u0007다른\u0007접근권리\u0007또는\u0007권한을\u0007갖게된다. 은\u0007자료를\u0007공유하여\u0007갱신할\u0007때\u0007갱신\u0007결과의\u0007일부가\u0007 무결성(Integrity)과 보안(Security) 없어지는\u0007현상 •\u0007무결성은\u0007권한이\u0007있는\u0007사용자로부터\u0007데이터베이스를\u0007 \u0007\u0007\u0007-\u0007비완료\u0007의존성(Uncommitted\u0007Dependency)\u0007:\u0007하나 보호하는\u0007것이고,\u0007보안은\u0007권한이\u0007없는\u0007사용자로부터\u0007데 의\u0007트랜잭션\u0007수행이\u0007실패한\u0007후\u0007회복되기\u0007전에\u0007다른\u0007 이터베이스를\u0007보호하는\u0007것을\u0007말한다. 트랜잭션이\u0007실패한\u0007갱신\u0007결과를\u0007참조하는\u0007현상 •\u0007보안은\u0007데이터베이스\u0007사용자들이\u0007데이터베이스를\u0007사용 \u0007\u0007\u0007-\u0007모순성(Inconsistency)\u0007:\u0007두\u0007개의\u0007트랜잭션이\u0007병행\u0007 하고자\u0007할\u0007때\u0007언제든지\u0007사용할\u0007수\u0007있도록\u0007보장하는\u0007것 수행될\u0007때\u0007원치\u0007않는\u0007자료를\u0007이용함으로써\u0007발생하는\u0007 이고,\u0007무결성은\u0007정확하게\u0007사용할\u0007수\u0007있도록\u0007보장하는\u0007 문제 것을\u0007말한다. \u0007\u0007\u0007-\u0007\u0007연쇄\u0007복귀(Cascading\u0007Rollback)\u0007:\u0007병행\u0007수행되던\u0007트 암호화 기법 랜잭션들\u0007중\u0007어느\u0007하나에\u0007문제가\u0007생겨\u0007Rollback하는\u0007 •\u0007개인키 암호 방식(Private Key Encryption) = 비밀키 암호 방식 경우\u0007다른\u0007트랜잭션도\u0007함께\u0007Rollback되는\u0007현상 \u0007\u0007\u0007-\u0007동일한\u0007키로\u0007데이터를\u0007암호화하고\u0007복호화한다. • 병행 제어의 목적 \u0007\u0007\u0007-\u0007비밀키는\u0007제3자에게는\u0007노출시키지\u0007않고,\u0007데이터베이 \u0007\u0007\u0007-\u0007\u0007데이터베이스의\u0007공유를\u0007최대화한다. 스\u0007사용\u0007권한이\u0007있는\u0007사용자만\u0007나누어\u0007가진다. \u0007\u0007\u0007-\u0007\u0007시스템의\u0007활용도를\u0007최대화한다. \u0007\u0007\u0007-\u0007대칭\u0007암호\u0007방식\u0007또는\u0007단일키\u0007암호화\u0007기법이라고도\u0007한 \u0007\u0007\u0007-\u0007\u0007데이터베이스의\u0007일관성을\u0007유지한다. 다. \u0007\u0007\u0007-\u0007\u0007사용자에\u0007대한\u0007응답\u0007시간을\u0007최소화한다. \u0007\u0007\u0007-\u0007대표적으로\u0007DES(Data\u0007Encryption\u0007Standard)가\u0007있다. • 로킹(Locking) \u0007\u0007\u0007-\u0007장점\u0007:\u0007암호화/복호화\u0007속도가\u0007빠르며,\u0007알고리즘이\u0007단 \u0007\u0007\u0007-\u0007로킹은\u0007주요\u0007데이터의\u0007액세스를\u0007상호\u0007배타적으로\u0007하 순하고\u0007파일\u0007크기가\u0007작음 는\u0007것이다. \u0007\u0007\u0007-\u0007단점 :\u0007사용자의\u0007증가에\u0007따라\u0007관리해야\u0007할\u0007키의\u0007수가\u0007 \u0007\u0007\u0007-\u0007트랜잭션들이\u0007어떤\u0007로킹\u0007단위를\u0007액세스하기\u0007전에\u0007 상대적으로\u0007많아짐 Lock(잠금)을\u0007요청해서\u0007Lock이\u0007허락되어야만\u0007그\u0007로 \u0007\u0007\u0007-\u0007DES는\u000756Bit의\u000716개\u0007키를\u0007이용하여\u000764Bit의\u0007평문\u0007블록 킹\u0007단위를\u0007액세스할\u0007수\u0007있도록\u0007하는\u0007기법이다. 을\u000716회의\u0007암호\u0007계산\u0007단계를\u0007거쳐\u000764Bit의\u0007암호문을\u0007얻 • 로킹 단위(Locking Granularity) 는다. \u0007\u0007\u0007-\u0007병행\u0007제어에서\u0007한꺼번에\u0007로킹할\u0007수\u0007있는\u0007데이터\u0007단위 •\u0007공개키 암호 방식(Public Key Encryption) 이다. \u0007\u0007\u0007-\u0007서로\u0007다른\u0007키로\u0007데이터를\u0007암호화하고\u0007복호화한다. \u0007\u0007\u0007-\u0007데이터베이스,\u0007파일,\u0007레코드,\u0007필드\u0007등은\u0007로킹\u0007단위가\u0007 \u0007\u0007\u0007-\u0007데이터를\u0007암호화할\u0007때\u0007사용하는\u0007키(공개키,\u0007Public\u0007 될\u0007수\u0007있다. Key)는\u0007데이터베이스\u0007사용자에게\u0007공개하고,\u0007복호화 \u0007\u0007\u0007-\u0007로킹\u0007단위가\u0007크면\u0007로크\u0007수가\u0007작아\u0007관리하기\u0007쉽지만\u0007 할\u0007때의\u0007키(비밀키,\u0007Secret\u0007Key)는\u0007관리자가\u0007비밀리 병행성\u0007수준이\u0007낮아지고,\u0007로킹\u0007단위가\u0007작으면\u0007로크\u0007 에\u0007관리하는\u0007방법이다. 수가\u0007많아\u0007관리하기\u0007복잡하지만\u0007병행성\u0007수준이\u0007높아 \u0007\u0007\u0007-\u0007비대칭\u0007암호\u0007방식이라고도\u0007하며,\u0007대표적으로\u0007RSA\u0007 진다. (Rivest\u0007Shamir\u0007Adleman)가\u0007있다. 19 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 17] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 \u0007\u0007\u0007-\u0007장점\u0007:\u0007키의\u0007분배가\u0007용이하고,\u0007관리해야\u0007할\u0007키의\u0007개수 핵심 13.8, 13.3, 12.8, 12.5, 07.5, 07.3, 06.9, 06.5, 05.5, 04.5, 03.8, 03.3, 01.6, 01.3 048 자료 구조의 분류 가\u0007적음 \u0007\u0007\u0007-\u0007단점\u0007:\u0007암호화/복호화\u0007속도가\u0007느리며,\u0007알고리즘이\u0007복 •선\u0007 형 구조\u0007:\u0007선형\u0007리스트(배열),\u0007연결\u0007리스트,\u0007스택,\u0007큐,\u0007데크 잡하고\u0007파일\u0007크기가\u0007큼 • 비선형 구조 :\u0007트리,\u0007그래프 핵심 11.3, 09.8, 07.9, 06.9, 05.9, 05.3, 04.9, 04.3, 03.8, 03.3, 01.9 046 분산 데이터베이스 핵심 07.9, 02.9, 01.9, 00.10, 00.3 049 연결 리스트(Linked List) •분\u0007 산\u0007데이터베이스는\u0007논리적으로는\u0007하나의\u0007시스템에\u0007 •\u0007연결\u0007리스트는\u0007자료들을\u0007임의의\u0007기억공간에\u0007기억시키 속하지만\u0007물리적으로는\u0007네트워크를\u0007통해\u0007연결된\u0007여러\u0007 되,\u0007자료\u0007항목의\u0007순서에\u0007따라\u0007노드의\u0007포인터\u0007부분을\u0007이 개의\u0007컴퓨터\u0007사이트(Site)에\u0007분산되어\u0007있는\u0007데이터베이 용하여\u0007서로\u0007연결시킨\u0007자료\u0007구조이다. 스를\u0007의미한다. •\u0007노드의\u0007삽입,\u0007삭제\u0007작업이\u0007용이하다. •분산 데이터베이스의 4대 목표 •\u0007기억공간이\u0007연속적으로\u0007놓여있지\u0007않아도\u0007저장이\u0007가능하다. 위치 투명성 액세스하려는\u0007데이터베이스의\u0007실제\u0007위치를\u0007알\u0007 •\u0007연결을\u0007위한\u0007링크(포인터)\u0007부분이\u0007필요하기\u0007때문에\u0007순 (Location 필요\u0007없이\u0007단지\u0007데이터베이스의\u0007논리적인\u0007명칭 차\u0007리스트에\u0007비해\u0007기억공간\u0007이용\u0007효율이\u0007좋지\u0007않다. Transparency) 만으로\u0007액세스할\u0007수\u0007있음 •접근\u0007속도가\u0007느리다. 중복(복제) 동일\u0007데이터가\u0007여러\u0007곳에\u0007중복되어\u0007있더라도\u0007사 투명성 용자는\u0007마치\u0007하나의\u0007데이터만\u0007존재하는\u0007것처럼\u0007 •연\u0007 결\u0007리스트\u0007중에서\u0007중간\u0007노드의\u0007연결이\u0007끊어지면\u0007그\u0007 (Replication 사용하고,\u0007시스템은\u0007자동으로\u0007여러\u0007자료에\u0007대한\u0007 다음\u0007노드를\u0007찾기\u0007힘들다. Transparency) 작업을\u0007수행함 •희\u0007 소\u0007행렬을\u0007링크드\u0007리스트로\u0007표현하면\u0007기억장소가\u0007절 병행 투명성 분산\u0007데이터베이스와\u0007관련된\u0007다수의\u0007트랜잭션들 약된다. (Concurrency 이\u0007동시에\u0007실현되더라도\u0007그\u0007트랜잭션의\u0007결과는\u0007 Transparency) 영향을\u0007받지\u0007않음 잠깐만요 ! 희소 행렬(Sparse Matrix) 장애 투명성 행렬의\u0007요소\u0007중\u0007많은\u0007항들이\u00070으로\u0007되어\u0007있는\u0007형태로,\u0007기억장소를\u0007절 트랜잭션,\u0007DBMS,\u0007네트워크,\u0007컴퓨터\u0007장애에도\u0007불 (Failure 약하기\u0007위해\u0007링크드\u0007리스트를\u0007이용하여\u0007저장합니다. 구하고\u0007트랜잭션을\u0007정확하게\u0007처리함 Transparency) 03.8, 03.3, 01.9, 00.3, 핵심 14.8, 14.5, 13.8, 12.8, 12.5, 11.8, 11.6, 10.9, 10.5, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.3, 06.9, 06.5, 05.4, 05.3, 04.5, 050 스택(Stack) 핵심 14.3, 11.8, 10.5, 10.3, 08.9, 08.5, 07.5, 06.9, 06.3, 05.4, 04.5, 03.8, 02.5, 02.3, 01.9, 00.10 047 분산 데이터베이스의 장·단점 •\u0007리스트의\u0007한쪽\u0007끝으로만\u0007자료의\u0007삽입,\u0007삭제\u0007작업이\u0007이 루어지는\u0007자료\u0007구조이다. 장 점 단 점 •가\u0007 장\u0007나중에\u0007삽입된\u0007자료가\u0007가장\u0007먼저\u0007삭제되는\u0007후입\u0007 •지역\u0007자치성이\u0007높음 •\u0007DBMS가\u0007수행할\u0007기능이\u0007복잡 •\u0007자료의\u0007공유성이\u0007향상\u0007 함 선출(LIFO;\u0007Last-In,\u0007First-Out)\u0007방식으로\u0007자료를\u0007처 •\u0007분산\u0007제어가\u0007가능함 •\u0007데이터베이스\u0007설계가\u0007어려움 리한다. •\u0007시스템\u0007성능이\u0007향상\u0007 •\u0007소프트웨어\u0007개발\u0007비용이\u0007증가 •\u0007TOP\u0007:\u0007\u0007Stack으로\u0007할당된\u0007기억공간에\u0007가장\u0007마지막으로\u0007 함 •\u0007효용성과\u0007융통성이\u0007높음 •\u0007처리\u0007비용이\u0007증가함 삽입된\u0007자료가\u0007기억된\u0007위치를\u0007가리키는\u0007요소,\u0007스택\u0007포 •\u0007신뢰성\u0007및\u0007가용성이\u0007높음 •\u0007잠재적\u0007오류가\u0007증가함 인터라고도\u0007함 •\u0007점증적\u0007시스템\u0007용량\u0007확장이\u0007 용이함 •B\u0007ottom\u0007:\u0007스택의\u0007가장\u0007밑바닥임 •P\u0007USH\u0007:\u0007스택에\u0007자료를\u0007입력하는\u0007명령 •P\u0007OP\u0007:\u0007스택에서\u0007자료를\u0007출력하는\u0007명령 Stack의 용도 •부프로그램\u0007호출\u0007시\u0007복귀주소를\u0007저장할\u0007때 20 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 18] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •함수\u0007호출의\u0007순서\u0007제어 은\u0007한쪽에서만\u0007이루어지는\u0007출력\u0007제한이\u0007있다. •인터럽트가\u0007발생하여\u0007복귀주소를\u0007저장할\u0007때\u0007 •\u0007입력 제한 데크\u0007:\u0007Scroll •후\u0007 위\u0007표기법(Postfix\u0007Notation)으로\u0007표현된\u0007산술식을\u0007 •\u0007출력 제한 데크\u0007:\u0007Shelf 연산할\u0007때\u0007 •0\u0007주소지정방식\u0007명령어의\u0007자료\u0007저장소 핵심 14.8, 14.5, 14.3, 13.6, 11.8, 10.9, 10.3, 09.8, 08.9, 06.9, 06.5, 05.4, 03.5, 03.3, 01.9 •재귀(Recursive)\u0007프로그램의\u0007순서\u0007제어 053 트리(Tree) •컴파일러를\u0007이용한\u0007언어\u0007번역\u0007시 정점(Node,\u0007노드)과\u0007선분(Branch,\u0007가지)을\u0007이용하여\u0007사 잠깐만요 ! 재귀(Recursion) 프로그램 이클을\u0007이루지\u0007않도록\u0007구성한\u0007Graph의\u0007특수한\u0007형태로\u0007 재귀(Recursion)\u0007프로그램이란\u0007한\u0007루틴(Routine)이\u0007자기를\u0007다시\u0007호출 가족의\u0007계보(족보),\u0007연산\u0007수식,\u0007회사\u0007조직\u0007구조도,\u0007히프 하여\u0007실행하는\u0007프로그램을\u0007말합니다. (Heap)\u0007등을\u0007표현하기에\u0007적합하다. (cid:1236)(cid:1)(cid:1442)(cid:1624)(cid:9)(cid:51)(cid:80)(cid:80)(cid:85)(cid:1)(cid:47)(cid:80)(cid:69)(cid:70)(cid:10) 핵심 12.8, 12.3, 08.5, 07.9, 06.5, 05.9, 03.5, 03.3, 02.5, 02.3, 00.10 051 큐(Queue) (cid:34) (cid:45)(cid:70)(cid:87)(cid:70)(cid:77)(cid:1)(cid:18) •선\u0007 형\u0007리스트의\u0007한쪽에서는\u0007삽입\u0007작업이\u0007이루어지고\u0007다 (cid:35) (cid:36) (cid:37) (cid:45)(cid:70)(cid:87)(cid:70)(cid:77)(cid:1)(cid:19) 른\u0007한쪽에서는\u0007삭제\u0007작업이\u0007이루어지도록\u0007구성한\u0007자료\u0007 (cid:38) (cid:39) (cid:40) (cid:41) (cid:42) (cid:43) (cid:45)(cid:70)(cid:87)(cid:70)(cid:77)(cid:1)(cid:20) 구조이다. •시\u0007 작(Front\u0007또는\u0007Head)과\u0007끝(Rear\u0007또는\u0007Tail)을\u0007표시 (cid:44) (cid:45) (cid:46) (cid:45)(cid:70)(cid:87)(cid:70)(cid:77)(cid:1)(cid:21)(cid:1)(cid:170)(cid:1)(cid:37)(cid:70)(cid:81)(cid:85)(cid:73) 하는\u0007두\u0007개의\u0007포인터가\u0007있다. •\u0007노드(Node)\u0007:\u0007트리의\u0007기본\u0007요소로서\u0007자료\u0007항목과\u0007다른\u0007 •가\u0007 장\u0007먼저\u0007삽입된\u0007자료가\u0007가장\u0007먼저\u0007삭제되는\u0007선입선 항목에\u0007대한\u0007가지(Branch)를\u0007합친\u0007것 출(FIFO;\u0007First-In,\u0007First-Out)\u0007방식으로\u0007처리한다. \u0007\u0007\u0007\u0007\u0007A,\u0007B,\u0007C,\u0007D,\u0007E,\u0007F,\u0007G,\u0007H,\u0007I,\u0007J,\u0007K,\u0007L,\u0007M •프\u0007 런트(F, Front) 포인터\u0007:\u0007가장\u0007먼저\u0007삽입된\u0007자료의\u0007기억공 •\u0007근 노드(Root Node) (cid:34):\u0007트리의\u0007맨\u0007위에\u0007있는\u0007노드\u0007\u0007\u0007\u0007\u0007A 간을\u0007가리키는\u0007포인터로,\u0007삭제\u0007작업을\u0007할\u0007때\u0007사용함 •디\u0007 그리(Degree, 차수)\u0007:\u0007각\u0007노드에서\u0007뻗어나온\u0007가지의\u0007수 •리\u0007 어(R, Rear) 포인터\u0007:\u0007가장\u0007마지막에\u0007삽입된\u0007자료가\u0007위 (cid:35) (cid:36) (cid:37) 치한\u0007기억장소를\u0007가리키는\u0007포인터로,\u0007삽입\u0007작업을\u0007할\u0007 \u0007\u0007\u0007\u0007\u0007A\u0007=\u00073,\u0007B\u0007=\u00072,\u0007C\u0007=\u00071,\u0007D\u0007=\u00073 때\u0007사용함 • 트리의(cid:38) 디그(cid:39)리 :\u0007노드(cid:40) 들의(cid:41)\u0007디그리(cid:42)\u0007중에서\u0007가장\u0007많은\u0007수 Queue를 이용하는 예 \u0007\u0007\u0007\u0007\u0007노드\u0007A나\u0007D가\u00073개의\u0007디그리를\u0007가지므로\u0007위\u0007트리의\u0007 (cid:45) (cid:46) •\u0007창구\u0007업무처럼\u0007서비스\u0007순서를\u0007기다리는\u0007등의\u0007대기\u0007행 디그리는\u00073이다. 렬의\u0007처리에\u0007사용한다. • 단말 노드(Terminal Node) = 잎 노드(Leaf Node)\u0007:\u0007자식이\u0007 하나도\u0007없는\u0007노드,\u0007즉\u0007디그리가\u00070인\u0007노드\u0007 •운\u0007 영체제의\u0007작업\u0007스케줄링에\u0007사용한다. \u0007\u0007\u0007\u0007\u0007K,\u0007L,\u0007F,\u0007G,\u0007M,\u0007I,\u0007J •\u0007비단말 노드(Non-Terminal Node)\u0007:\u0007자식이\u0007하나라도\u0007있는\u0007 핵심 07.9, 06.3, 05.4 052 데크(Deque) 노드,\u0007즉\u0007디그리가\u00070이\u0007아닌\u0007노드\u0007 \u0007\u0007\u0007\u0007\u0007A,\u0007B,\u0007C,\u0007D,\u0007E,\u0007H •\u0007삽입과\u0007삭제가\u0007리스트의\u0007양쪽\u0007끝에서\u0007모두\u0007발생할\u0007수\u0007 • 자식 노드(Son Node, Children Node) :\u0007어떤\u0007노드에\u0007연결 있는\u0007자료\u0007구조이다. 된\u0007다음\u0007레벨의\u0007노드들 •\u0007Double\u0007Ended\u0007Queue의\u0007약자이다. \u0007\u0007\u0007\u0007\u0007D의\u0007자식\u0007노드\u0007:\u0007H,\u0007I,\u0007J •\u0007Stack과\u0007Queue의\u0007장점만\u0007따서\u0007구성한\u0007것이다. •\u0007부모 노드(Parent Node) :\u0007어떤\u0007노드에\u0007연결된\u0007이전\u0007레벨 •\u0007입력이\u0007한쪽에서만\u0007발생하고\u0007출력은\u0007양쪽에서\u0007일어날\u0007 의\u0007노드 수\u0007있는\u0007입력\u0007제한과\u0007입력은\u0007양쪽에서\u0007일어나고\u0007출력 21 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 19] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 \u0007\u0007\u0007\u0007\u0007E,\u0007F의\u0007부모\u0007노드는\u0007B ➊\u0007Preorder는\u0007Root\u0007→\u0007Left\u0007→\u0007Right이므로\u0007A13이\u0007 된다. • 형제 노드(Brother Node, Sibling)\u0007:\u0007동일한\u0007부모를\u0007갖는\u0007노 드들 ➋\u00071은\u0007B2E이므로\u0007AB2E3이\u0007된다. \u0007\u0007\u0007\u0007\u0007H의\u0007형제\u0007노드는\u0007I,\u0007J ➌\u00072는\u0007DHI이므로\u0007ABDHIE3이\u0007된다. • Level\u0007:\u0007근\u0007노드의\u0007Level을\u00071로\u0007가정한\u0007후\u0007어떤\u0007Level이\u0007 ➍\u00073은\u0007CFG이므로\u0007ABDHIECFG가\u0007된다.\u0007\u0007\u0007 L이면\u0007자식\u0007노드는\u0007L+1이다. ∴ 방문 순서 :\u0007ABDHIECFG \u0007\u0007\u0007\u0007\u0007H의\u0007레벨은\u00073 <Inorder 운행법의 방문 순서> •깊\u0007 이(Depth, Height)\u0007:\u0007어떤\u0007Tree에서\u0007노드가\u0007가질\u0007수\u0007있 ➊\u0007Inorder는\u0007Left\u0007→\u0007Root\u0007→\u0007Right이므로\u00071A3이\u0007된다.\u0007 는\u0007최대의\u0007레벨 ➋1은\u00072BE이므로\u00072BEA3이\u0007된다. \u0007\u0007\u0007\u0007\u0007위\u0007트리의\u0007깊이는\u00074 ➌2는\u0007HDI이므로\u0007HDIBEA3이\u0007된다. ➍3은\u0007FCG이므로\u0007HDIBEAFCG가\u0007된다. 핵심 14.8, 14.5, 14.3, 13.8, 13.3, 12.8, 12.5, 11.8, 11.6, 10.5, 10.3, 09.8, 08.9, 08.5, 08.3, 07.5, 06.9, 04.3, 02.3 054 이진 트리의 운행법 ∴ 방문 순서\u0007:\u0007HDIBEAFCG \u0007\u0007\u0007\u0007 <Postorder의 방문 순서> (cid:34) ➊\u0007Postorder는\u0007Left\u0007→\u0007Right\u0007→\u0007Root이므로\u000713A가\u0007 (cid:35) (cid:36) 된다. ➋1은\u00072EB이므로\u00072EB3A가\u0007된다. • Preorder(전위) 운행\u0007:\u0007Root\u0007→\u0007Left\u0007→\u0007Right\u0007순으로\u0007운 행함\u0007A,\u0007B,\u0007C ➌2는\u0007HID이므로\u0007HIDEB3A가\u0007된다. •\u0007Inorder(중위) 운행\u0007:\u0007Left\u0007→\u0007Root\u0007→\u0007Right\u0007순으로\u0007운행 ➍3은\u0007FGC이므로\u0007HIDEBFGCA가\u0007된다. 함\u0007B,\u0007A,\u0007C ∴ 방문 순서\u0007:\u0007HIDEBFGCA • Postorder(후위) 운행\u0007:\u0007Left\u0007→\u0007Right\u0007→\u0007Root\u0007순으로\u0007 운행함\u0007B,\u0007C,\u0007A\u0007 핵심 14.5, 12.3, 09.5, 09.3, 07.9, 07.3, 06.5, 06.3, 05.5, 05.4, 05.3, 04.9, 04.3, 03.5 \u0007\u0007\u0007\u0007\u0007다음\u0007트리를\u0007Inorder,\u0007Preorder,\u0007Postorder\u0007방법으 055 수식의 표기법 로\u0007운행했을\u0007때\u0007각\u0007노드를\u0007방문한\u0007순서는? (cid:34) (cid:12) (cid:35) (cid:36) (cid:34) (cid:35) \u0007\u0007 (cid:37) (cid:38) (cid:39) (cid:40) •\u0007전위 표기법(Prefix) :\u0007연산자\u0007→\u0007Left\u0007→\u0007Right,\u0007+AB (cid:41) (cid:42) •중\u0007 위 표기법(Infix) :\u0007Left\u0007→\u0007연산자\u0007→\u0007Right,\u0007A+B <Preorder 운행법의 방문 순서> •후\u0007 위 표기법(Postfix) :\u0007Left\u0007→\u0007Right\u0007→\u0007연산자,\u0007AB+ 서브\u0007트리를\u0007하나의\u0007노드로\u0007생각할\u0007수\u0007있도록\u0007다음과\u0007 Infix 표기를 Postfix로 바꾸기 같이\u0007서브\u0007트리\u0007단위로\u0007묶는다.\u0007Preorder,\u0007Inorder,\u0007 \u0007Infix로\u0007표기된\u0007수식에서\u0007연산자를\u0007해당\u0007피연산자\u00072개의\u0007 Postorder\u0007모두\u0007공통으로\u0007사(cid:34) 용한다. 뒤(오른쪽)에\u0007오도록\u0007이동하면\u0007Postfix가\u0007된다. (cid:18) (cid:20) (cid:35) (cid:36) (cid:19) X\u0007=\u0007A\u0007/\u0007B\u0007*\u0007(C\u0007+\u0007D)\u0007+\u0007E\u0007\u0007\u0007\u0007\u0007X\u0007A\u0007B\u0007/\u0007C\u0007D\u0007+\u0007*\u0007E\u0007+\u0007= (cid:37) (cid:38) (cid:39) (cid:40) ➊\u0007연산\u0007우선순위에\u0007따라\u0007괄호로\u0007묶는다. (cid:41) (cid:42) \u0007\u0007\u0007\u0007(\u0007X\u0007\u0007=\u0007\u0007(\u0007\u0007(\u0007\u0007(A\u0007\u0007/\u0007\u0007B)\u0007*\u0007(C\u0007+\u0007D)\u0007\u0007)\u0007+\u0007E\u0007\u0007)\u0007\u0007) 22 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 20] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 ➋\u0007연산자를\u0007해당\u0007괄호의\u0007뒤로\u0007옮긴다. 핵심 02.9, 01.9 056 정렬(Sort) 파일을\u0007구성하는\u0007각\u0007레코드들을\u0007특정\u0007키\u0007항목을\u0007기준으 \u0007\u0007\u0007\u0007  로\u0007오름차순(Ascending)\u0007또는\u0007내림차순(Descending)으 로\u0007재배열하는\u0007작업이다. \u0007\u0007\u0007\u0007\u0007(\u0007X\u0007\u0007(\u0007\u0007(\u0007\u0007(AB)\u0007/\u0007(CD)\u0007+\u0007)\u0007*\u0007E\u0007\u0007)\u0007\u0007+\u0007)\u0007=\u0007 내부 정렬 ➌\u0007괄호를\u0007제거한다. •소\u0007 량의\u0007데이터를\u0007주기억장치에만\u0007기억시켜서\u0007정렬하 \u0007\u0007\u0007\u0007X\u0007A\u0007B\u0007/\u0007C\u0007D\u0007+\u0007*\u0007E\u0007+\u0007=\u0007 는\u0007방식이다. Infix 표기를 Prefix로 바꾸기 •\u0007종류\u0007:\u0007히프\u0007정렬,\u0007삽입\u0007정렬,\u0007셸\u0007정렬,\u0007버블\u0007정렬,\u0007선택\u0007 Infix로\u0007표기된\u0007수식에서\u0007연산자를\u0007해당\u0007피연산자\u00072개의\u0007 정렬,\u0007퀵\u0007정렬,\u00072-Way\u0007Merge\u0007정렬,\u0007기수\u0007정렬 앞(왼쪽)에\u0007오도록\u0007이동하면\u0007Prefix가\u0007된다. (=Radix\u0007Sort) ➊\u0007연산\u0007우선순위에\u0007따라\u0007괄호로\u0007묶는다. 외부 정렬 \u0007\u0007\u0007\u0007\u0007(X\u0007=\u0007(\u0007(\u0007(A\u0007/\u0007B)\u0007*\u0007(C\u0007+\u0007D)\u0007)\u0007+\u0007E)\u0007) •\u0007대량의\u0007데이터를\u0007보조기억장치에\u0007기억시켜서\u0007정렬하 ➋\u0007연산자를\u0007해당\u0007괄호의\u0007앞으로\u0007옮긴다. 는\u0007방식으로,\u0007대부분\u0007병합\u0007정렬(Merge\u0007Sort)\u0007기법으로\u0007 처리한다. (cid:9)(cid:57)(cid:1)(cid:30)(cid:1)(cid:9)(cid:1)(cid:9)(cid:1)(cid:9)(cid:34)(cid:1)(cid:16)(cid:1)(cid:35)(cid:10)(cid:1)(cid:1)(cid:1)(cid:9)(cid:36)(cid:1)(cid:12)(cid:1)(cid:37)(cid:10)(cid:1)(cid:10)(cid:1)(cid:12)(cid:1)(cid:38)(cid:10)(cid:1)(cid:10) \u0007\u0007\u0007\u0007 (cid:11) • 종류\u0007:\u0007밸런스\u0007병합\u0007정렬,\u0007캐스케이드\u0007병합\u0007정렬,\u0007폴리  파즈\u0007병합\u0007정렬,\u0007오실레이팅\u0007병합\u0007정렬 \u0007\u0007\u0007\u0007\u0007=(X\u0007+\u0007(\u0007*\u0007(\u0007/\u0007(\u0007A\u0007B)\u0007+\u0007(C\u0007\u0007D)\u0007\u0007)\u0007E)\u0007\u0007) ➌\u0007괄호를\u0007제거한다. 핵심 14.3, 13.8, 13.6, 13.3, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 07.5, 05.3, 01.6 057 주요 정렬 알고리즘의 이해 \u0007\u0007\u0007\u0007\u0007=X\u0007+\u0007*\u0007/\u0007\u0007A\u0007B\u0007+\u0007C\u0007D\u0007E Postfix 표기를 Infix로 바꾸기 삽입 정렬 Postfix는\u0007Infix\u0007표기법에서\u0007연산자를\u0007해당\u0007피연산자\u00072개 예제 \u00078,\u00075,\u00076,\u00072,\u00074를\u0007삽입\u0007정렬로\u0007정렬하시오. (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) 의\u0007뒤(오른쪽)로\u0007이동한\u0007것이므로\u0007연산자를\u0007다시\u0007해당\u0007피 •\u0007초기 상태\u0007:\u0007 (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) 연산자\u00072개의\u0007가운데로\u0007옮기면\u0007된다. \u0007A\u0007B\u0007C\u0007-\u0007/\u0007D\u0007E\u0007F\u0007+\u0007*\u0007+\u0007\u0007\u0007\u0007\u0007A\u0007/\u0007(B\u0007-\u0007C)\u0007+D\u0007*\u0007(E\u0007+\u0007F) \u0007\u0007\u0007 •\u00071회전\u0007:\u0007 (cid:25)(cid:25) (cid:22)(cid:22) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) \u0007\u0007\u0007\u0007두\u0007번째\u0007값(cid:25)(cid:25)\u00075를(cid:22)(cid:22)\u0007첫\u0007(cid:23)(cid:23)번째(cid:19)(cid:19)\u0007값(cid:21)(cid:21)과\u0007비교하(cid:22)여\u0007(cid:25)첫\u0007번(cid:23)째\u0007(cid:19)자리(cid:21)에\u0007 ➊\u0007먼저\u0007인접한\u0007피연산자\u00072개와\u0007오른쪽의\u0007연산자를\u0007괄호 삽입하고\u00078을\u0007한\u0007칸\u0007뒤로\u0007이동시킨다. 로\u0007묶는다. (cid:25)(cid:22) (cid:22)(cid:25) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22)(cid:22) (cid:25)(cid:23) (cid:23)(cid:25) (cid:19)(cid:19) (cid:21)(cid:21) \u0007\u0007\u0007\u0007(\u0007\u0007(A\u0007\u0007(B\u0007\u0007C\u0007\u0007-)\u0007\u0007/)\u0007\u0007(D\u0007\u0007(E\u0007\u0007F\u0007\u0007+)\u0007\u0007*)\u0007\u0007+\u0007) •2회전\u0007:\u0007 (cid:22)(cid:25) (cid:22) (cid:25)(cid:22) (cid:25) (cid:23)(cid:23) (cid:23) (cid:19)(cid:19) (cid:19) (cid:21)(cid:21) (cid:21) (cid:22)(cid:22) (cid:22) (cid:23)(cid:25) (cid:23) (cid:25)(cid:23) (cid:25) (cid:19)(cid:19) (cid:19) (cid:21)(cid:21) (cid:21) ➋연산자를\u0007해당\u0007피연산자의\u0007가운데로\u0007이동시킨다. \u0007\u0007\u0007\u0007세\u0007번째\u0007값(cid:22)\u0007 (cid:22)6을(cid:25)(cid:23)\u0007첫\u0007번(cid:23)(cid:25) 째(cid:19)(cid:19),\u0007두\u0007(cid:21)(cid:21)번째\u0007값과(cid:22)(cid:19)\u0007비(cid:23)(cid:22)교하(cid:25)(cid:23)여\u00078(cid:19)(cid:25)자리(cid:21)(cid:21)에\u0007 삽입하고\u00078은\u0007한\u0007칸\u0007뒤로\u0007이동시킨다. (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) \u0007\u0007\u0007\u0007 (cid:22)(cid:22) (cid:23)(cid:25) (cid:25)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:19)(cid:22) (cid:22)(cid:23) (cid:23)(cid:25) (cid:25)(cid:19) (cid:21)(cid:21)  •\u00073회전\u0007:\u0007 (cid:22)(cid:19) (cid:23)(cid:22) (cid:25)(cid:23) (cid:19)(cid:25) (cid:21)(cid:21) (cid:19)(cid:19) (cid:22)(cid:21) (cid:23)(cid:22) (cid:25)(cid:23) (cid:21)(cid:25) \u0007\u0007\u0007\u0007\u0007(\u0007(\u0007A\u0007/\u0007(\u0007B\u0007-\u0007C\u0007)\u0007)\u0007+\u0007(\u0007D\u0007*\u0007(\u0007E\u0007+\u0007F\u0007)\u0007)\u0007)\u0007\u0007 \u0007\u0007\u0007\u0007네\u0007번째\u0007값 (cid:19)(cid:22)\u00072를(cid:19) (cid:22)(cid:23)\u0007처음(cid:22) (cid:23)(cid:25)부(cid:23) (cid:25)터 (cid:19) \u0007비(cid:25) (cid:21)(cid:21)교하(cid:21) 여\u0007 (cid:19)맨 (cid:19) \u0007처(cid:19) (cid:21)(cid:22)음에(cid:21) (cid:22)(cid:23)\u0007삽(cid:22) (cid:23)(cid:25)입하(cid:23) (cid:25)(cid:21)고\u0007(cid:25) ➌필요\u0007없는\u0007괄호를\u0007제거한다. 나머지를\u0007한\u0007칸씩\u0007뒤로\u0007이동시킨다. (cid:19)(cid:22) (cid:22)(cid:25) (cid:23)(cid:23) (cid:25)(cid:19) (cid:21)(cid:21) (cid:22)(cid:19) (cid:23)(cid:21) (cid:25)(cid:22) (cid:19)(cid:23) (cid:21)(cid:25) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) \u0007\u0007\u0007\u0007A\u0007/\u0007(B\u0007-\u0007C)\u0007+\u0007D\u0007*\u0007(E\u0007+\u0007F) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) •4회전\u0007:\u0007 (cid:22)(cid:19) (cid:25)(cid:22) (cid:23)(cid:23) (cid:19)(cid:25) (cid:21)(cid:21) (cid:22)(cid:19) (cid:23)(cid:21) (cid:25)(cid:22) (cid:19)(cid:23) (cid:21)(cid:25) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) \u0007\u0007\u0007\u0007다섯\u0007번째\u0007값\u00074를\u0007처음부터\u0007비교하여\u00075자리에\u0007삽입하고\u0007 (cid:22)(cid:22) (cid:25)(cid:23) (cid:23)(cid:19) (cid:19)(cid:21) (cid:21)(cid:25) (cid:22)(cid:22) (cid:23)(cid:19) (cid:25)(cid:23) (cid:19)(cid:21) (cid:21)(cid:25) (cid:22)(cid:22) (cid:23)(cid:19) (cid:19)(cid:21) (cid:25)(cid:23) (cid:21)(cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) 나머지를\u0007한\u0007칸씩\u0007뒤로\u0007이동시킨다. (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) 23 (cid:22)(cid:22) (cid:23)(cid:25) (cid:19)(cid:23) (cid:21)(cid:19) (cid:25)(cid:21) (cid:22)(cid:22) (cid:19)(cid:23) (cid:23)(cid:25) (cid:21)(cid:19) (cid:25)(cid:21) (cid:22)(cid:22) (cid:19)(cid:23) (cid:21)(cid:19) (cid:23)(cid:25) (cid:25)(cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22)(cid:19) (cid:23)(cid:22) (cid:19)(cid:21) (cid:21)(cid:23) (cid:25)(cid:25) (cid:22)(cid:19) (cid:19)(cid:21) (cid:23)(cid:22) (cid:21)(cid:23) (cid:25)(cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) 정(cid:21)성을 만나(cid:22)보세요(cid:23) (cid:25) (cid:19)(cid:22) (cid:22)(cid:23) (cid:21)(cid:19) (cid:23)(cid:21) (cid:25)(cid:25) (cid:19)(cid:22) (cid:21)(cid:19) (cid:22)(cid:23) (cid:23)(cid:21) (cid:25)(cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:19)(cid:19) (cid:22)(cid:21) (cid:21)(cid:22) (cid:23)(cid:23) (cid:25)(cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19)(cid:19) (cid:21)(cid:22) (cid:22)(cid:21) (cid:23)(cid:23) (cid:25)(cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19)(cid:25) (cid:21)(cid:22) (cid:22)(cid:23) (cid:23)(cid:19) (cid:25)(cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25)(cid:19) (cid:22)(cid:21) (cid:23)(cid:22) (cid:19)(cid:23) (cid:21)(cid:25) (cid:25)(cid:22) (cid:22)(cid:25) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:22)(cid:25) (cid:25)(cid:22) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:22)(cid:19) (cid:25)(cid:23) (cid:23)(cid:25) (cid:19)(cid:22) (cid:21)(cid:21) (cid:22)(cid:19) (cid:25)(cid:22) (cid:23)(cid:25) (cid:19)(cid:23) (cid:21)(cid:21) (cid:19)(cid:19) (cid:25)(cid:21) (cid:23)(cid:25) (cid:22)(cid:23) (cid:21)(cid:22) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:23) (cid:25) (cid:22) (cid:21) (cid:19) (cid:22) (cid:25) (cid:23) (cid:21) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:19)(cid:22) (cid:23)(cid:25) (cid:25)(cid:23) (cid:22)(cid:19) (cid:21)(cid:21) (cid:19)(cid:22) (cid:22)(cid:25) (cid:25)(cid:23) (cid:23)(cid:19) (cid:21)(cid:21) (cid:19)(cid:19) (cid:21)(cid:25) (cid:25)(cid:23) (cid:23)(cid:22) (cid:22)(cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19)(cid:19) (cid:23)(cid:21) (cid:25)(cid:23) (cid:22)(cid:25) (cid:21)(cid:22) (cid:19)(cid:19) (cid:22)(cid:21) (cid:25)(cid:22) (cid:23)(cid:25) (cid:21)(cid:23) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19)(cid:19) (cid:21)(cid:23) (cid:23)(cid:25) (cid:25)(cid:22) (cid:22)(cid:21) (cid:19)(cid:19) (cid:21)(cid:22) (cid:22)(cid:25) (cid:25)(cid:23) (cid:23)(cid:21) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:19)(cid:19) (cid:21)(cid:21) (cid:23)(cid:22) (cid:25)(cid:23) (cid:22)(cid:25) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22)(cid:23) (cid:23)(cid:25) (cid:25)(cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25)",
    "[페이지 21] (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25)(cid:25) (cid:22)(cid:22) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25)(cid:25) (cid:22)(cid:22) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22)(cid:25) (cid:22) (cid:25)(cid:22) (cid:23) (cid:23)(cid:23) (cid:19) (cid:19)(cid:19) (cid:21) (cid:21)(cid:21) (cid:22)(cid:22) (cid:23)(cid:25) (cid:25)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) 시 나험 오에 는 것만 (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) 정보처리기사 필기 공부한다! (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25)(cid:25) (cid:22)(cid:23) (cid:23)(cid:19) (cid:19)(cid:21) (cid:21) (cid:22) (cid:22)(cid:23) (cid:25)(cid:25) (cid:23)(cid:19)시나 (cid:19)공(cid:21) 시리(cid:21)즈 (cid:22)(cid:22) (cid:25) (cid:25)(cid:25) (cid:22) (cid:23)(cid:23) (cid:23) (cid:19)(cid:19) (cid:19) (cid:21)(cid:21) (cid:21) (cid:22)(cid:22) (cid:22) (cid:23)(cid:23) (cid:25) (cid:25)(cid:25) (cid:23) (cid:19)(cid:19) (cid:19) (cid:21)(cid:21) (cid:21) 핵심 요약 (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:25) (cid:22)(cid:22) (cid:22) (cid:23)(cid:25) (cid:23) (cid:25)(cid:23) (cid:19) (cid:19)(cid:19) (cid:21) (cid:21)(cid:21) (cid:22) (cid:19)(cid:22) (cid:25) (cid:22)(cid:23) (cid:23) (cid:23)(cid:25) (cid:25)(cid:19)(cid:19) (cid:21) (cid:21)(cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) 버(cid:23)블 정(cid:19) 렬(cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) \u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007↓ (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:22)(cid:23) (cid:25)(cid:25) (cid:23)(cid:19) (cid:19)(cid:21) (cid:21) (cid:19) (cid:22)(cid:22) (cid:23)(cid:23) 예(cid:25)(cid:25) 제(cid:19)\u0007(cid:21) 8,\u00075(cid:21),\u00076(cid:22)(cid:22) ,(cid:22)\u00072,\u0007(cid:23)(cid:23) (cid:25)4를\u0007(cid:25)(cid:25) (cid:23)버블(cid:19)(cid:19) (cid:19)\u0007정렬(cid:21)(cid:21) (cid:21) 로\u0007정렬(cid:19)(cid:19) (cid:22)하시(cid:22)(cid:22) (cid:23)오.(cid:23)(cid:23) (cid:25) (cid:25)(cid:25) (cid:19) (cid:21)(cid:21) (cid:21) \u0007\u0007\u0007(2,\u000771)\u0007(5,\u000738)\u0007(7,\u000761)\u0007(11,\u000726)\u0007(42,\u000753) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:22) (cid:19)(cid:22) (cid:25) (cid:22)(cid:23) (cid:23) (cid:23)(cid:25) (cid:25)(cid:19)(cid:19) (cid:21) (cid:21)(cid:21) (cid:22) (cid:19)(cid:19) (cid:23) (cid:21)(cid:22) (cid:25) (cid:22)(cid:23) (cid:23)(cid:19)(cid:25) (cid:21) (cid:25)(cid:21) •2\u0007회전\u0007:\u0007묶여진\u0007묶음을\u00072개씩\u0007묶은\u0007후\u0007각각의\u0007묶음\u0007안에 •초기 상태\u0007:\u0007 (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) 서\u0007정렬합니다. (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19)(cid:22) (cid:22)(cid:23) (cid:23)(cid:25) (cid:25)(cid:19) (cid:21)(cid:21) (cid:19)(cid:19) (cid:21)(cid:22) (cid:22)(cid:23) (cid:23)(cid:25) (cid:25)(cid:21) \u0007\u0007\u0007((2,\u000771)\u0007(5,\u000738))\u0007((7,\u000761)\u0007(11,\u000726))\u0007(42,\u000753) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) •(cid:22) 1회전(cid:23)\u0007:\u0007\u0007(cid:25) (cid:22) (cid:22)(cid:19) (cid:23) (cid:25)(cid:22) (cid:25) (cid:23)(cid:23) (cid:19) (cid:19)(cid:25) (cid:21) (cid:21)(cid:21) (cid:22)(cid:19)(cid:19) (cid:23)(cid:22)(cid:21) (cid:25)(cid:23)(cid:22) (cid:19)(cid:25)(cid:23) (cid:21)(cid:21)(cid:25) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) \u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007↓ (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) \u0007\u0007\u0007(2,\u00075,\u000738,\u000771)\u0007(7,\u000711,\u000726,\u000761)\u0007(42,\u000753) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22)(cid:22) (cid:25)(cid:23) (cid:23)(cid:19) (cid:19)(cid:25) (cid:21)(cid:21) (cid:22)(cid:22) (cid:23)(cid:23) (cid:25)(cid:19) (cid:19)(cid:21) (cid:21)(cid:25) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:22)(cid:19) (cid:25)(cid:22) (cid:23)(cid:23) (cid:19)(cid:25) (cid:21)(cid:21) (cid:22)(cid:19) (cid:23)(cid:21) (cid:25)(cid:22) (cid:19)(cid:23) (cid:21)(cid:25) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22)(cid:22) (cid:22)(cid:22) (cid:23)(cid:25) (cid:23)(cid:23) (cid:19)(cid:23) (cid:19)(cid:25) (cid:21)(cid:19) (cid:25)(cid:21) (cid:25)(cid:21) (cid:21) (cid:22)(cid:22)(cid:19) (cid:22)(cid:19)(cid:23)(cid:21) (cid:23)(cid:23)(cid:25)(cid:22) (cid:19)(cid:21)(cid:19)(cid:23) (cid:21)(cid:25)(cid:21)(cid:25) (cid:25) (cid:22)(cid:22) (cid:19)(cid:23)•3\u0007회 (cid:21)(cid:19)전\u0007 (cid:23)(cid:25):\u0007묶 (cid:25)(cid:21)여진\u0007묶음 (cid:22) 을 (cid:23)\u00072개 (cid:19)씩\u0007묶 (cid:21) 은 (cid:25)\u0007후\u0007각각의\u0007묶음\u0007안에 (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) 서\u0007정렬합니다. •\u00072회전\u0007:\u0007\u0007 (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22)(cid:22) (cid:23)(cid:19) (cid:19)(cid:21) (cid:21)(cid:23) (cid:25)(cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19)\u0007\u0007\u0007(((cid:21)2,\u00075(cid:23),\u000738(cid:25),\u000771)\u0007(7,\u000711,\u000726,\u000761))\u0007(42,\u000753) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22)(cid:22) (cid:22)(cid:23)(cid:25) (cid:23)(cid:19)(cid:23) (cid:19)(cid:21)(cid:19) (cid:25)(cid:25)(cid:21) (cid:21) (cid:22)(cid:22) (cid:22)(cid:19)(cid:23) (cid:23)(cid:23)(cid:25) (cid:19)(cid:21)(cid:19) (cid:21)(cid:25)(cid:21) (cid:25) (cid:22)(cid:22) (cid:19)(cid:23) (cid:21)(cid:19) (cid:23)(cid:25) (cid:25)(cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19)(cid:22) (cid:22)(cid:25) (cid:22)(cid:23) (cid:19)(cid:23) (cid:21)(cid:19) (cid:21)(cid:23)(cid:19)(cid:21) (cid:23)(cid:21) (cid:25)(cid:25) (cid:25) (cid:22) (cid:19)(cid:22) (cid:23) (cid:21)(cid:19) (cid:25) (cid:22)(cid:23) (cid:23)(cid:19)(cid:21) (cid:21) (cid:25)(cid:25) (cid:22)(cid:22) (cid:23)(cid:19)\u0007\u0007\u0007\u0007\u0007(cid:19) \u0007(cid:21)\u0007\u0007\u0007\u0007\u0007(cid:25)(cid:23)\u0007\u0007\u0007\u0007\u0007(cid:21) \u0007(cid:25)\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007(cid:22) ↓ (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) \u0007\u0007\u0007(2,\u00075,\u00077,\u000711,\u000726,\u000738,\u000761,\u000771)\u0007(42,\u000753) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23)•3회(cid:21)전\u0007(cid:25):\u0007\u0007 (cid:19)(cid:22) (cid:22)(cid:22)(cid:23) (cid:19)(cid:21)(cid:19) (cid:21)(cid:23)(cid:21) (cid:23)(cid:25)(cid:25) (cid:25) (cid:19)(cid:22) (cid:21)(cid:19) (cid:22)(cid:23) (cid:23)(cid:21) (cid:25)(cid:25) (cid:22) (cid:19)•4회(cid:21)전\u0007(cid:23):\u0007묶여(cid:25) 진\u0007묶음\u00072개를\u0007하나로\u0007묶은\u0007후\u0007정렬합니다. (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:22) (cid:19)(cid:19) (cid:23) (cid:21)(cid:22) (cid:19) (cid:22)(cid:21) (cid:21) (cid:23)(cid:23) (cid:25) (cid:25)(cid:25) (cid:22)(cid:19) (cid:19)(cid:21) (cid:23)(cid:22) (cid:21)(cid:23) (cid:25)(cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) \u0007\u0007\u0007((2,\u00075,\u00077,\u000711,\u000726,\u000738,\u000761,\u000771)\u0007(42,\u000753)) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) •4회전\u0007:\u0007\u0007 (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) \u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007↓ (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19)(cid:19) (cid:21)(cid:22) (cid:22)(cid:21) (cid:23)(cid:23) (cid:25)(cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:25)(cid:19)(cid:19) (cid:22) (cid:22)(cid:21) (cid:21) (cid:23)(cid:22) (cid:23) (cid:19)(cid:23) (cid:25) (cid:21)(cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) \u0007\u0007\u00072,\u00075,\u00077,\u000711,\u000726,\u000738,\u000742,\u000753,\u000761,\u000771 (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:19) (cid:25) (cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:19) (cid:22) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) 선택 정렬 (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:25) (cid:19)(cid:22) (cid:21)(cid:23) (cid:22)(cid:19) (cid:23)(cid:21) (cid:25) 예제 \u00078,\u00075,\u00076 (cid:25)(cid:25) ,(cid:19)\u00072,\u0007 (cid:22)(cid:22) (cid:21)4를\u0007 (cid:23)(cid:23) (cid:22)선택 (cid:19)(cid:19) (cid:23)\u0007정렬 (cid:21)(cid:21) (cid:25) 로\u0007정렬하시오. 핵심 13.6, 11.3, 06.3, 05.5, 04.9, 03.3, 02.5, 00.7 (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:19) (cid:22)(cid:25) (cid:21) (cid:25)(cid:22) (cid:22) (cid:23)(cid:23) (cid:23) (cid:19)(cid:19) (cid:25) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) 0(cid:23)58(cid:22) 이(cid:21)분 검색(cid:19)(이(cid:25)진 검(cid:23) 색(cid:22)) (cid:21) •초기 상태\u0007:\u0007 (cid:22)(cid:25) (cid:23)(cid:22) (cid:19)(cid:23) (cid:21)(cid:19) (cid:25)(cid:21) (cid:22) (cid:19) (cid:23) (cid:21) (cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22)(cid:19) (cid:25)(cid:25) (cid:23)(cid:23) (cid:19)(cid:22) (cid:21)(cid:21) (cid:22)(cid:19) (cid:25)(cid:25) (cid:23)(cid:23) (cid:19)(cid:22) (cid:21)(cid:21) (cid:19) (cid:25)•\u0007제(cid:23)어\u0007검(cid:22) 색(cid:21)의\u0007일종(cid:19)인\u0007이(cid:25)분\u0007(cid:23)검색(cid:22)은\u0007반(cid:21) 드시\u0007순서화된\u0007파일 (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22)(cid:25) (cid:25)(cid:22) (cid:23)(cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) •(cid:23) \u00071회(cid:19)전\u0007:(cid:21)\u0007 (cid:25) (cid:19)(cid:22) (cid:19)(cid:22) (cid:23)(cid:25) (cid:25)(cid:23) (cid:25)(cid:23) (cid:23)(cid:19) (cid:22)(cid:19) (cid:22)(cid:21) (cid:21)(cid:21) (cid:21) (cid:19)(cid:22) (cid:19)(cid:22)(cid:25) (cid:25)(cid:25)(cid:23) (cid:23)(cid:23)(cid:19) (cid:22)(cid:21)(cid:21) (cid:21) (cid:19)(cid:19) (cid:21)(cid:25) 이 (cid:25)(cid:23)어야 (cid:23)(cid:22)\u0007검 (cid:22)(cid:21)색할\u0007수\u0007 (cid:19)있다 (cid:25). (cid:23) (cid:22) (cid:21) (cid:19)(cid:25) (cid:22)(cid:22) (cid:21)(cid:23) (cid:23)(cid:19) (cid:25)(cid:21) (cid:19)(cid:22) (cid:21)(cid:25) (cid:22)(cid:23) (cid:23)(cid:19) (cid:25)(cid:21) (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:19) (cid:23) (cid:25) (cid:22) (cid:21) (cid:19) (cid:22) (cid:25) (cid:23) (cid:21) (cid:19) (cid:21)•\u0007탐(cid:25)색\u0007효(cid:23) 율(cid:22)이\u0007좋고\u0007탐색\u0007시간이\u0007적게\u0007소요된다.\u0007 (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:22)(cid:23) (cid:25)(cid:25) (cid:23)(cid:22) (cid:19)(cid:21) (cid:21) (cid:19) (cid:22)(cid:22) (cid:25)(cid:25) (cid:23)(cid:23) (cid:19)(cid:21) (cid:21) (cid:19)(cid:19)(cid:19)(cid:22) (cid:19)(cid:23)(cid:23)(cid:21)(cid:25) (cid:25)(cid:25)(cid:25)(cid:25)(cid:23) (cid:23)(cid:22)(cid:22)(cid:23)(cid:19) (cid:22)(cid:21)(cid:21)(cid:22)(cid:21) (cid:21) (cid:19)(cid:19) (cid:22) (cid:19)(cid:22)(cid:22) (cid:25) (cid:25)(cid:25)(cid:25) (cid:23) (cid:23)(cid:23)(cid:23) (cid:19) (cid:22)(cid:21)(cid:21) (cid:21) (cid:21) (cid:19)(cid:19) (cid:19) (cid:21)(cid:21) (cid:25)•\u0007전(cid:25)(cid:25) (cid:23)체\u0007(cid:23)(cid:23) 파(cid:22) 일(cid:22)(cid:22) (cid:21)을\u0007두\u0007개(cid:19)의\u0007(cid:25)서브(cid:23)\u0007파(cid:22)일로(cid:21)\u0007분리해\u0007가면서\u0007Key\u0007 (cid:19) (cid:23) (cid:25) (cid:22) (cid:21) (cid:19) (cid:22) (cid:25) (cid:23) (cid:21) (cid:22) (cid:19)(cid:19) (cid:19)(cid:25) (cid:21)(cid:23) (cid:21)(cid:23) (cid:23)(cid:25) (cid:25)(cid:25)(cid:19)(cid:22) (cid:23)(cid:21) (cid:22)(cid:21) (cid:22) (cid:22) (cid:19)(cid:19) (cid:25) (cid:21)(cid:22) (cid:23) (cid:22)(cid:25) (cid:25)(cid:19)(cid:23) (cid:21) (cid:23)(cid:21) (cid:19)(cid:19) (cid:25)(cid:21) 레(cid:23)(cid:25) 코드(cid:22)(cid:23) 를\u0007(cid:21)(cid:22) 검색하기(cid:19) \u0007때(cid:25) 문에(cid:23) \u0007검(cid:22) 색회(cid:21) 수를\u0007거듭할\u0007때마다\u0007 (cid:19)(cid:22) (cid:21)(cid:25) (cid:22)(cid:23) (cid:23)(cid:19) (cid:25)(cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) 검색\u0007대상이\u0007되는\u0007데이터의\u0007수가\u0007절반으로\u0007줄어든다. •2회전\u0007:\u0007 (cid:19) (cid:23) (cid:25) (cid:22) (cid:21) (cid:19) (cid:22) (cid:25) (cid:23) (cid:21) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:19) (cid:19)(cid:21) (cid:23)(cid:23) (cid:25)(cid:25) (cid:22)(cid:22) (cid:21) (cid:19) (cid:19)(cid:21) (cid:22)(cid:22) (cid:25)(cid:25) (cid:23)(cid:23) (cid:21) (cid:19)(cid:19) (cid:19) (cid:19)(cid:21)(cid:21) (cid:23) (cid:21)(cid:23)(cid:23) (cid:25) (cid:25)(cid:25)(cid:25) (cid:22) (cid:23)(cid:22)(cid:22) (cid:21) (cid:22) (cid:19)(cid:19) (cid:19) (cid:21)(cid:21) (cid:22) (cid:22)(cid:22) (cid:25) (cid:25)(cid:25) (cid:23) (cid:23)(cid:23) (cid:21) (cid:19) (cid:21) •\u0007찾(cid:25) 고자(cid:23) \u0007하는(cid:22) \u0007Key\u0007값을\u0007파일의\u0007중간\u0007레코드\u0007Key\u0007값과\u0007비 (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:19)(cid:19) (cid:23) (cid:21)(cid:21) (cid:25) (cid:22)(cid:23) (cid:22) (cid:23)(cid:25) (cid:21) (cid:25)(cid:22) (cid:19)(cid:19) (cid:22)(cid:21) (cid:25)(cid:22) (cid:23)(cid:25) (cid:21)(cid:23) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:25)(cid:22) (cid:22)(cid:23) (cid:23)(cid:25) (cid:19)(cid:19) (cid:21)(cid:21) (cid:19) (cid:22) (cid:23) (cid:25) (cid:21) 교하면서\u0007검색한다. (cid:19) (cid:23) (cid:25) (cid:22) (cid:21) (cid:19) (cid:22) (cid:25) (cid:23) (cid:21) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) F+L (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) • 중간 레코드 번호(M)\u0007:\u0007 (단,\u0007F\u0007:\u0007첫\u0007번째\u0007레코드\u0007번호, (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) 2 (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19)(cid:19) (cid:21)(cid:21) (cid:22)(cid:23) (cid:23)(cid:25) (cid:25)(cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) • 3회전\u0007:\u0007 (cid:19)(cid:19) (cid:21)(cid:21) (cid:23)(cid:22) (cid:25)(cid:23) (cid:22)(cid:25) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) \u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007L\u0007:\u0007마지막\u0007레코드\u0007번호) (cid:22)(cid:19) (cid:25)(cid:22) (cid:23)(cid:23) (cid:19)(cid:25) (cid:21)(cid:21) (cid:22)(cid:19) (cid:25)(cid:21) (cid:23)(cid:22) (cid:19)(cid:23) (cid:21)(cid:25) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) •4회전\u0007:\u0007 (cid:19)(cid:19) (cid:21)(cid:21) (cid:22)(cid:22) (cid:23)(cid:23) (cid:25)(cid:25) 핵심 13.3, 08.5, 07.5, 06.3, 04.5, 04.3, 01.3, 99.4 059 해싱(Hashing) (cid:19)(cid:22) (cid:23)(cid:25) (cid:25)(cid:23) (cid:22)(cid:19) (cid:21)(cid:21) (cid:19)(cid:22) (cid:22)(cid:23) (cid:25)(cid:25) (cid:23)(cid:19) (cid:21)(cid:21) (cid:19)(cid:22) (cid:21)(cid:23) (cid:25)(cid:19) (cid:23)(cid:25) (cid:22)(cid:21) (cid:22) (cid:23) (cid:19) (cid:21) (cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) 2-Way 합병 정렬(Merge Sort) •\u0007Hash\u0007Table이라는\u0007기억공간을\u0007할당하고,\u0007해시\u0007함수 예제 \u000771,\u00072,\u000738,\u00075,\u00077,\u000761,\u000711,\u000726,\u000753,\u000742를\u00072-Way\u0007합병\u0007 (Hash\u0007Function)를\u0007이용하여\u0007레코드\u0007키에\u0007대한\u0007Hash\u0007 정렬로\u0007정렬하시오(cid:19)(cid:22). (cid:21)(cid:23) (cid:23)(cid:19) (cid:25)(cid:21) (cid:22)(cid:25) (cid:19)(cid:22) (cid:21)(cid:19) (cid:22)(cid:23) (cid:25)(cid:21) (cid:23)(cid:25) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) Table\u0007내의\u0007Home\u0007Address를\u0007계산한\u0007후\u0007주어진\u0007레코드 •1회전\u0007:\u00072개씩\u0007묶은\u0007후\u0007각각의\u0007묶음\u0007안에서\u0007정렬합니다. 를\u0007해당\u0007기억장소에\u0007저장하거나\u0007검색\u0007작업을\u0007수행하는\u0007 방식이다. \u0007\u0007\u0007(71,\u00072)\u0007(38,\u00075)\u0007(7,\u000761)\u0007(11,\u000726)\u0007(53,\u000742) (cid:19)(cid:19) (cid:21)(cid:22) (cid:22)(cid:21) (cid:23)(cid:23) (cid:25)(cid:25) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) 24 (cid:19) (cid:21) (cid:22) (cid:23) (cid:25) www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요 (cid:25) (cid:22) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:25) (cid:23) (cid:22) (cid:21) (cid:19) (cid:23) (cid:25) (cid:22) (cid:21) (cid:19) (cid:22) (cid:25) (cid:23) (cid:21) (cid:19) (cid:21) (cid:25) (cid:23) (cid:22) (cid:19) (cid:21) (cid:23) (cid:25) (cid:22) (cid:19) (cid:21) (cid:22) (cid:25) (cid:23) (cid:19) (cid:21) (cid:22) (cid:23) (cid:25)",
    "[페이지 22] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007DAM(직접접근방법)\u0007파일을\u0007구성할\u0007때\u0007해싱이\u0007사용되며,\u0007 순차 파일의 장점 접근\u0007속도는\u0007빠르지만\u0007기억공간이\u0007많이\u0007요구된다. •기\u0007 록\u0007밀도가\u0007높아\u0007기억공간을\u0007효율적으로\u0007사용할\u0007수\u0007있다. •여\u0007 러가지\u0007검색\u0007방식\u0007중\u0007검색\u0007속도가\u0007가장\u0007빠르다. •레\u0007 코드가\u0007키\u0007순서대로\u0007편성되어\u0007취급이\u0007용이하다.\u0007 •삽\u0007 입,\u0007삭제\u0007작업의\u0007빈도가\u0007많을\u0007때\u0007유리한\u0007방식이다. •매\u0007 체\u0007변환이\u0007쉬워\u0007어떠한\u0007매체에도\u0007적용할\u0007수\u0007있다. •키-주소\u0007변환\u0007방법이라고도\u0007한다. •레\u0007 코드를\u0007기록할\u0007때\u0007사용한\u0007키\u0007순서대로\u0007레코드를\u0007처리 해시 테이블(Hash Table) 하는\u0007경우,\u0007다른\u0007편성법보다\u0007처리\u0007속도가\u0007빠르다. •레\u0007 코드를\u00071개\u0007이상\u0007보관할\u0007수\u0007있는\u0007Home\u0007Bucket들로\u0007구 순차 파일의 단점 성한\u0007기억공간으로,\u0007보조기억장치에\u0007구성할\u0007수도\u0007있고\u0007 •파\u0007 일에\u0007새로운\u0007레코드를\u0007삽입,\u0007삭제,\u0007수정하는\u0007경우\u0007파 주기억장치에\u0007구성할\u0007수도\u0007있다. 일\u0007전체를\u0007복사해야\u0007하므로\u0007시간이\u0007많이\u0007소요된다. •데\u0007 이터\u0007검색\u0007시\u0007처음부터\u0007순차적으로\u0007하기\u0007때문에\u0007검색\u0007 효율이\u0007낮다. 핵심 14.5, 14.3, 13.3, 10.3, 09.5, 09.3, 08.9, 05.3, 03.3, 02.9, 02.3, 00.5, 00.3, 99.6 061 색인 순차 파일(Indexed Sequential File) •순\u0007 차\u0007처리와\u0007랜덤\u0007처리가\u0007모두\u0007가능하도록\u0007레코드들을\u0007 키\u0007값\u0007순으로\u0007정렬(Sort)시켜\u0007기록하고,\u0007레코드의\u0007키\u0007항 •\u0007버킷(Bucket)\u0007:\u0007하나의\u0007주소를\u0007갖는\u0007파일의\u0007한\u0007구역을\u0007의 목만을\u0007모은\u0007색인을\u0007구성하여\u0007편성하는\u0007방식이다. 미하며,\u0007버킷의\u0007크기는\u0007같은\u0007주소에\u0007포함될\u0007수\u0007있는\u0007레코 드\u0007수를\u0007의미함 •\u0007색인을\u0007이용한\u0007순차적인\u0007접근\u0007방법을\u0007제공하여\u0007ISAM\u0007 (Index\u0007Sequential\u0007Access\u0007Method)이라고도\u0007한다. •\u0007\u0007슬롯(Slot) :\u00071\u0007개의\u0007레코드를\u0007저장할\u0007수\u0007있는\u0007공간으로\u0007n 개의\u0007슬롯이\u0007모여\u0007하나의\u0007버킷을\u0007형성함 •\u0007레코드를\u0007참조할\u0007때는\u0007색인을\u0007탐색한\u0007후\u0007색인이\u0007가리키 는\u0007포인터(주소)를\u0007사용하여\u0007직접\u0007참조할\u0007수\u0007있다. • Collision(충돌 현상) :\u0007서로\u0007다른\u00072개\u0007이상의\u0007레코드가\u0007같 은\u0007주소를\u0007갖는\u0007현상 •\u0007일반적으로\u0007자기\u0007디스크에\u0007많이\u0007사용되며,\u0007자기\u0007테이프 에서는\u0007사용할\u0007수\u0007없다. •\u0007Synonym\u0007:\u0007같은\u0007Home\u0007Address를\u0007갖는\u0007레코드들의\u0007 집합 색인 순차 파일의 구성 • Overflow •기\u0007 본 구역(Prime Area) :\u0007실제\u0007레코드들을\u0007기록하는\u0007부분 으로,\u0007각\u0007레코드는\u0007키\u0007값\u0007순으로\u0007저장\u0007 \u0007\u0007\u0007-\u0007계산된\u0007Home\u0007Address의\u0007Bucket\u0007내에\u0007저장할\u0007기억공 간이\u0007없는\u0007상태 •색\u0007 인 구역(Index Area) :\u0007기본\u0007구역에\u0007있는\u0007레코드들의\u0007위 치를\u0007찾아가는\u0007색인이\u0007기록되는\u0007부분으로,\u0007트랙\u0007색인\u0007구 \u0007\u0007\u0007-\u0007Bucket을\u0007구성하는\u0007Slot이\u0007여러\u0007개일\u0007때는\u0007Collision은\u0007 역,\u0007실린더\u0007색인\u0007구역,\u0007마스터\u0007색인\u0007구역으로\u0007구분할\u0007수\u0007 발생해도\u0007Overflow는\u0007발생하지\u0007않을\u0007수\u0007있음 있음 •\u0007오버플로 구역(Overflow Area) :\u0007기본\u0007구역에\u0007빈\u0007공간이\u0007없 핵심 14.8, 13.6, 12.3, 11.3, 10.9, 10.5 060 순차 파일(Sequential File) = 순서 파일 어서\u0007새로운\u0007레코드의\u0007삽입이\u0007불가능할\u0007때를\u0007대비하여\u0007 예비적으로\u0007확보해\u0007둔\u0007부분 •입\u0007 력되는\u0007데이터들을\u0007논리적인\u0007순서에\u0007따라\u0007물리적\u0007연 실린더 오버플로 각\u0007실린더마다\u0007만들어지는\u0007오버플로\u0007구역으 속\u0007공간에\u0007순차적으로\u0007기록하는\u0007방식이다. 구역(Cylinder 로,\u0007해당\u0007실린더의\u0007기본\u0007구역에서\u0007오버플로\u0007 •급\u0007 여\u0007관리\u0007등과\u0007같이\u0007변동\u0007사항이\u0007크지\u0007않고\u0007기간별로\u0007 Overflow Area) 된\u0007데이터를\u0007기록함 일괄\u0007처리를\u0007주로\u0007하는\u0007경우에\u0007적합하다. 실린더\u0007오버플로\u0007구역에\u0007더\u0007이상\u0007오버플로\u0007 독립 오버플로 구역 •주\u0007 로\u0007순차\u0007접근이\u0007가능한\u0007자기\u0007테이프에서\u0007사용된다.\u0007 된\u0007데이터를\u0007기록할\u0007수\u0007없을\u0007때\u0007사용할\u0007수\u0007있 (Independent 는\u0007예비\u0007공간으로,\u0007실린더\u0007오버플로\u0007구역과는\u0007 Overflow Area) 별도로\u0007만들어짐 25 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 23] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 색인 순차 파일의 장점 \u0007\u0007\u0007 \u0007다음\u0007불\u0007함수를\u0007간략화하시오. •순\u0007 차\u0007처리와\u0007랜덤\u0007처리가\u0007모두\u0007가능하므로,\u0007목적에\u0007따 •A\u0007+\u0007A·B\u0007=\u0007A·(1\u0007+\u0007B)\u0007=\u0007A·1\u0007=\u0007A 라\u0007융통성\u0007있게\u0007처리할\u0007수\u0007있다. •\u0007A(A\u0007+\u0007B)\u0007=\u0007A·A\u0007+\u0007A·B\u0007=\u0007A\u0007+\u0007A·B\u0007=\u0007A·(1\u0007+\u0007B)\u0007=\u0007 A·1\u0007=\u0007A •효\u0007 율적인\u0007검색이\u0007가능하고\u0007레코드의\u0007삽입,\u0007삭제,\u0007갱신 이\u0007용이하다. •A\u0007+\u0007A·B\u0007=\u0007(A\u0007+\u0007A\u0007)(A\u0007+\u0007B)\u0007=\u00071·(A\u0007+\u0007B)\u0007=\u0007A\u0007+\u0007B ß ß •A(\u0007A\u0007+\u0007B)\u0007=\u0007A·A\u0007+\u0007A·B\u0007=\u00070\u0007+\u0007A·B\u0007=\u0007A·B\u0007 색인 순차 파일의 단점 ß ß •색\u0007 인\u0007구역과\u0007오버플로우\u0007구역을\u0007구성하기\u0007위한\u0007추가\u0007 \u0007\u0007\u0007 \u0007다음\u0007불\u0007함수를\u0007간략화하시오. 기억\u0007공간이\u0007필요하다. •Y\u0007=\u0007AB\u0007+\u0007A\u0007B\u0007+\u0007AB ß ß •파\u0007 일이\u0007정렬되어\u0007있어야\u0007하므로\u0007추가,\u0007삭제가\u0007많으면\u0007 =\u0007A(B\u0007+\u0007B\u0007\u0007)\u0007+\u0007AB ß ß 효율이\u0007떨어진다. =\u0007A(1)\u0007+\u0007AB ß •색\u0007 인을\u0007이용한\u0007액세스를\u0007하기\u0007때문에\u0007액세스\u0007시간이\u0007 =\u0007A\u0007+\u0007AB ß 랜덤\u0007편성\u0007파일보다\u0007느리다. =\u0007(A\u0007+\u0007A)(A\u0007+\u0007B) ß =\u00071·(A\u0007+\u0007B) =\u0007A\u0007+\u0007B 카르노 맵(카르노 도, Karnaugh Map) 이용하기 2과목·전자계산기 구조 카르노\u0007맵은\u0007설계된\u0007논리식을\u0007도표로\u0007표현하여\u0007최소화하 는\u0007방법이다.\u0007여기서는\u0007카르노\u0007맵으로\u0007표현된\u0007도표를\u0007간 핵심 02.9, 02.5 략화하여\u0007표기하는\u0007방법에\u0007대해서만\u0007알아볼\u0007것이다. 062 불대수의 기본 공식 •\u0007\u0007\u0007카르노\u0007맵은\u0007변수(입력선)의\u0007개수에\u0007따라\u0007표의\u0007크기가\u0007 • 교환법칙 :\u0007A+B\u0007=\u0007B+A,\u0007A·B\u0007=\u0007B·A 달라지며\u0007칸의\u0007위치에\u0007따라서\u0007각\u0007칸의\u0007불\u0007함수가\u0007정해 진다. • 결합법칙 :\u0007A+(B+C)\u0007=\u0007(A+B)+C,\u0007A·(B·C)\u0007=\u0007(A·B)·C <변수가 두 개일 때> • 분배법칙 :\u0007\u0007A·(B+C)\u0007=\u0007A·B+A·C,\u0007 (cid:35) (cid:17) (cid:18) A+B·C\u0007=\u0007(A+B)·(A+C) (cid:34) (cid:9)(cid:35)(cid:10) (cid:9)(cid:35)(cid:10) • 멱등법칙 :\u0007A+A\u0007=\u0007A,\u0007A·A\u0007=\u0007A (cid:17)(cid:17)(cid:27)(cid:17) (cid:17)(cid:18)(cid:27)(cid:18) (cid:17)(cid:9)(cid:34)(cid:10) • 보수법칙 :\u0007A+A\u0007=\u00071,\u0007A·A\u0007=\u00070 (cid:9)(cid:34)(cid:35)(cid:10) (cid:9)(cid:34)(cid:35)(cid:10) • 항등법칙 :\u0007A+0\u0007=\u0007A,\u0007A+1\u0007=\u00071,\u0007A·0\u0007=\u00070,\u0007A·1\u0007=\u0007A (cid:18)(cid:17)(cid:27)(cid:19) (cid:18)(cid:18)(cid:27)(cid:20) (cid:18)(cid:9)(cid:34)(cid:10) (cid:9)(cid:34)(cid:35)(cid:10) (cid:9)(cid:34)(cid:35)(cid:10) • 드모르강 :\u0007A+B\u0007=\u0007(A·B),\u0007\u0007A·B\u0007\u0007=\u0007(A+B) • 복원법칙 :\u0007\u0007A\u0007=\u0007A\u0007 <변수가 세 개일 때> (cid:35)(cid:36)(cid:1) (cid:17)(cid:17) (cid:17)(cid:18) (cid:18)(cid:18) (cid:18)(cid:17) (cid:34) (cid:9)(cid:35)(cid:36)(cid:10) (cid:9)(cid:35)(cid:36)(cid:10) (cid:9)(cid:35)(cid:36)(cid:10) (cid:9)(cid:35)(cid:36)(cid:10) 핵심 12.8, 12.5, 11.8, 11.3, 10.5, 10.3, 08.9, 08.5, 02.5, 99.4 063 논리식의 간소화 (cid:17)(cid:17)(cid:17)(cid:27)(cid:17) (cid:17)(cid:17)(cid:18)(cid:27)(cid:18) (cid:17)(cid:18)(cid:18)(cid:27)(cid:20) (cid:17)(cid:18)(cid:17)(cid:27)(cid:19) (cid:34)(cid:1495)(cid:1)(cid:18)(cid:13)(cid:1)(cid:35)(cid:1495)(cid:1)(cid:17)(cid:13)(cid:1)(cid:36)(cid:1495)(cid:1)(cid:17)(cid:2633)(cid:1970)(cid:1789)(cid:1) (cid:17)(cid:9)(cid:34)(cid:10) A(cid:18)(cid:17)는(cid:17)(cid:2633) (cid:1)1(cid:1595),(cid:1518) B(cid:15)는 0, C는 (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) 불 대수의 기본 공식 이용하기 0(cid:18)(cid:2615)이(cid:1)(cid:2869)므(cid:13)(cid:1)(cid:17)로(cid:2615) (cid:1)1(cid:1122)0(cid:2777)0(cid:2633)이(cid:1970)된(cid:1789)다(cid:1) . 1(cid:34)은(cid:35)(cid:36) (cid:1086)참(cid:1)(cid:1595), (cid:1518)0(cid:15)은 거짓이 (cid:18)(cid:17)(cid:17)(cid:27)(cid:21) (cid:18)(cid:17)(cid:18)(cid:27)(cid:22) (cid:18)(cid:18)(cid:18)(cid:27)(cid:24) (cid:18)(cid:18)(cid:17)(cid:27)(cid:23) ❶\u0007\u0007합의\u0007곱((A+B)(C+D))\u0007표현을\u0007곱의\u0007합(AC+AD+\u0007 (cid:18)(cid:9)(cid:34)(cid:10) 므로 ABC가 된다. (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) (cid:9)(cid:34)(cid:35)(cid:36)(cid:10) BC+BD)\u0007표현으로\u0007변환한다. ¬  다 음과 같이 표시된 카르노 도를 간략화하시오. ❷\u0007공통\u0007인수를\u0007뽑아\u0007묶는다. ❸\u0007\u0007멱등법칙,\u0007보수법칙,\u0007항등법칙\u0007등의\u0007기본\u0007공식\u0007형태로\u0007 유도하여\u0007줄여\u0007나간다. 26 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 24] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 (가) (cid:35) (나) (cid:35)(cid:36) 묶음은\u0007변수\u0007A에\u0007대해서는\u00070에만\u0007속하므로\u0007A,\u0007변수\u0007 (cid:34) (cid:17) (cid:18) (cid:34) (cid:17)(cid:17) (cid:17)(cid:18) (cid:18)(cid:18) (cid:18)(cid:17) ß B에\u0007대해서도\u00070에만\u0007속하므로\u0007B,\u0007변수\u0007C에\u0007대해서 ß (cid:17) (cid:18) (cid:18) (cid:17) (cid:18) (cid:18) (cid:18) 는\u00070,\u00071\u0007모두에\u0007속하므로\u0007무시한다.\u0007그러므로\u0007➎번\u0007 (cid:18) (cid:18) (cid:18) (cid:18) (cid:18) (cid:18) 묶음은\u0007A·B이다.\u0007결과는\u0007➌``+``➍``+``➎이므로\u0007 ß ß i C`+``AB``+``A\u0007\u0007\u0007B가\u0007된다. ❶\u0007\u00071\u0007이\u0007입력되어\u0007이웃하는\u0007칸을\u0007최대\u00072(1,\u00072,\u00074,\u00078,\u000716\u0007…) ß ß ß 개로\u0007묶는다.\u0007한번\u0007묶인\u0007칸이\u0007다른\u0007묶음에\u0007또\u0007묶여도\u0007 된다.\u00071묶음에\u0007묶여지는\u0007칸이\u0007많을수록,\u0007그리고\u0007묶음의\u0007 핵심 06.5, 06.3, 05.9, 04.5, 99.8 개수가\u0007적을수록\u0007간소화된다.\u0007 064 논리 게이트 (가) 게이트 기호 의미 진리표 논리식 (cid:35) (cid:34) (cid:17) (cid:18) (cid:34)(cid:34) 입력신호가\u0007 (cid:34) (cid:17)(cid:34) (cid:17)(cid:34) (cid:35) (cid:17)(cid:35) (cid:17)(cid:35) (cid:17)(cid:58) (cid:17)(cid:58) (cid:58) Y\u0007=\u0007A·B ( ※ ❷ ((cid:34)나 가 ) (cid:35) \u0007 ((cid:17) 를(cid:18) \u0007묶\u0007 )(cid:17) 한 다 속 는나(cid:36)(cid:18) \u0007➊\u0007\u0007 로 ) 여 \u0007 른 해 \u0007한의 것(cid:8342) 개(cid:35) 번(cid:17) \u0007(cid:18) (cid:18) 진(cid:18) (cid:18) \u0007 \u0007 무(cid:17) 묶 이➌ 있묶의 \u0007\u0007 묶 시음(cid:36) 번 므는음묶 \u0007(cid:17)(cid:18) 으(cid:8346) 음 하묶 (cid:18) 로(cid:18) \u0007과음묶 변로 이 고음(cid:8344) \u0007음 는을(cid:8343) 무 수 \u0007묶 ,에(cid:18) 은(cid:18) \u0007변\u0007\u0007(cid:18) 시 변는O은 한 \u0007 수앞 속 R 한 수\u0007\u0007것 0(cid:18) \u0007의 \u0007개(cid:18)(cid:18) (cid:18)(cid:17) 하(cid:18) 다 \u0007연 A과이 B 로 에는두 .산 \u0007다 에1(cid:8345) \u0007 \u0007\u0007 \u0007. 시개 \u0007대간 아변 대와 킨 해주 무수➎ 당 해 된 해 다되번 다당 서맨 하 거들 서고 . 된 .묶 는고 나은 다 \u0007뒤 는C음 묶.에 \u0007 \u0007의 \u0007이 \u0007 \u0007A 0는 입불 음 0A 에 , B 에\u0007두0 N는에 력\u0007 이 1과 함 \u0007는 만 D0 되 모개 \u00071 만 \u0007 0수0 \u0007모 를 어 두만 연 해과해두 를 도당해 에 에산 당\u0007합 \u0007 1 에 \u0007 \u0007읽 시쳐 되속상 \u0007는 키 는네 하관모다 고 데 므없두개 . , ,\u0007 \u0007 \u0007\u0007 A O N B N N XU ON O A OR FD RNT RFE DR (cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:35)(cid:35) (cid:35) (cid:35) (cid:35)(cid:35)(cid:35) (cid:35) (cid:35)(cid:35) (cid:35)(cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:35)(cid:35) (cid:35) (cid:35)(cid:35) (cid:35)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:35) (cid:35) (cid:35)(cid:35) (cid:35) (cid:35) (cid:35) (cid:35)(cid:35) (cid:35) (cid:35) (cid:35) (cid:35)(cid:35) (cid:35) (cid:35) (cid:35) (cid:35)(cid:35)(cid:35) (cid:35) (cid:35) (cid:35) (cid:35)(cid:35)(cid:35) (cid:35) (cid:35)(cid:35) (cid:35)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34) (cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58)(cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58)(cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58)(cid:58) (cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58) (cid:58) (cid:58)(cid:58)(cid:58) (cid:58) (cid:58)(cid:58)(cid:58) 모 출 입 1 도 입 를 환 입 를 출 N 즉 부 N 즉 부 입 이 면 도 출 N개 O O O력 \u0007 하 \u0007 \u0007 력\u0007 정두 력 력 \u0007 력 \u0007 력 \u0007 정 력 \u0007반 A만 1 그 O 0모T T T\u0007 다된 여 ,N\u0007 신 된출 R \u0007되\u0007 \u0007 \u0007대\u00071 대 두+ ++ 한D일 1 의 르\u0007 \u0007 \u0007호 이 력 \u0007 \u0007는정 로 출 \u0007의정 로 \u0007A X\u0007O\u0007 \u0007 면개같\u0007 어때 ON보 \u0007 력 \u0007\u0007보중 \u0007 R변 \u0007 라것 으 R\u0007D\u0007 ,\u00071 \u0007 1 ,,\u0007 \u0007 \u0007\u0007 (cid:34)(cid:34) (cid:34) (cid:34)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17) (cid:17) (cid:17) (cid:34)(cid:34)(cid:34)(cid:34) (cid:34) (cid:34)(cid:34)(cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34)(cid:17) (cid:18)(cid:18) (cid:18) (cid:18) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:34) (cid:34) (cid:34)(cid:34)(cid:34)(cid:34)(cid:34)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:17)(cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17) (cid:18) (cid:34) (cid:34) (cid:34)(cid:34)(cid:34)(cid:34) (cid:34) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:34)(cid:17) (cid:17)(cid:17) (cid:17) (cid:34) (cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34)(cid:34) (cid:34) (cid:34) (cid:34) (cid:34)(cid:18) (cid:18) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17)(cid:17) (cid:17) (cid:17)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18) (cid:18)(cid:18)(cid:17)(cid:17) (cid:17) (cid:17)(cid:35)(cid:35) (cid:35) (cid:35)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:35)(cid:35)(cid:35)(cid:35) (cid:35) (cid:35)(cid:35)(cid:35)(cid:35) (cid:35)(cid:35) (cid:35)(cid:35) (cid:35)(cid:35) (cid:35) (cid:35) (cid:35) (cid:35) (cid:35)(cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17)(cid:58) (cid:58) (cid:17)(cid:58) (cid:58) (cid:17) (cid:17)(cid:58) (cid:58) (cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17) (cid:17)(cid:58) (cid:58) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:35)(cid:35)(cid:35)(cid:35)(cid:35) (cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18) (cid:18) (cid:18) (cid:58) (cid:58) (cid:17)(cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:35)(cid:35)(cid:35)(cid:35) (cid:35)(cid:58) (cid:58) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:17) (cid:17)(cid:35)(cid:17) (cid:17) (cid:35) (cid:35)(cid:35) (cid:35)(cid:35) (cid:35)(cid:35) (cid:35)(cid:35) (cid:35) (cid:58) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:58) (cid:58) (cid:58) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17) (cid:17)(cid:17)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18) (cid:18)(cid:18)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17) (cid:58)(cid:58) (cid:58) (cid:58) (cid:17)(cid:17) (cid:17)(cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17)(cid:17)(cid:58)(cid:58)(cid:58)(cid:58) (cid:58) (cid:58)(cid:17)(cid:58)(cid:58)(cid:58) (cid:17)(cid:58) (cid:17)(cid:58) (cid:58)(cid:17)(cid:17) (cid:17)(cid:58) (cid:58)(cid:58) (cid:58) (cid:58) (cid:58) (cid:58) (cid:58)(cid:17) (cid:17) (cid:17)(cid:17)(cid:17)(cid:17) (cid:17)(cid:17)(cid:17) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:18)(cid:18) (cid:18) (cid:18) (cid:17)(cid:17)(cid:17) (cid:17)(cid:58)(cid:58)(cid:17)(cid:58)(cid:58)(cid:58) (cid:17)(cid:17) (cid:17)(cid:17)(cid:17) (cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:17)(cid:17)(cid:17) (cid:17)(cid:58)(cid:58)(cid:17)(cid:58)(cid:58) (cid:58) (cid:17)(cid:17) (cid:17)(cid:17) (cid:18)(cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18) (cid:18)(cid:18)(cid:18)(cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18)(cid:18) (cid:18) (cid:18)(cid:18)(cid:18)(cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17)(cid:58) (cid:17) (cid:17)(cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17)(cid:58) (cid:58)(cid:58) (cid:58)(cid:17) (cid:17)(cid:58) (cid:58)(cid:58) (cid:58)(cid:58) (cid:58) (cid:17) (cid:17)(cid:17) (cid:17) (cid:17) (cid:17)(cid:17) (cid:17)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) (cid:18) (cid:18)(cid:18) (cid:18)(cid:18) (cid:18) Y Y Y Y Y Y Y Y Y Y Y\u0007 \u0007 \u0007 \u0007 = = = = = = \u0007= = = = =A A A AA A\u0007 \u0007 \u0007 \u0007 \u0007A A · B + B⊕AA AB \u0007 \u0007B' ◉+ B B +\u0007 \u0007 BB AB 0은\u0007부정이므로\u0007➊번\u0007묶음은\u0007B가\u0007된다.\u0007➋번\u0007묶음은\u0007 XNOR (cid:35) (cid:58) 즉\u0007XOR의\u0007 (cid:17)(cid:18) (cid:18) (cid:17)(cid:18)(cid:18) (cid:17)(cid:17)(cid:18) Y\u0007=\u0007A\u0007⊕\u0007B ß 부정 (cid:18) (cid:18) (cid:18) Y\u0007=\u0007AB+A\u0007B 변수\u0007B에\u0007대해서는\u00070,\u00071\u0007모두에\u0007속하므로\u0007무시하고,\u0007 변수\u0007A에\u0007대해서는\u00070에만\u0007해당되므로\u0007➋번\u0007묶음은\u0007 A가\u0007된다.\u0007결과는\u0007➊\u0007+\u0007➋이므로\u0007A`\u0007+\u0007B가\u0007된다. ß ß ß (나)\u0007➌\u0007\u0007 번\u0007묶음이\u0007변수\u0007A에\u0007대해서는\u00070,\u00071에\u0007모두\u0007속하므 로\u0007무시하고,\u0007변수\u0007B에\u0007대해서도\u00070,\u00071에\u0007모두\u0007속하므 로\u0007무시한다.\u0007하지만\u0007변수\u0007C에\u0007대해서는\u00070에만\u0007속하 므로\u0007➌번\u0007묶음은\u0007C가\u0007된다.\u0007➍번\u0007묶음은\u0007변수\u0007A에\u0007 ß 대해서는\u00071에만\u0007속하므로\u0007A,\u0007변수\u0007B에\u0007대해서도\u00071에 만\u0007속하므로\u0007B,\u0007변수\u0007C에\u0007대해서는\u00070,\u00071\u0007모두에\u0007속하 므로\u0007무시한다.\u0007그러므로\u0007➍번\u0007묶음은\u0007AB이다.\u0007➎번\u0007 27 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 25] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.3, 13.3, 12.5, 08.3, 07.9, 07.5, 06.5, 05.5, 04.9, 03.8, 02.5, 02.3, 01.9, 01.6, 00.10, 00.3 논리식 065 논리회로의 이해 Carry\u0007=\u0007A·B\u0007\u0007\u0007Sum=\u0007A·B\u0007+\u0007A·B\u0007=\u0007A⊕`B \u0007다음 논리회로를 논리식으로 표현하시오. 논리회로 (cid:34) (cid:34) (cid:8342)(cid:1)(cid:1)(cid:1) (cid:52)(cid:86)(cid:78) (cid:35) (cid:8344)(cid:1)(cid:1)(cid:1) (cid:58) (cid:36)(cid:66)(cid:83)(cid:83)(cid:90) (cid:8343)(cid:1)(cid:1)(cid:1) (cid:35) 핵심 13.8, 13.3, 11.8, 05.3, 03.3, 01.3, 00.10, 00.7, 99.10 각각의\u0007논리\u0007게이트를\u0007분리하여\u0007논리식으로\u0007표현한\u0007후\u0007한\u0007개의\u0007논리 067 전가산기(FA; Full Adder) (cid:18) 식으로\u0007합쳐나간다.\u0007 (cid:34) (cid:17) (cid:52)(cid:86)(cid:78) ➊\u0007A·B 자(cid:35) 리올림\u0007수(C\u0007)를\u0007포함하여\u00071Bit\u0007크기의\u00072진수\u00073자리를\u0007더 ß (cid:18) i ➋\u0007A·B (cid:18) ß 하여\u0007합(Sum)과\u0007자 (cid:18)리올림\u0007수(Carry)를\u0007구하는\u0007회로이다. ➌\u0007➊\u0007+\u0007➋\u0007=\u0007\u0007A·B ß \u0007\u0007+\u0007\u0007\u0007 ßA·B\u0007\u0007=\u0007\u0007A\u0007\u0007⊕\u0007\u0007B (cid:18) (cid:36)(cid:66)(cid:83)(cid:83)(cid:90) (cid:34)그러므로\u0007위의\u0007논리회로는\u0007오른쪽과\u0007\u0007 (cid:34) 진리표 (cid:58) 같은\u0007XOR\u0007회로로\u0007간략하게\u0007표현할\u0007수\u0007있다. (cid:35) A B C Sum C i i+1 \u0007다음 논리식을 논리회로로 표현하시오. (cid:58) 0 0 0 0 0 A B+BC +(A+C) 0 0 1 1 0 (cid:35) AND\u0007연산에\u0007해당하는\u0007논리식을\u0007논리\u0007게이트로\u0007표현한\u0007후\u0007각각의\u0007출 0 1 0 1 0 력을\u0007OR\u0007게이트의\u0007입력으로\u0007표현한다. 0 1 1 0 1 ➊\u0007A·B ß(cid:34) (cid:34) 1 0 0 1 0 (cid:8342)➋\u0007B·C (cid:8344) ➌\u0007A(cid:35) \u0007+\u0007Cß (cid:36) 1 0 1 0 1 ➍ (cid:8342)\u0007➊(cid:34)\u0007\u0007+\u0007\u0007➋\u0007\u0007+\u0007\u0007➌ (cid:8344) (cid:34) 1 1 0 0 1 (cid:35) (cid:36) (cid:35)(cid:34) (cid:34)(cid:34) 1 1 1 1 1 (cid:8343)(cid:8342) (cid:8345)(cid:8344) (cid:36)(cid:35) (cid:36) (cid:35) 논리식 (cid:35) (cid:34) (cid:8343) (cid:35)(cid:36) (cid:8345) (cid:36) (cid:34)(cid:35) • 합계(Sum)\u0007=\u0007(A`⊕```B)\u0007⊕\u0007C\u0007 i (cid:34) (cid:8343) (cid:34)(cid:36) (cid:8345) • 자리올림(Carry)\u0007=\u0007(A`⊕```B)C\u0007+\u0007AB (cid:8342) (cid:8344) (cid:35)(cid:36) i (cid:35) (cid:36) (cid:36) 회로 전가산기는\u00072개의\u0007반가산기(HA)와\u00071개의\u0007OR\u0007Gate로\u0007 (cid:35) (cid:34) (cid:8343) 핵심(cid:8345) 12.8, 12.5, 08.5, 07.5, 05.3, 04.3 구성된다. (cid:36) 0 (cid:35)66 반가산기(HA; Half Adder) (cid:1992)(cid:1086)(cid:2193)(cid:1245) (cid:1992)(cid:1086)(cid:2193)(cid:1245) 1Bit짜(cid:36) 리\u00072진수\u00072개를\u0007덧셈한\u0007합(S)과\u0007자리올림\u0007수(C)를\u0007 (cid:34) 구하는\u0007회로이다. (cid:35) (cid:52)Sum (cid:36) 진리표 (cid:36)Carry A B Sum Carry 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 28 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 26] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.6, 08.7, 07.8, 06.8, 06.3, 05.8, 05.3, 04.8, 04.5 068 디코더(Decoder) •\u0007JK\u0007FF의\u0007두\u0007입력선을\u0007묶어서\u0007한\u0007개의\u0007입력선으로\u0007구성 한\u0007플립플롭 T •\u0007T=0인\u0007경우는\u0007변화가\u0007없고,\u0007T=1인\u0007경우에\u0007현재의\u0007상태 • n\u0007Bit의\u0007Code화된\u0007정보를\u0007그\u0007Code의\u0007각\u0007Bit\u0007조합에\u0007 를\u0007토글(Toggle)시킴.\u0007즉\u0007원\u0007상태와\u0007보수\u0007상태의\u00072가지\u0007 따라\u00072\u0007n개의\u0007출력으로\u0007번역하는\u0007회로이다. 상태로만\u0007서로\u0007전환됨 • 명령어의\u0007명령부나\u0007번지를\u0007해독할\u0007때\u0007사용하며,\u0007주로\u0007 •\u0007출력\u0007측의\u0007일부가\u0007입력\u0007측에\u0007궤환(FeedBack)되어\u0007유 마스터- 발되는\u0007레이스\u0007현상을\u0007없애기\u0007위해\u0007고안된\u0007플립플롭 AND\u0007게이트로\u0007구성된다. 슬레이브 •\u00072개의\u0007플립플롭으로\u0007구성되는\u0007데,\u0007한쪽\u0007회로가\u0007마스터 • 회로 (M/S) 이고\u0007다른\u0007한쪽이\u0007슬레이브의\u0007위치에\u0007있어\u0007마스터-슬 (cid:34) 레이브\u0007플립플롭이라\u0007함 (cid:37)(cid:17) (cid:35) (cid:37)(cid:18) 특성 표 <RS 플립플롭> <JK 플립플롭> (cid:37)(cid:19) S R Q 암기 J K Q 암기 (T+1) (T+1) (cid:37)(cid:20) \u00070\u0007 0\u0007 Q\u0007\u0007 무(상태\u0007변화\u0007없음) \u00070\u0007 0\u0007 Q\u0007\u0007 무(상태\u0007변화\u0007없음) (T) (T) \u00070\u0007 1\u0007 0\u0007 공(항상\u00070) \u00070\u0007 1\u0007 0\u0007 공(항상\u00070) \u0007 1\u0007 0\u0007 1\u0007 일(항상\u00071) \u00071\u0007 0\u0007 1\u0007 일(항상\u00071) 핵심 14.8, 14.5, 12.8, 12.3, 11.3, 10.5, 10.3, 08.9, 08.3, 06.5, 06.3, 05.5, 04.9, 03.5, 02.9, 02.5, 00.7, 99.4 069 플립플롭 \u0007 1\u0007 1\u0007 동작\u0007안됨\u0007\u0007불(불가) \u00071\u0007 1\u0007 보수\u0007 보(보수) • 플립플롭은\u0007전원이\u0007공급되고\u0007있는\u0007한,\u0007상태의\u0007변화를\u0007 <D 플립플롭> <T 플립플롭> 위한\u0007신호가\u0007발생할\u0007때까지\u0007현재의\u0007상태를\u0007그대로\u0007유지 D Q T Q (t+1) (t+1) 하는\u0007논리회로이다. 0 0 0 Q (t) • 플립플롭\u00071개가\u00071Bit를\u0007구성하는\u00072진\u0007셀(Binary\u0007Cell) 1 1 1 Q 이\u0007된다. (t) • 반도체\u0007기억장치에서\u00072진수\u00071자리값을\u0007기억하는\u0007메모 잠깐만요 ! JK\u0007플립플롭은\u0007J와\u0007K에\u0007모두\u00071이\u0007입력될\u0007때\u0007보수가\u0007출력 되는\u0007것이\u0007RS\u0007플립플롭과\u0007다릅니다. 리\u0007소자이다. • 플립플롭은\u0007레지스터를\u0007구성하는\u0007기본\u0007소자이다. • 기본적인\u0007플립플롭은\u00072개의\u0007NAND\u0007또는\u0007NOR\u0007게이트 핵심 11.6, 10.9, 08.3, 07.5, 01.9, 00.10 070 자료 구성의 단위 를\u0007이용하여\u0007구성한다. •자료(정보)\u0007표현의\u0007최소\u0007단위 플립플롭 특 징 비트(Bit, •2가지\u0007상태(0과\u00071)를\u0007표시하는\u00072진수\u00071자리 Binary Digit) 플립플롭의\u0007기본으로,\u0007S와\u0007R선의\u0007입력을\u0007조절하여\u0007임의 •nBit를\u0007이용하여\u00072\u0007n\u0007가지를\u0007표현할\u0007수\u0007있음 RS 의\u0007Bit\u0007값을\u0007그대로\u0007유지시키거나,\u0007무조건\u00070\u0007또는\u00071의\u0007값 •4개의\u0007비트(Bit)가\u0007모여\u00071개의\u0007Nibble을\u0007구성함\u0007 을\u0007기억시키기\u0007위해서\u0007사용\u0007 니블(Nibble) •\u00074비트로\u0007구성되며\u000716진수\u00071자리를\u0007표현하기에\u0007 •\u0007RS\u0007FF에서\u0007S\u0007=\u0007R\u0007=\u00071일\u0007때\u0007동작되지\u0007않는\u0007결점을\u0007보완 적합함\u0007 한\u0007플립플롭 •\u0007문자를\u0007표현하는\u0007최소\u0007단위로,\u00078개의\u0007비트(Bit)가\u0007 JK •\u0007RS\u0007FF의\u0007입력선\u0007S와\u0007R을\u0007JK\u0007FF의\u0007입력선\u0007J와\u0007K로\u0007사 모여\u00071Byte를\u0007구성함\u0007 용함 바이트(Byte) •1Byte는\u0007256(28)가지의\u0007정보를\u0007표현할\u0007수\u0007있음 •모든\u0007플립플롭의\u0007기능을\u0007포함함 •주소\u0007지정의\u0007단위로\u0007사용\u0007\u0007 •\u0007RS\u0007FF의\u0007R선에\u0007인버터(Inverter)를\u0007추가하여\u0007S선과\u0007 •CPU가\u0007한\u0007번에\u0007처리할\u0007수\u0007있는\u0007명령\u0007단위 D 하나로\u0007묶어서\u0007입력선을\u0007하나만\u0007구성한\u0007플립플롭 •반워드(Half Word)\u0007:\u00072Byte •입력하는\u0007값을\u0007그대로\u0007저장하는\u0007기능을\u0007수행함 워드(Word) •풀워드(Full Word) :\u00074Byte •\u0007더블워드(Double Word)\u0007:\u00078Byte\u0007 •파일\u0007구성의\u0007최소\u0007단위 필드(Field) •의미\u0007있는\u0007정보를\u0007표현하는\u0007최소\u0007단위\u0007\u0007 29 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 27] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •하나\u0007이상의\u0007관련된\u0007필드가\u0007모여서\u0007구성됨 2진수, 8진수, 16진수를 10진수로 변환 레코드(Record) •\u0007컴퓨터\u0007내부의\u0007자료\u0007처리\u0007단위로서,\u0007일반적으로\u0007 정수\u0007부분과\u0007소수\u0007부분의\u0007각\u0007자리를\u0007분리하여\u0007변환하려 레코드는\u0007논리\u0007레코드(Logical\u0007Record)를\u0007의미함\u0007 는\u0007각\u0007진수의\u0007자리값과\u0007자리의\u0007지수\u0007승을\u0007곱한\u0007결과값을\u0007 블록(Block) •하나\u0007이상의\u0007논리\u0007레코드가\u0007모여서\u0007구성됨 모두\u0007더하여\u0007계산한다. = 물리 레코드 •\u0007각종\u0007저장\u0007매체와의\u0007입·출력\u0007단위를\u0007의미하며,\u0007 (Physical \u0007(101111.101)를\u000710진수로\u0007변환하기 일반적으로\u0007물리\u0007레코드(Physical\u0007Record)라고\u0007함\u0007 2 Record) \u0007\u0007\u0007\u0007(\u0007\u00071\u0007\u0007\u0007\u0007\u0007\u0007\u0007`0\u0007\u0007\u0007\u0007\u0007\u0007\u0007``1\u0007\u0007\u0007\u0007\u0007\u0007\u0007```\u00071\u0007\u0007\u0007\u0007\u0007\u0007````1\u0007\u0007\u0007\u0007\u0007\u0007\u00071\u0007\u0007.\u0007\u0007\u0007\u0007``\u00071\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u00070\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007``1\u0007) 2 프로그램\u0007구성의\u0007기본\u0007단위로,\u0007여러\u0007레코드가\u0007모 파일(File) \u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007``\u0007×\u0007\u0007\u0007\u0007\u0007``\u0007`×\u0007\u0007\u0007\u0007\u0007\u0007\u0007``×\u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007 여서\u0007구성됨 =\u0007\u0007\u000725\u0007\u0007\u0007\u0007\u0007\u0007\u000724\u0007\u0007\u0007\u0007\u0007\u0007\u000723\u0007\u0007\u0007\u0007\u0007\u0007\u000722\u0007\u0007\u0007\u0007\u0007\u000721\u0007\u0007\u0007\u0007\u0007\u000720\u0007.\u0007\u0007\u0007\u0007\u00072-1\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u00072-2\u0007\u0007\u0007\u0007\u0007\u0007\u00072-3\u0007 데이터베이스 여러\u0007개의\u0007관련된\u0007파일(File)의\u0007집합 =\u0007\u000732\u0007\u0007+\u0007\u00070\u0007\u0007\u0007+\u0007\u0007``8\u0007\u0007\u0007\u0007+\u0007\u0007\u0007``4\u0007\u0007\u0007`+\u0007\u0007`2\u0007\u0007\u0007+\u0007\u00071\u0007\u0007.\u0007\u0007\u0007\u0007\u00070.5\u0007\u0007``+\u0007\u0007\u0007``0\u0007\u0007\u0007+\u0007\u00070.125 (Database) =\u0007\u000747.625 \u0007(57.5)를\u000710진수로\u0007변환하기 8 핵심 14.3, 10.3, 07.9, 04.3, 99.8 071 진법 변환 \u0007\u0007\u0007\u0007\u0007\u0007(5\u0007\u0007\u0007\u0007\u0007\u0007\u0007`\u00077\u0007\u0007\u0007\u0007.\u0007\u0007\u0007`5) 8 \u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007\u0007× 10진수를 2진수, 8진수, 16진수로 변환 \u0007\u0007\u0007=\u0007\u000781\u0007\u0007\u0007\u0007\u0007```\u000780\u0007\u0007\u0007.\u0007\u0007\u00078-1 •정 수 부분 :\u000710진수의\u0007값을\u0007변환할\u0007진수로\u0007나누어\u0007더\u0007이 \u0007\u0007\u0007=\u0007\u000740\u0007\u0007\u0007+\u0007\u0007\u00077\u0007\u0007\u0007\u0007\u0007.\u0007\u00070.625 상\u0007나눠지지\u0007않을\u0007때까지\u0007나누고,\u0007나머지를\u0007역순으로\u0007 \u0007\u0007\u0007=\u0007\u000747.625 표시함 \u0007(4F.2) 를\u000710진수로\u0007변환하기 16 •소 수 부분 :\u000710진수의\u0007값에\u0007변환할\u0007진수를\u0007곱한\u0007후\u0007결과 \u0007\u0007\u0007\u0007\u0007\u0007(\u00074\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007F\u0007\u0007\u0007\u0007\u0007.\u0007\u0007\u0007\u0007\u0007\u0007\u00072\u0007\u0007) 의\u0007정수\u0007부분만을\u0007차례대로\u0007표기하되,\u0007소수\u0007부분이\u00070\u0007 16 \u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007\u0007×\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007× 또는\u0007반복되는\u0007수가\u0007나올\u0007때까지\u0007곱하기를\u0007반복함 \u0007\u0007\u0007=\u0007\u0007161\u0007\u0007+\u0007\u0007160\u0007\u0007\u0007\u0007\u0007.\u0007\u0007\u0007\u0007\u0007\u000716-1 \u0007\u0007\u0007\u0007(47.625) 를\u00072진수,\u00078진수,\u000716진수로\u0007변환하기 10 \u0007\u0007\u0007=\u0007\u000764\u0007\u0007\u0007+\u0007\u000715\u0007\u0007\u0007```\u0007\u0007.\u0007\u0007\u0007\u0007\u00070.125\u0007 \u0007\u0007\u0007=\u0007\u000779.125 <정수 부분> 2진수, 8진수, 16진수 상호 변환 2진수 8진수 16진수 •2 진수를 8진수로 :\u0007정수\u0007부분은\u0007소수점을\u0007기준으로\u0007왼\u0007\u0007 쪽\u0007방향으로\u00073자리씩,\u0007소수\u0007부분은\u0007소수점을\u0007기준으로\u0007 2 47 2 23 … 1 오른쪽\u0007방향으로\u00073자리씩\u0007묶어서\u0007변환함 2 11 … 1 8 47 16 47 •2 진수를 16진수로 :\u0007정수\u0007부분은\u0007소수점을\u0007기준으로\u0007왼쪽\u0007\u0007 2 5 … 1 5 … 7 2 … 15(F) 방향으로\u00074자리씩,\u0007소수\u0007부분은\u0007소수점을\u0007기준으로\u0007오 2 2 … 1 른쪽\u0007방향으로\u00074자리씩\u0007묶어서\u0007변환함 1 … 0 •8 진수, 16진수를 2진수로 :\u00078진수\u00071자리는\u00072진수\u00073비트로,\u0007 (47) = (101111) (47) = (57) (47) = (2F) 16진수\u00071자리는\u00072진수\u00074비트로\u0007풀어서\u0007변환함 10 2 10 8 10 16 •8 진수를 16진수로 :\u00078진수를\u00072진수로\u0007변환한\u0007뒤\u00072진수 <소수 부분> 를\u000716진수로\u0007변환함 • 1 6진수를 8진수로 :\u000716진수를\u00072진수로\u0007변환한\u0007뒤\u00072진 2진수 8진수 16진수 수를\u00078진수로\u0007변환함 0.625 0.250 0.5 0.625 0.625 × 2 × 2 × 2 × 8 × 16 1.250 0.5 1.0 5.000 10(A).000 (0.625) = (0.101) (0.625) = (0.5) (0.625) = (0.A) 10 2 10 8 10 16 (47.625) → (101111.101) (47.625) → (57.5) (47.625) → (2F.A) 10 2 10 8 10 16 30 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 28] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.8, 07.9, 05.4, 03.5, 03.3 부호화\u00072의\u0007보수법 072 보수 양수\u0007표현에\u0007대하여\u0007 한\u0007가지\u0007형태의\u00070만\u0007 (Signed\u00072's\u0007 2의\u0007보수를\u0007취함 존재(+0) Complement) 컴퓨터가\u0007기본적으로\u0007수행하는\u0007덧셈\u0007회로를\u0007이용하여\u0007뺄 셈을\u0007수행하기\u0007위해\u0007사용한다. 표현 범위 •\u000710진법에는\u000710의\u0007보수가\u0007있고,\u00072진법에는\u00072의\u0007보수 종 류 범 위 n=8 n=16 n=32 가\u0007있음 부호화\u0007 •\u0007보수를\u0007구할\u0007숫자의\u0007자릿수만큼\u00070을\u0007채우고\u0007가장\u0007 왼쪽에\u00071을\u0007추가하여\u0007기준을\u0007만듦 절대치법 -2n-1+1\u0007~\u0007 -32767\u0007~\u0007 -231+1\u0007~\u0007 r의 보수 \u0007\u0007\u000733의\u000710의\u0007보수는?\u0007\u0007\u0007 부호화\u00071의\u0007 +2n-1-1 -127\u0007~\u0007+127 +32767 +231-1 \u0007\u0007\u0007\u0007\u0007\u000733\u0007+\u0007X\u0007=\u0007100\u0007→\u0007X\u0007=\u0007100\u0007-\u000733\u0007→\u0007X\u0007=\u000767 보수법 \u0007\u0007\u000710101의\u00072의\u0007보수는? 부호화\u00072의\u0007 -2n-1\u0007~\u0007 -32768\u0007~\u0007 -231\u0007~\u0007 -128\u0007~\u0007+127 \u0007\u0007\u0007\u0007\u0007\u0007\u000710101\u0007+\u0007X\u0007=\u0007100000\u0007→\u0007X\u0007=\u0007100000\u0007-\u000710101\u0007→\u0007X 보수법 +2n-1-1 +32767 +231-1 \u0007\u0007\u0007\u0007\u0007\u0007=\u000701011 •\u000710진법에는\u00079의\u0007보수가\u0007있고,\u00072진법에는\u00071의\u0007보수가\u0007 잠깐만요 ! 2의 보수 표현법이 널리 사용되는 이유\u0007 •\u00072의\u0007보수\u0007표현법은\u00071의\u0007보수\u0007표현법에\u0007비해\u0007음수\u0007표현\u0007시\u0007숫자\u00071개 있음 를\u0007더\u0007표현할\u0007수\u0007있습니다. •\u000710진수\u0007N에\u0007대한\u00079의\u0007보수는\u0007주어진\u0007숫자의\u0007자릿수\u0007 만큼\u00079를\u0007채워\u0007기준을\u0007만듦 •\u00072의\u0007보수\u0007표현법에서는\u0007연산\u0007시\u0007자리올림(Carry)이\u0007발생하면\u0007무시 \u0007\u0007\u000733의\u00079의\u0007보수는?\u0007\u0007 하므로\u00071의\u0007보수\u0007표현에\u0007비해\u0007연산이\u0007간단합니다. r-1의 보수 \u0007\u0007\u0007\u0007\u0007\u0007\u000733\u0007+\u0007X\u0007=\u000799\u0007→\u0007X\u0007=\u000799\u0007-\u000733\u0007→\u0007X\u0007=\u000766 •\u00072의\u0007보수\u0007표현법에서는\u00070이\u0007하나만\u0007존재하므로\u00070의\u0007판단이\u0007쉽습니다. •\u00072진수\u0007N에\u0007대한\u00071의\u0007보수는\u0007주어진\u0007숫자의\u0007자릿수\u0007 만큼\u00071을\u0007채워\u0007기준을\u0007만듦 \u0007\u0007\u000710101의\u00071의\u0007보수는?\u0007\u0007 핵심 14.5, 11.8, 09.5, 09.3, 08.9, 07.3, 05.4 \u0007\u0007\u0007\u0007\u000710101\u0007+\u0007X\u0007=\u000711111\u0007→\u0007X\u0007=\u000711111\u0007-\u000710101\u0007→\u0007X\u0007 074 부동 소수점 표현 \u0007\u0007\u0007\u0007\u0007\u0007\u0007=\u000701010 부동\u0007소수점\u0007방식은\u0007소수점이\u0007포함된\u0007실수\u0007데이터의\u0007표 현과\u0007연산에\u0007사용하는\u0007방식이다. 핵심 13.8, 13.6, 13.3, 12.3, 11.8, 11.3, 10.9, 10.3, 09.8, 06.9, 05.9, 03.8 073 2진 연산 부동 소수점 방식의 특징 • 고정\u0007소수점\u0007방식으로\u0007표현하는\u0007것보다\u0007매우\u0007큰\u0007수나\u0007작 • 정수값을\u00072진수로\u0007변환하여\u0007표현하는\u0007방식이다. 은\u0007수,\u0007매우\u0007정밀한\u0007수를\u0007적은\u0007비트로\u0007표현할\u0007수\u0007있다. •표현할\u0007수\u0007있는\u0007범위는\u0007작지만\u0007연산\u0007속도가\u0007빠르다. • 과학이나\u0007공학\u0007또는\u0007수학적인\u0007응용에\u0007주로\u0007사용된다. •n \u0007Bit\u0007크기의\u0007워드가\u0007있을\u0007때\u0007맨\u0007처음\u00071\u0007Bit는\u0007부호 • 고정\u0007소수점\u0007방식에\u0007비해\u0007연산\u0007시간이\u0007많이\u0007걸린다. (Sign)\u0007비트로\u0007사용되고\u0007나머지\u0007n-1\u0007Bit에\u00072진수로\u0007표 • 지수부와\u0007가수부를\u0007분리하는\u0007정규화\u0007과정이\u0007필요하다. 현된\u0007정수값이\u0007저장된다. • 4Byte를\u0007사용하는\u0007단정도와\u0007가수부를\u00074Byte\u0007추가하여\u0007 •양 수 :\u0007부호\u0007비트에\u00070을\u0007넣고,\u0007변환된\u00072진수\u0007값을\u0007Data\u0007 좀\u0007더\u0007정밀하게\u0007표현할\u0007수\u0007있는\u00078Byte\u0007배정도\u0007표현법 Bit의\u0007오른쪽에서\u0007왼쪽\u0007순으로\u0007차례로\u0007채우고\u0007남는\u0007자 이\u0007있다. 리에\u00070을\u0007채움 • 표현 범위 :\u0007±16-64~±1663 •음 수 :\u0007음수를\u0007표현할\u0007때는\u0007다음과\u0007같은\u00073가지\u0007방법을\u0007 사용함 0\u0007\u0007\u0007\u0007\u0007\u0007\u00071\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u00077\u00078\u0007\u0007\u0007\u0007\u0007\u0007 31Bit 부호\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007지수부\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007가수부 종 류 표현 방법 비 고 양수\u0007표현에\u0007대하여\u0007 부동 소수점 수의 연산 방법 부호화\u0007절대치법 부호\u0007Bit의\u0007값만\u00070을\u0007 (Signed\u0007Magnitude) • 덧셈,\u0007뺄셈 1로\u0007바꿈 두\u0007가지\u0007형태의\u00070\u0007 존재(+0,\u0007-0)\u0007 ➊\u0007\u00070인지의\u0007여부를\u0007조사한다. 부호화\u00071의\u0007보수법 양수\u0007표현에\u0007대하여\u0007 (Signed\u00071's\u0007 1의\u0007보수를\u0007취함 ➋\u0007\u0007가수의\u0007위치\u0007조정\u0007:\u0007두\u0007자료의\u0007지수를\u0007비교한\u0007후\u0007소 Complement) 수점의\u0007위치를\u0007이동하여\u0007지수가\u0007큰\u0007쪽에\u0007맞춘다. 31 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 29] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 ➌\u0007가수부\u0007값끼리\u0007더하거나\u0007뺀다.\u0007 •\u0007해밍\u0007코드\u0007중\u0007\u00071,\u00072,\u00074,\u00078,\u000716\u0007……\u00072\u0007n\u0007번째\u0007비트는\u0007오 해밍 코드 류\u0007검출을\u0007위한\u0007패리티\u0007비트임 ➍\u0007결과를\u0007정규화한다. • 곱셈 잠깐만요 ! 오류 검출용 코드 해밍\u0007코드,\u0007패리티\u0007검사\u0007코드,\u0007Biquinary,\u0007Ring-Counter,\u00072-out-of-5,\u0007 ➊\u0007\u00070인지의\u0007여부를\u0007조사한다.\u0007 3-out-of-5 ➋\u0007\u0007지수를\u0007더한다.\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007 ➌\u0007가수를\u0007곱한다.\u0007 핵심 13.8, 12.3, 08.5, 08.3 ➍\u0007결과를\u0007정규화한다. 076 해밍 코드의 오류 검출 • 나눗셈 n • 해밍\u0007코드\u0007중\u0007\u00071,\u00072,\u00074,\u00078,\u000716\u0007……\u00072\u0007 \u0007번째\u0007비트는\u0007오류\u0007 ➊\u0007\u00070인지의\u0007여부를\u0007조사한다.\u0007\u0007 검출을\u0007위한\u0007패리티\u0007비트이다. ➋\u0007\u0007부호를\u0007결정한다. • n번\u0007째의\u0007패리티\u0007비트는\u0007n번째\u0007비트에서\u0007시작하여\u0007n개 ➌\u0007피제수가\u0007제수보다\u0007작게\u0007피제수의\u0007위치를\u0007조정한다. 의\u0007비트를\u0007포함하고,\u0007n개의\u0007비트를\u0007건너뛴\u0007비트들을\u0007대 ➍\u0007지수의\u0007뺄셈을\u0007한다.\u0007\u0007 상으로\u0007패리티\u0007비트를\u0007결정한다. ➎\u0007가수의\u0007나눗셈을\u0007한다. \u0007다음은\u0007해밍\u0007코드로\u0007구성된\u0007데이터이다.\u0007패리티\u0007비트 를\u0007표시하시오. 패리티\u0007비트 \u0007 1\u0007\u0007\u00070\u0007\u0007\u00071\u0007\u0007\u00071\u0007\u0007\u00070\u0007\u0007\u00071\u0007\u0007\u00071 핵심 14.3, 11.6, 03.5, 02.3, 01.9, 99.10 075 자료 표현 코드 \u0007BCD\u0007코드\u00071011에\u0007대한\u0007해밍\u0007코드를\u0007구하시오(짝수\u0007 패리티\u0007이용). •10진수\u00071자리의\u0007수를\u00072진수\u00074Bit로\u0007표현함 ➊\u00074비트\u0007이므로\u0007패리티\u0007비트가\u0007들어갈\u0007자리인\u00071,\u00072,\u00074번\u0007 •\u00074Bit의\u00072진수\u0007각\u0007Bit가\u00078(2\u00073),\u00074(2\u00072),\u00072(2\u00071),\u00071(2\u00070)의\u0007자리 값을\u0007가지므로\u00078421\u0007코드라고도\u0007함 째\u0007자리를\u0007비운\u0007나머지\u0007자리에\u00074비트를\u0007적는다. BCD 코드 •\u0007대표적인\u0007가중치\u0007코드 1 2 3 4 5 6 7 •\u0007문자\u0007코드인\u0007BCD에서\u0007Zone\u0007부분을\u0007생략한\u0007형태임 •\u000710진수\u0007입·출력이\u0007간편함\u0007 H H 1 H 0 1 1 Excess-3 •\u0007BCD\u0007+\u00073,\u0007즉\u0007BCD\u0007코드에\u00073을\u0007더하여\u0007만든\u0007코드임 ➋\u00071번\u0007비트는\u00073,\u00075,\u00077번\u0007비트를\u0007이용하여\u00071인\u0007비트의\u0007수 코드 •\u0007대표적인\u0007자보수\u0007코드이며,\u0007비가중치\u0007코드임 (3초과 코드) 가\u0007짝수가\u0007되도록\u0007한다. •\u0007BCD\u0007코드의\u0007인접하는\u0007비트를\u0007X-OR\u0007연산하여\u0007만 1 2 3 4 5 6 7 든\u0007코드 0 H 1 H 0 1 1 •\u0007입·출력장치,\u0007A/D\u0007변환기,\u0007주변장치\u0007등에서\u0007숫자 Gray 코드 를\u0007표현할\u0007때\u0007사용 3, 5, 7번 비트의 1의 개수는 짝수이므로 1번 비트를 0으로 하여 1, 3, 5, 7 •\u00071Bit만\u0007변화시켜\u0007다음\u0007수치로\u0007증가시키기\u0007때문에\u0007 번 비트의 1의 개수가 짝수가 되게 한다. 하드웨어적인\u0007오류가\u0007적음 ➌\u00072번\u0007비트는\u00073,\u00076,\u00077번\u0007비트를\u0007이용하여\u00071인\u0007비트의\u0007수 •\u0007코드의\u0007오류를\u0007검사하기\u0007위해서\u0007데이터\u0007비트\u0007외에\u0007 가\u0007짝수가\u0007되도록\u0007한다. 1Bit의\u0007패리티\u0007체크\u0007비트를\u0007추가하는\u0007것으로\u00071Bit의\u0007 오류만\u0007검출할\u0007수\u0007있음\u0007 1 2 3 4 5 6 7 패리티 검사 • Odd Parity\u0007:\u0007코드에서\u00071인\u0007Bit의\u0007수가\u0007홀수가\u0007되 코드 0 1 1 H 0 1 1 도록\u00070이나\u00071을\u0007추가함 • Even Parity\u0007:\u0007코드에서\u00071인\u0007Bit의\u0007수가\u0007짝수가\u0007되 3, 6, 7번 비트의 1의 개수는 홀수이므로 2번 비트를 1로 하여 2, 3, 6, 7번 도록\u00070이나\u00071을\u0007추가함 비트의 1의 개수가 짝수가 되게 한다. •\u0007오류를\u0007스스로\u0007검출하여\u0007교정이\u0007가능한\u0007코드 ➍\u00074번\u0007비트는\u00075,\u00076,\u00077번\u0007비트를\u0007이용하여\u00071의\u0007비트의\u0007수 •\u00071Bit의\u0007오류만\u0007교정할\u0007수\u0007있음 해밍 코드 •\u0007데이터\u0007비트\u0007외에\u0007에러\u0007검출\u0007및\u0007교정을\u0007위한\u0007잉여\u0007 가\u0007짝수가\u0007되도록\u0007한다. 비트가\u0007많이\u0007필요함 32 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 30] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 1 2 3 4 5 6 7 핵심 14.8, 12.8, 12.5, 12.3, 11.6, 07.5, 07.3, 04.5, 04.3, 02.9, 02.5, 00.7, 00.3 078 중앙처리장치의 구성 요소 0 1 1 0 0 1 1 •\u0007컴퓨터에\u0007있는\u0007모든\u0007장치들의\u0007동작을\u0007지시하고\u0007제어하는\u0007 5, 6, 7 번 비트의 1의 개수는 짝수이므로 4번 비트를 0으로 하여 4, 5, 6, 장치 7번 비트의 1의 개수가 짝수가 되게 한다. •\u0007주기억장치에서\u0007읽어\u0007들인\u0007명령어를\u0007해독하여\u0007해당하는\u0007장 치에게\u0007제어\u0007신호를\u0007보내\u0007정확하게\u0007수행하도록\u0007지시함 잠깐만요 ! 오류 검출을 위한 패리티 비트 결정하는 방법\u0007 •\u0007제어장치의\u0007구성\u0007요소 n번\u0007패리티\u0007비트를\u0007결정하기\u0007위해서는\u0007n비트만큼을\u0007포함하고,\u0007n비트 -\u0007\u0007명령\u0007레지스터\u0007:\u0007현재\u0007실행중인\u0007명령어의\u0007내용을\u0007기억하 씩\u0007건너뛴\u0007비트들을\u0007대상으로\u0007패리티\u0007비트를\u0007결정합니다.\u0007즉\u00071번\u0007패 고\u0007있는\u0007레지스터 리티\u0007비트를\u0007결정하기\u0007위해서는\u00071비트만큼을\u0007포함하고\u00071비트씩\u0007건너 -\u0007\u0007명령\u0007해독기(Decoder)\u0007:\u0007명령\u0007레지스터에\u0007있는\u0007명령어를\u0007 뛴\u00071,\u00073,\u00075,\u00077,\u0007…\u0007비트가\u0007대상이\u0007됩니다.\u0007\u00072번\u0007비트를\u0007결정하기\u0007위해서 해독하는\u0007회로 는\u00072비트만큼을\u0007포함하고\u00072비트씩\u0007건너뛴\u00072,\u00073,\u00076,\u00077,\u000710,\u000711,\u0007…\u0007비트를\u0007 -\u0007\u0007제어신호\u0007발생기,\u0007부호기(Encoder)\u0007:\u0007해독된\u0007명령에\u0007따라\u0007 이용하고,\u00074번\u0007비트를\u0007결정하기\u0007위해서는\u00074비트만큼을\u0007포함하고\u00074비 각\u0007장치로\u0007보낼\u0007제어\u0007신호를\u0007생성하는\u0007회로 트씩\u0007건너뛴\u00074,\u00075,\u00076,\u00077,\u000712,\u000713,\u000714,\u000715,\u0007…\u0007비트를\u0007이용합니다. 제어 -\u0007\u0007제어\u0007주소\u0007레지스터(CAR)\u0007:\u0007다음에\u0007실행할\u0007마이크로\u0007명령 장치 어의\u0007주소를\u0007저장하는\u0007레지스터로,\u0007Mapping의\u0007결과값,\u0007 주소\u0007필드,\u0007서브루틴\u0007레지스터의\u0007내용들이\u0007적재되어\u0007있음 -\u0007\u0007제어\u0007버퍼\u0007레지스터(CBR)\u0007:\u0007제어\u0007기억장치로부터\u0007읽혀진\u0007 핵심 07.9, 05.5, 05.3, 03.8 077 그레이 코드 변환 마이크로\u0007명령어\u0007비트들을\u0007일시적으로\u0007저장하는\u0007레지스터 -\u0007\u0007제어\u0007기억장치\u0007:\u0007마이크로\u0007명령어들로\u0007이루어진\u0007마이크로 프로그램을\u0007저장하는\u0007내부\u0007기억장치 2진수를 Gray Code로 변환하는 방법 -\u0007\u0007순서\u0007제어\u0007모듈\u0007:\u0007마이크로\u0007명령어의\u0007실행\u0007순서를\u0007결정하 ➊\u0007첫\u0007번째\u0007그레이\u0007비트는\u00072진수의\u0007첫\u0007번째\u0007비트를\u0007그대 는\u0007회로들의\u0007집합 -\u0007\u0007순차\u0007카운터(Sequence\u0007Counter)\u0007:\u0007디코더에\u0007의해\u0007선택된\u0007 로\u0007내려쓴다. 번호에\u0007해당하는\u0007타이밍\u0007신호를\u0007생성 ➋\u0007두\u0007번째\u0007그레이\u0007비트부터는\u0007변경할\u00072진수의\u0007해당\u0007번째\u0007 •\u0007제어장치에\u0007입력되는\u0007항목\u0007:\u0007명령어\u0007레지스터,\u0007플래그,\u0007클록 비트와\u0007그\u0007왼쪽의\u0007비트를\u0007XOR\u0007연산하여\u0007쓴다. •\u0007제어장치의\u0007명령에\u0007따라\u0007실제로\u0007연산을\u0007수행하는\u0007장치 •\u0007산술연산,\u0007논리연산,\u0007관계연산,\u0007이동(Shift)\u0007등의\u0007연산을\u0007수\u0007 \u0007\u0007\u0007\u0007\u0007\u00072진수\u00071001을\u0007Gray\u0007Code로\u0007변환하시오. 연산 행함 장치 •\u0007가산기,\u0007누산기(AC;\u0007Accumulator),\u0007보수기,\u0007데이터\u0007레지스 (cid:19)(cid:2771)(cid:2299) 터,\u0007오버플로\u0007검출기,\u0007Shift\u0007Register\u0007등으로\u0007구성되어\u0007\u0007 있음 \u0007\u0007\u0007\u0007\u0007\u0007\u0007 •\u0007CPU\u0007내부에서\u0007처리할\u0007명령어나\u0007연산의\u0007중간\u0007결과값\u0007등을\u0007 일시적으로\u0007기억하는\u0007임시\u0007기억장소 Gray Code를 2진수로 변환하는 방법 •\u0007플립플롭(Flip-Flop)이나\u0007래치(Latch)들을\u0007병렬로\u0007연결하여\u0007 구성함 ➊\u0007첫\u0007번째\u00072진수\u0007비트는\u0007그레이\u0007코드의\u0007첫\u0007번째\u0007비트를\u0007 •\u0007메모리\u0007중에서\u0007가장\u0007속도가\u0007빠름 그대로\u0007내려쓴다. •\u0007레지스터의\u0007크기는\u0007워드를\u0007구성하는\u0007비트\u0007개수만큼의\u0007플립 플롭으로\u0007구성되며,\u0007여러\u0007개의\u0007플립플롭은\u0007공통\u0007클록의\u0007입 ➋\u0007두\u0007번째\u00072진수\u0007비트부터는\u0007왼쪽에\u0007구해\u0007놓은\u00072진수\u0007비 력에\u0007의해\u0007동시에\u0007여러\u0007비트의\u0007자료가\u0007저장됨 트와\u0007변경할\u0007해당\u0007번째\u0007그레이\u0007비트를\u0007XOR\u0007연산하여\u0007 •\u0007레지스터를\u0007구성하는\u0007플립플롭은\u0007저장하는\u0007값을\u0007임의로\u0007설 레지 쓴다. 정하기\u0007위해\u0007별도의\u0007입력\u0007단자를\u0007추가할\u0007수\u0007있으며,\u0007저장값 스터 을\u00070으로\u0007하는\u0007것을\u0007설정해제(CLR)라\u0007함 \u0007\u0007\u0007\u0007\u0007\u0007Gray\u0007Code\u00071001을\u00072진수로\u0007변환하시오. •\u0007레지스터\u0007간의\u0007자료\u0007전송 (cid:1234)(cid:1768)(cid:2633)(cid:1)(cid:3023)(cid:1624) -\u0007\u0007직렬\u0007전송\u0007:\u0007직렬\u0007시프트\u0007마이크로\u0007오퍼레이션을\u0007뜻하며,\u0007 병렬\u0007전송에\u0007비해\u0007전송속도가\u0007느림 \u0007\u0007\u0007\u0007\u0007 -\u0007\u0007병렬\u0007전송\u0007:\u0007하나의\u0007클록\u0007펄스\u0007동안에\u0007레지스터\u0007내의\u0007모든\u0007 비트,\u0007즉\u0007워드가\u0007동시에\u0007전송되는\u0007전송\u0007방식 -\u0007\u0007버스\u0007전송\u0007:\u0007모든\u0007레지스터들이\u0007공통으로\u0007이용하는\u0007경로 로,\u0007병렬\u0007전송에\u0007비해\u0007결선의\u0007수를\u0007줄일\u0007수\u0007있다는\u0007장점 이\u0007있음 33 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 31] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.3, 13.6, 11.3, 10.5, 10.3, 09.8, 09.5, 07.9, 07.5, 06.5, 06.3, 05.4, 05.3, 03.8, 02.9, 02.5, 02.3, 01.9, 00.3 •버스의 종류 079 주요 레지스터 • 번지 버스(Address Bus) :\u0007CPU가\u0007메모리나\u0007 레지스터 기 능 입·출력\u0007기기의\u0007번지를\u0007지정할\u0007때\u0007사용하는\u0007 단방향\u0007전송선 •\u0007다음\u0007번에\u0007실행할\u0007명령어의\u0007번지를\u0007 프로그램\u0007카운터,\u0007 • 자료 버스(Data Bus) :\u0007CPU와\u0007메모리\u0007또는\u0007 기억하는\u0007레지스터 전송하는 정보에 프로그램\u0007계수기 입·출력\u0007기기\u0007사이에서\u0007데이터를\u0007전송하는\u0007 •\u0007분기\u0007명령이\u0007실행되는\u0007경우\u0007그\u0007 따른 버스의 분류 (PC;\u0007Program\u0007Counter) 양방향\u0007전송선 목적지\u0007주소로\u0007갱신된다. • 제어 버스(Control Bus) :\u0007CPU의\u0007현재\u0007상태 명령\u0007레지스터 현재\u0007실행중인\u0007명령의\u0007내용을\u0007기억하 나\u0007상태\u0007변경을\u0007메모리\u0007또는\u0007입·출력에\u0007알 (IR;\u0007Instruction\u0007Register) 는\u0007레지스터 리는\u0007제어신호를\u0007전송하는\u0007양방향\u0007전송선 누산기 연산된\u0007결과를\u0007일시적으로\u0007저장하는\u0007 위치에 따른 • 내부 버스 :\u0007CPU\u0007및\u0007메모리\u0007내에\u0007구성된\u0007Bus (AC;\u0007Accumulator) 레지스터로\u0007연산의\u0007중심임 버스의 분류 • 외부 버스 :\u0007주변\u0007입·출력장치에\u0007구성된\u0007Bus •\u0007상태\u0007레지스터(Status\u0007 •\u0007시스템\u0007내부의\u0007순간순간의\u0007상태가\u0007 Register)\u0007 기록된\u0007정보를\u0007PSW라고\u0007함 •\u0007PSWR(Program\u0007Status\u0007 •\u0007오버플로,\u0007언더플로,\u0007자리올림,\u0007계산 핵심 12.5, 11.3, 10.9, 10.5, 10.3, 09.8, 08.9, 08.3, 07.9, 07.5, 06.3, 05.9, 05.3, 04.5, 03.8, 03.5, 03.3, 02.3, 00.7 Word\u0007Register) 상태(0,\u0007-,\u0007+),\u0007인터럽트\u0007등의\u0007PSW 081 명령어의 구성 •\u0007플래그\u0007레지스터 를\u0007저장하고\u0007있는\u0007레지스터 Operation Code, 연산자부 모드(Mode)부 Operand, 자료부 메모리\u0007주소\u0007레지스터 기억장치를\u0007출입하는\u0007데이터의\u0007번지 (MAR;\u0007Memory\u0007 를\u0007기억하는\u0007레지스터 Address\u0007Register) 연산자부(Operation Code부) 기억장치를\u0007출입하는\u0007데이터가\u0007잠시\u0007 •수 행해야\u0007할\u0007동작에\u0007맞는\u0007연산자를\u0007표시함,\u0007흔히\u0007 메모리\u0007버퍼\u0007레지스터(MBR;\u0007 기억되는\u0007레지스터로\u0007CPU가\u0007데이터 OP-Code부라고\u0007한다. Memory\u0007Buffer\u0007Register) 를\u0007처리하기\u0007위해서는\u0007반드시\u0007거쳐\u0007 야\u0007함 •연 산자부의\u0007크기(비트\u0007수)는\u0007표현할\u0007수\u0007있는\u0007명령의\u0007종 •\u0007주소의\u0007변경,\u0007서브루틴\u0007연결\u0007및\u0007프 류를\u0007나타내는\u0007것으로,\u0007n\u0007Bit면\u0007최대\u00072\u0007n개의\u0007명령어를\u0007 인덱스\u0007레지스터 로그램에서의\u0007반복\u0007연산의\u0007횟수를\u0007 사용할\u0007수\u0007있다. (Index\u0007Register) 세는\u0007레지스터 •\u0007사용자가\u0007내용을\u0007변경할\u0007수\u0007있음 •모 드(Mode)부 :\u0007주소부의\u0007유효\u0007주소가\u0007결정되는\u0007방법을\u0007 지정한다.\u0007모드\u0007비트가\u00070이면\u0007직접,\u00071이면\u0007간접이다. 데이터\u0007레지스터\u0007 연산에\u0007사용될\u0007데이터를\u0007기억하는\u0007 (Data\u0007Register) 레지스터 자료부(Operand부) •\u0007저장된\u0007값을\u0007왼쪽\u0007또는\u0007오른쪽으로\u0007 시프트\u0007레지스터\u0007\u0007 •실 제\u0007데이터에\u0007대한\u0007정보를\u0007표시하는\u0007부분이다. 1Bit씩\u0007자리를\u0007이동시키는\u0007레지스터 (Shift\u0007Register) •\u00072배\u0007길이\u0007레지스터라고도\u0007함 •기 억장소의\u0007주소,\u0007레지스터\u0007번호,\u0007사용할\u0007데이터\u0007등을\u0007 표시한다. 메이저\u0007스테이터스\u0007레지스터 CPU의\u0007메이저\u0007상태를\u0007저장하고\u0007있는\u0007 (Major\u0007Status\u0007Register) 레지스터 •주 소부의\u0007크기는\u0007메모리의\u0007용량과\u0007관계가\u0007있다. •자 료부의\u0007길이가\u0007n\u0007Bit라면\u0007최대\u00072\u0007n개의\u0007기억장소를\u0007 주소로\u0007지정할\u0007수\u0007있다. 핵심 04.5, 00.10 080 버스 명령어 설계 시 고려사항 •C PU,\u0007메모리,\u0007I/O\u0007장치\u0007등과\u0007상호\u0007필요한\u0007정보를\u0007교환 •연 산자의 수와 종류 :\u0007해당\u0007컴퓨터\u0007시스템에서\u0007처리할\u0007기 하기\u0007위해\u0007연결하는\u0007공동의\u0007전송선이다. 능에\u0007맞게\u0007연산자의\u0007수와\u0007종류를\u0007결정함 •주 소 지정 방식 :\u0007명령어가\u0007사용할\u0007자료의\u0007위치를\u0007표현하 기\u0007위한\u0007방법을\u0007결정함 •데 이터 구조(워드의 크기) :\u0007해당\u0007컴퓨터\u0007시스템의\u0007데이터\u0007 구조에\u0007맞게\u0007명령어를\u0007설계함 •인 스트럭션 세트의 효율성을 높이기 위하여 고려할 사항 :\u0007 기억\u0007공간,\u0007사용\u0007빈도,\u0007주소지정\u0007방식 34 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 32] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.8, 10.9, 10.3, 07.3, 06.2, 05.4, 05.3, 04.4, 04.2, 03.3, 03.1, 02.4, 02.3, 02.2, 02.1, 01.1, 00.3, 00.2, 97.3 •\u00072개의\u0007데이터를\u0007비교하거나\u0007특정\u0007비트를\u0007반전시킬\u0007 082 연산자(Operation Code)의 기능 XOR 때\u0007사용함 (Compare, •\u00072개의\u0007데이터를\u0007XOR\u0007연산하여\u0007결과에\u00071Bit라도\u00071 함수 •산술 연산 :\u0007ADD,\u0007SUB,\u0007MUL,\u0007DIV,\u0007산술\u0007SHIFT\u0007등 비교) 이\u0007있으면\u0007서로\u0007다른\u0007데이터임 연산 •\u0007논리 연산 :\u0007NOT,\u0007AND,\u0007OR,\u0007XOR,\u0007논리적\u0007SHIFT,\u0007 •\u0007반전시킬\u0007때는\u0007반전시킬\u0007비트와\u00071을\u0007XOR\u0007시킴 기능 ROTATE,\u0007COMPLEMENT,\u0007CLEAR\u0007등 NOT 각\u0007비트의\u0007값을\u0007반전시키는\u0007연산으로\u0007보수를\u0007구할\u0007 \u0007CPU와\u0007기억장치\u0007사이에서\u0007정보를\u0007교환하는\u0007기능 (Comple- 때\u0007사용함 •\u0007Load :\u0007기억장치에\u0007기억되어\u0007있는\u0007정보를\u0007CPU로\u0007꺼내 ment, 보수) 자료 오는\u0007명령 •\u0007왼쪽\u0007또는\u0007오른쪽으로\u00071Bit씩\u0007자리를\u0007이동시키는\u0007 전달 •\u0007Store :\u0007CPU에\u0007있는\u0007정보를\u0007기억장치에\u0007기억시키는\u0007명령 연산으로\u0007데이터의\u0007직렬\u0007전송(Serial\u0007Transfer)에\u0007 기능 •\u0007Move :\u0007레지스터\u0007간에\u0007자료를\u0007전달하는\u0007명령 논리 Shift 사용함 •\u0007Push :\u0007자료를\u0007스택에\u0007저장하는\u0007명령 •\u0007삽입되는\u0007자리는\u0007무조건\u00070임 •\u0007Pop :\u0007스택에서\u0007자료를\u0007꺼내오는\u0007명령 •\u0007Shift에서\u0007밀려\u0007나가는\u0007비트의\u0007값을\u0007반대편\u0007값으로\u0007 명령어의\u0007실행\u0007순서를\u0007변경시킬\u0007때\u0007사용하는\u0007기능 Rotate 입력하는\u0007연산 •\u0007무조건 분기 명령 :\u0007GOTO,\u0007Jump(JMP)\u0007등 제어 •\u0007문자\u0007위치를\u0007변환할\u0007때\u0007이용 •\u0007조건 분기 명령 :\u0007IF\u0007조건,\u0007SPA,\u0007SNA,\u0007SZA\u0007등 기능 •\u0007Call :\u0007부프로그램\u0007호출 •\u0007부호(Sign)를\u0007고려하여\u0007자리를\u0007이동시키는\u0007연산으 •\u0007Return :\u0007부프로그램에서\u0007메인\u0007프로그램으로\u0007복귀\u0007 로,\u00072\u0007n으로\u0007곱하거나\u0007나눌\u0007때\u0007사용함 •\u0007왼쪽으로\u0007n\u0007Bit\u0007Shift하면\u0007원래\u0007자료에\u00072\u0007n을\u0007곱한\u0007값 \u0007CPU와\u0007I/O장치,\u0007또는\u0007메모리와\u0007I/O\u0007장치\u0007사이에서\u0007자료를\u0007 과\u0007같음 전달하는\u0007기능 산술 Shift •\u0007오른쪽으로\u0007n\u0007Bit\u0007Shift하면\u0007원래\u0007자료를\u00072\u0007n으로\u0007나 입·출력 • INPUT :\u0007입·출력장치의\u0007자료를\u0007주기억장치로\u0007입력하는\u0007 눈\u0007값과\u0007같음 기능 명령 •\u0007홀수를\u0007오른쪽으로\u0007한\u0007번\u0007Shift하면\u00070.5의\u0007오차가\u0007 •\u0007OUTPUT :\u0007주기억장치의\u0007자료를\u0007입·출력장치로\u0007출력 발생함 하는\u0007명령 핵심 083 피11.8, 0 연6.5, 0 산6.3, 0 자4.5 의 수에 따른 연산자의 분류 핵심 085 연13.8, 산10.5, 0 9. -5, 0 8. 산5, 06.9 술, 00.7 , 0 S0.3 hift 산술\u0007Shift는\u0007정수\u0007표현\u0007방식에서만\u0007가능한\u0007방법으로,\u0007정 NOT\u0007A처럼\u0007피연산자가\u00071개만\u0007필요한\u0007연산자를\u0007단항\u0007연 수의\u0007수치\u0007표현\u0007방법에\u0007따라서\u0007표현이\u0007조금씩\u0007다르다. 산자라\u0007하고,\u0007A+B처럼\u0007피연산자가\u00072개\u0007필요한\u0007연산자를\u0007 이항\u0007연산자라\u0007한다. 수치 Shift -43 +43 표현법 단항 연산자 NOT,\u0007COMPLEMENT,\u0007SHIFT,\u0007ROTATE,\u0007 •Padding\u0007Bit\u0007:\u00070 (Unary Operator) MOVE,\u0007CLEAR\u0007등 부호화\u0007 \u0007\u000710101011\u0007→\u000711010110 절대치 이항 연산자 \u0007\u0007-43×21,\u0007즉\u0007-86이\u0007된다. 양수는\u0007모두\u0007같다. 사칙\u0007연산,\u0007AND,\u0007OR,\u0007XOR,\u0007XNOR (Binary Operator) •Padding\u0007Bit\u0007:\u00070 •Padding\u0007Bit\u0007:\u00071 Shift 1의\u0007 \u0007\u000700101011\u0007→\u0007 \u0007\u000711010100\u0007→\u000710101001 Left 보수법 \u0007\u000701010110 \u0007\u0007-43×21,\u0007즉\u0007-86이\u0007된다. \u0007\u0007\u0007\u000743×21,\u0007즉\u000786이\u0007 핵심 14.3, 13.6, 12.5, 10.5, 08.9, 08.5, 05.9, 05.5, 05.3, 04.3, 03.3, 00.3, 99.4 •Padding\u0007Bit\u0007:\u00070 된다. 084 연산 2의\u0007 \u0007\u000711010101\u0007→\u000710101010 보수법 \u0007\u0007-43×21,\u0007즉\u0007-86이\u0007된다. •\u0007특정\u0007문자\u0007또는\u0007특정\u0007Bit를\u0007삭제(Clear)시키는\u0007명령 AND 으로\u0007Masking\u0007명령이라고도\u0007함 (Masking •\u0007삭제할\u0007부분의\u0007Bit를\u00070과\u0007AND시켜서\u0007삭제하는데,\u0007 Operation) 대응시키는\u00070인\u0007Bit를\u0007Mask\u0007Bit라고\u0007함 \u0007•\u0007특정\u0007문자를\u0007삽입하거나\u0007특정\u0007Bit에\u00071을\u0007세트시키는\u0007 OR 명령으로\u0007Selective\u0007Set\u0007연산이라고도\u0007함\u0007 (Selective •\u0007삽입하거나\u0007세트시킬\u0007Bit에\u0007삽입할\u0007문자\u0007코드\u0007또는\u0007 Set) 1을\u0007OR\u0007연산시킴 35 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 33] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •Padding\u0007Bit\u0007:\u00070 •\u0007단점 부호화\u0007 •오차\u0007발생\u0007:\u00070.5\u0007증가 2 번지 -\u0007\u0007\u0007연산의\u0007결과는\u0007주로\u0007Operand\u00071에\u0007저장되므로\u0007 절대치 \u0007\u000710101011\u0007→\u000710010101 명령어 Operand\u00071에\u0007있던\u0007원래의\u0007자료가\u0007파괴됨 양수는\u0007모두\u0007같다. \u0007\u0007-43÷21\u0007→\u0007-21.5\u0007→\u0007-21\u0007 -\u0007\u0007전체\u0007프로그램의\u0007길이가\u0007길어짐 •Padding\u0007Bit\u0007:\u00070 •Padding\u0007Bit\u0007:\u00071 \u0007\u0007\u000700101011\u0007→\u0007 1 번지 •\u0007Operand부가\u00071개로\u0007구성되어\u0007있음 Shift 1의\u0007 •오차\u0007발생\u0007:\u00070.5\u0007증가 00010101\u0007→\u000721 명령어 •\u0007AC(Accumulator;\u0007누산기)를\u0007이용하여\u0007명령어를\u0007처리함 Right 보수법 \u0007\u000711010100\u0007→\u000711101010 \u0007\u0007\u000743÷21,\u0007즉\u000721.5가\u0007 \u0007\u0007-43÷21\u0007→\u0007-21.5\u0007→\u0007-21 되어야\u0007하지만\u0007 •\u0007Operand부\u0007없이\u0007OP-Code부만으로\u0007구성\u0007 오차가\u0007발생하여\u0007 •\u0007모든\u0007연산은\u0007Stack\u0007메모리의\u0007Stack\u0007Pointer가\u0007가리키 •Padding\u0007Bit\u0007:\u00071 0.5가\u0007감소한다. 는\u0007Operand를\u0007이용하여\u0007수행함 2의\u0007 •오차\u0007발생\u0007:\u00070.5\u0007감소 0 번지 •\u0007수식을\u0007계산하기\u0007위해서는\u0007우선,\u0007수식을\u0007Postfix(역\u0007 보수법 \u0007\u000711010101\u0007→\u000711101010 명령어 Polish)\u0007형태로\u0007변경하여야\u0007함 \u0007\u0007-43÷21\u0007→\u0007-21.5\u0007→\u0007-22 •\u0007모든\u0007연산은\u0007스택에\u0007있는\u0007자료를\u0007이용하여\u0007수행하기\u0007 때문에\u0007스택\u0007머신(Stack\u0007Machine)이라고도\u0007함 잠깐만요 ! \u0007 Padding Bit(패딩 비트) •\u0007원래의\u0007자료가\u0007남지\u0007않음 Shift에서\u0007자리를\u0007이동한\u0007후\u0007생기는\u0007왼쪽이나\u0007오른쪽\u0007끝의\u0007빈자리에\u0007 채워지는\u0007비트를\u0007말합니다.\u0007패딩\u0007비트는\u0007모두\u00070으로\u0007채워지는\u0007데,\u0007음 수에\u0007대해서\u0007다음의\u0007세\u0007가지\u0007경우는\u00071로\u0007채워집니다. 핵심 14.8, 14.3, 05.9, 05.5, 00.7, 99.8 •1의\u0007보수법에서\u0007Shift\u0007Left 087 주소 설계 시 고려 사항 •1의\u0007보수법,\u00072의\u0007보수법에서\u0007Shift\u0007Right \u0007오른쪽 1Bit Shift(2의 보수법) •표 현의 효율성 : 빠르게\u0007접근하고\u0007주소\u0007지정에\u0007적은\u0007비트 1\u00071\u00070\u00071\u00070\u00071\u00070\u00071\u0007\u0007→\u0007\u00071\u0007\u00071\u00071\u00070\u00071\u00070\u00071\u00070 수를\u0007사용할\u0007수\u0007있도록\u0007다양한\u0007어드레스\u0007모드를\u0007사용할\u0007 잃어버리는\u0007비트 수\u0007있어야\u0007함 부호\u0007비트 Padding\u0007비트 • 사용의 편리성 :\u0007다양하고\u0007융통성\u0007있는\u0007프로그램\u0007작업을\u0007 왼쪽 1Bit Shift(2의 보수법) 위해\u0007포인터,\u0007프로그램\u0007리로케이션\u0007등의\u0007편의를\u0007제공 1\u00071\u00070\u00071\u00070\u00071\u00070\u00071\u0007\u0007→\u0007\u00071\u00070\u00071\u00070\u00071\u00070\u00071\u00070 하여야\u0007함 잃어버리는\u0007비트 부호\u0007비트 • 주소공간과 기억공간의 독립성 :\u0007프로그램\u0007상에서\u0007사용한\u0007 Padding\u0007비트 주소를\u0007변경\u0007없이\u0007실제\u0007기억공간\u0007내의\u0007주소로\u0007재배치할\u0007 수\u0007있도록\u0007서로\u0007독립적이어야\u0007함 03.5, 03.3, 02.9, 02.5 핵심 14.5, 14.3, 13.8, 12.5, 11.8, 11.6, 10.9, 09.8, 09.3, 07.9, 07.5, 07.3, 06.9, 06.5, 06.3, 05.9, 05.5, 05.3, 04.5, 04.3, 03.8, \u0007-\u0007주소공간\u0007:\u0007프로그램에서\u0007사용하는\u0007주소,\u0007보조기억 086 명령어 형식 장치\u0007내의\u0007기억공간 •\u0007Operand부가\u00073개로\u0007구성되는\u0007명령어\u0007형식으로\u0007여러\u0007 \u0007-기억공간\u0007:\u0007주기억장치\u0007내의\u0007실제\u0007기억공간 개의\u0007범용\u0007레지스터(GPR)를\u0007가진\u0007컴퓨터에서\u0007사용함 •\u0007연산의\u0007결과는\u0007주로\u0007Operand\u00071에\u0007기록됨\u0007 00.1 •\u0007연산\u0007시\u0007원시\u0007자료를\u0007파괴하지\u0007않음 3 번지 핵심 14.8, 13.8, 12.8, 12.5, 10.9, 10.5, 09.5, 08.9, 08.5, 07.5, 06.9, 06.3, 05.9, 05.3, 04.9, 03.8, 03.5, 02.5, 01.9, 01.6, 01.3, 명령어 •\u0007다른\u0007형식의\u0007명령어를\u0007이용하는\u0007것보다\u0007프로그램\u0007전체 088 주소지정방식의 종류 의\u0007길이를\u0007짧게\u0007할\u0007수\u0007있음 •\u0007전체\u0007프로그램\u0007실행\u0007시\u0007명령\u0007인출을\u0007위하여\u0007주기억장 •\u0007명령\u0007실행에\u0007필요한\u0007데이터의\u0007위치를\u0007지정하지\u0007 치를\u0007접근하는\u0007횟수가\u0007줄어들어\u0007프로그램\u0007실행\u0007속도를\u0007 암시적 주소 않고\u0007누산기나\u0007스택의\u0007데이터를\u0007묵시적으로\u0007지 단축시킴 지정방식 정하여\u0007사용함 (Implied •\u0007Operand부가\u0007두\u0007개로\u0007구성되는,\u0007가장\u0007일반적으로\u0007사 •\u0007오퍼랜드가\u0007없는\u0007명령이나\u0007‘PUSH\u0007R1’처럼\u0007오퍼 Mode) 용되는\u0007명령어\u0007형식임 랜드가\u00071개인\u0007명령어\u0007형식에\u0007사용됨 •\u0007여러\u0007개의\u0007범용\u0007레지스터를\u0007가진\u0007컴퓨터에서\u0007사용함 •\u0007명령어\u0007자체에\u0007오퍼랜드(실제\u0007데이터)를\u0007내포하 2 번지 •\u0007실행\u0007속도가\u0007빠르고\u0007기억\u0007장소를\u0007많이\u0007차지하지\u0007않음 고\u0007있는\u0007방식 명령어 •\u00073주소\u0007명령에\u0007비해\u0007명령어의\u0007길이가\u0007짧음 즉치(즉시)적 •\u0007별도의\u0007기억장소를\u0007액세스하지\u0007않고\u0007CPU에서\u0007 •\u0007계산\u0007결과가\u0007기억장치에\u0007기억되고\u0007중앙처리장치에도\u0007 주소지정방식 곧바로\u0007자료를\u0007이용할\u0007수\u0007있어서\u0007실행\u0007속도가\u0007빠 남아\u0007있어서\u0007계산\u0007결과를\u0007시험할\u0007필요가\u0007있을\u0007때\u0007시 (Immediate 르다는\u0007장점이\u0007있음 간이\u0007절약됨 Mode) •\u0007명령어의\u0007길이에\u0007영향을\u0007받으므로\u0007표현할\u0007수\u0007있 는\u0007데이터\u0007값의\u0007범위가\u0007제한적임 36 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 34] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007명령의\u0007주소부(Operand)가\u0007사용할\u0007자료의\u0007번지를\u0007 •마 이크로\u0007오퍼레이션의\u0007순서를\u0007결정하기\u0007위하여\u0007제어 표현하고\u0007있는\u0007방식 장치가\u0007발생하는\u0007신호를\u0007제어신호라고\u0007한다. •\u0007명령의\u0007Operand부에\u0007표현된\u0007주소를\u0007이용하여\u0007실 •마 이크로\u0007오퍼레이션은\u0007Instruction\u0007실행과정에서\u0007한\u0007 제\u0007데이터가\u0007기억된\u0007기억장소에\u0007직접\u0007사상시킬\u0007수\u0007 직접 주소 있음 단계씩\u0007이루어지는\u0007동작으로,\u0007한\u0007개의\u0007Instruction은\u0007 지정방식 •\u0007주소\u0007부분에\u0007실제\u0007사용할\u0007데이터의\u0007유효\u0007주소를\u0007 여러\u0007개의\u0007Micro\u0007Operation이\u0007동작되어\u0007실행된다. (Direct 적기\u0007때문에\u0007주소\u0007길이에\u0007제약을\u0007받는다. • Micro Cycle Time Mode) •\u0007기억\u0007용량이\u00072\u0007n개의\u0007Word인\u0007메모리\u0007시스템에서\u0007 주소를\u0007표현하려면\u0007n비트의\u0007Operand부가\u0007필요함 \u0007\u0007\u0007-\u0007\u0007\u0007한\u0007개의\u0007Micro\u0007Operation을\u0007수행하는\u0007데\u0007걸리는\u0007 •\u0007직접\u0007주소지정방식에서\u0007명령의\u0007Operand부에\u0007데이 시간 터를\u0007가지고\u0007있는\u0007레지스터의\u0007번호를\u0007지정하면\u0007레 \u0007\u0007\u0007-\u0007\u0007\u0007CPU\u0007Cycle\u0007Time\u0007또는\u0007CPU\u0007Clock\u0007Time이라고도\u0007 지스터\u0007모드라고\u0007함 하며,\u0007CPU\u0007속도를\u0007나타내는\u0007척도로\u0007이용됨 •\u0007명령어에\u0007나타낼\u0007주소가\u0007명령어\u0007내에서\u0007데이터 를\u0007지정하기\u0007위해\u0007할당된\u0007비트(Operand\u0007부의\u0007비 제어 워드와 마이크로 프로그램 트)\u0007수로\u0007나타낼\u0007수\u0007없을\u0007때\u0007사용하는\u0007방식 •제 어 워드 :\u0007레지스터의\u0007선택과\u0007산술\u0007논리\u0007연산장치의\u0007 •\u0007명령의\u0007길이가\u0007짧고\u0007제한되어\u0007있어도\u0007긴\u0007주소에\u0007 간접 주소 접근\u0007가능함 역할을\u0007결정하고,\u0007어떤\u0007마이크로\u0007연산을\u0007할\u0007것인가를\u0007 지정방식 •\u0007명령어\u0007내의\u0007주소부에\u0007실제\u0007데이터가\u0007저장된\u0007장 결정하는\u0007비트의\u0007모임을\u0007제어\u0007워드라고\u0007한다.\u0007제어\u0007워 (Indirect 소의\u0007번지를\u0007가진\u0007기억장소의\u0007번지를\u0007표현하므 드는\u0007마이크로\u0007명령어라고도\u0007함 Mode) 로,\u0007최소한\u0007주기억장치를\u00072번\u0007이상\u0007접근하여\u0007데 이터가\u0007있는\u0007기억장소에\u0007도달함 •마 이크로 프로그램 :\u0007어떤\u0007명령을\u0007수행할\u0007수\u0007있도록\u0007구성 •\u0007간접\u0007주소지정방식에서\u0007명령의\u0007Operand부에\u0007데 된\u0007일련의\u0007제어\u0007워드가\u0007특수한\u0007기억장치\u0007속에\u0007저장될\u0007 이터의\u0007주소를\u0007가지고\u0007있는\u0007레지스터의\u0007번호를\u0007 때\u0007이를\u0007마이크로\u0007프로그램이라고\u0007함 지정하면\u0007레지스터\u0007간접\u0007모드라고\u0007함 •\u0007Operand부와\u0007특정\u0007레지스터의\u0007값이\u0007더해져서\u0007 유효주소를\u0007계산하는\u0007방식 핵심 14.5, 14.3, 11.8, 11.3, 10.5, 10.3, 09.5, 09.3, 08.9, 07.5, 07.3, 03.8, 00.7, 99.4 •\u0007상대(Relative) 주소지정방식\u0007:\u0007명령어의\u0007주소\u0007부 090 Micro Cycle Time 부여 방식 분\u0007+\u0007PC\u0007 •\u0007Base Register Mode\u0007:\u0007명령어의\u0007주소\u0007부분\u0007+\u0007 한\u0007개의\u0007Micro\u0007Operation을\u0007\u0007수행하는\u0007데\u0007걸리는\u0007시간을\u0007 Base\u0007Register Micro\u0007Cycle\u0007Time이라\u0007한다. 계산에 의한 • Index Register Mode\u0007:\u0007명령어의\u0007주소\u0007부분\u0007+\u0007 주소지정방식 Index\u0007Register ※\u0007\u0007\u0007계산에\u0007의한\u0007주소지정방식은\u0007전체\u0007기억장치의\u0007 •\u0007모든\u0007마이크로\u0007오퍼레이션의\u0007동작\u0007시간이\u0007 주소를\u0007사용해야\u0007하는\u0007일반적인\u0007주소지정방식 같다고\u0007가정하여\u0007CPU\u0007Clock의\u0007주기를\u0007 에\u0007비해\u0007적은\u0007수의\u0007비트를\u0007사용하고,\u0007레지스터\u0007 Micro\u0007Cycle\u0007Time과\u0007같도록\u0007정의하는\u0007방식 지정\u0007필드\u0007없이\u0007묵시적으로\u0007레지스터를\u0007지정하 •\u0007모든\u0007마이크로\u0007오퍼레이션\u0007중에서\u0007동작\u0007시 동기 고정식 여\u0007사용하기\u0007때문에\u0007데이터의\u0007주소를\u0007분류할\u0007때\u0007 간이\u0007가장\u0007긴\u0007마이크로\u0007오퍼레이션의\u0007동작\u0007 (Synchronous 약식\u0007주소라고\u0007함 시간을\u0007\u0007Micro\u0007Cycle\u0007Time으로\u0007정함 Fixed) •\u0007모든\u0007마이크로\u0007오퍼레이션의\u0007동작\u0007시간이\u0007 비슷할\u0007때\u0007유리한\u0007방식임 •\u0007장점\u0007:\u0007제어기의\u0007구현이\u0007단순함 핵심 13.8, 13.3, 11.8, 10.5, 10.3, 08.9, 08.5, 06.9, 06.5, 04.5, 03.8, 03.3, 02.9, 01.9, 01.6, 00.10, 00.7, 99.10 •\u0007단점\u0007:\u0007CPU의\u0007시간\u0007낭비가\u0007심함 089 마이크로 오퍼레이션(Micro Operation)의 정의 •\u0007동작\u0007시간이\u0007유사한\u0007Micro\u0007Operation들끼리\u0007 • Instruction을\u0007수행하기\u0007위해\u0007CPU\u0007내의\u0007레지스터와\u0007 그룹을\u0007만들어,\u0007각\u0007그룹별로\u0007서로\u0007다른\u0007 Micro\u0007Cycle\u0007Time을\u0007정의하는\u0007방식 플래그가\u0007의미\u0007있는\u0007상태\u0007변환을\u0007하도록\u0007하는\u0007동작이다. •\u0007동기\u0007고정식에\u0007비해\u0007CPU\u0007시간\u0007낭비를\u0007줄일\u0007 동기 가변식 • 컴퓨터의\u0007모든\u0007명령을\u0007구성하고\u0007있는\u0007몇\u0007가지\u0007종류의\u0007 수\u0007있는\u0007반면,\u0007제어기의\u0007구현은\u0007조금\u0007복잡함 (Synchronous 기본\u0007동작이다.\u0007 •\u0007마이크로\u0007오퍼레이션들의\u0007수행시간이\u0007현저 Variable) 한\u0007차이를\u0007나타낼\u0007때\u0007사용함 • 컴퓨터\u0007프로그램에\u0007의한\u0007명령의\u0007수행은\u0007마이크로\u0007오퍼 •\u0007각\u0007그룹\u0007간\u0007서로\u0007다른\u0007사이클\u0007타임의\u0007동기를\u0007 레이션의\u0007수행으로\u0007이루어진다.\u0007 맞추기\u0007위해\u0007각\u0007그룹\u0007간의\u0007마이크로\u0007사이클\u0007 타임을\u0007정수배가\u0007되게함 • 레지스터에\u0007저장된\u0007데이터에\u0007의해\u0007이루어지는\u0007동작이다. • 마이크로\u0007오퍼레이션은\u0007하나의\u0007Clock\u0007펄스\u0007동안\u0007실행 되는\u0007기본\u0007동작으로\u0007모든\u0007마이크로\u0007오퍼레이션은\u0007CPU 의\u0007Clock\u0007펄스에\u0007맞춰\u0007실행된다. 37 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 35] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 동작 순서 •\u0007모든\u0007마이크로\u0007오퍼레이션에\u0007대하여\u0007서로\u0007 다른\u0007Micro\u0007Cycle\u0007Time을\u0007정의하는\u0007방식 비동기식 •\u0007CPU의\u0007시간\u0007낭비는\u0007전혀\u0007없으나\u0007제어기가\u0007 Micro Operation 의 미 (Asynchronous) 매우\u0007복잡해지기\u0007때문에\u0007실제로는\u0007거의\u0007사 MAR\u0007←\u0007PC PC에\u0007있는\u0007번지를\u0007MAR에\u0007전송시킴 용되지\u0007않음 MBR\u0007←\u0007M[MAR], •\u0007메모리에서\u0007MAR이\u0007지정하는\u0007위치의\u0007값을\u0007 MBR에\u0007전송함 PC\u0007←\u0007PC\u0007+\u00071 •\u0007다음에\u0007실행할\u0007명령의\u0007위치를\u0007지정하기\u0007 핵심 14.8, 12.8, 08.3, 07.3, 06.5, 05.5, 02.9, 01.6, 01.3, 00.10, 99.10 위해\u0007PC의\u0007값을\u00071\u0007증가시킴\u0007 091 메이저 스테이트 IR\u0007←\u0007MBR[OP], •\u0007명령어의\u0007OP-Code\u0007부분을\u0007명령\u0007레지스 • 현재\u0007CPU가\u0007무엇을\u0007하고\u0007있는가를\u0007나타내는\u0007상태로서\u0007 터에\u0007전송함 \u0007\u0007※\u0007현재\u0007MBR에는\u0007주기억장치에서\u0007읽어온\u0007 Fetch,\u0007Indirect,\u0007Execute,\u0007Interrupt\u0007이렇게\u00074개 명령이\u0007들어\u0007있음 의\u0007상태가\u0007있다. I\u0007←\u0007MBR[I] •\u0007명령어의\u0007모드\u0007비트를\u0007플립플롭\u0007I에\u0007전송함 • CPU는\u0007메이저\u0007스테이트의\u00074가지\u0007단계를\u0007반복적으로\u0007 I가\u00070이면\u0007F\u0007플립플롭에\u00071을\u0007전송하여\u0007 F\u0007←\u00071\u0007 Execute\u0007단계로\u0007변천하고,\u0007I가\u00071이면\u0007R\u0007플립 거치면서\u0007동작을\u0007수행한다. 또는\u0007R\u0007←\u00071 플롭에\u00071을\u0007전송하여\u0007Indirect\u0007단계로\u0007변천함 • 메이저\u0007스테이트는\u0007메이저\u0007스테이트\u0007레지스터를\u0007통해 서\u0007알\u0007수\u0007있다. • Major\u0007Cycle\u0007또는\u0007Machine\u0007Cycle이라고도\u0007한다. 핵심 10.9, 10.3, 09.8, 09.3, 07.5, 06.9, 05.4, 05.3, 03.8, 99.10 093 간접 단계(Indirect Cycle) • 메이저 스테이트의 변천 과정 • Fetch\u0007단계에서\u0007해석된\u0007명령의\u0007주소부가\u0007간접주소인\u0007 경우\u0007수행된다. •F etch\u0007단계에서\u0007해석한\u0007주소를\u0007읽어온\u0007후\u0007그\u0007주소가\u0007간 접주소이면\u0007유효주소를\u0007계산하기\u0007위해\u0007다시\u0007Indirect\u0007 단계를\u0007수행한다. •간 접주소가\u0007아닌\u0007경우에는\u0007명령어에\u0007따라\u0007Execute\u0007단 계\u0007또는\u0007Fetch\u0007단계로\u0007이동할지를\u0007판단한다. •동 작 순서 핵심 11.6, 11.3, 09.8, 08.3, 06.9, 06.3, 05.9, 05.5, 03.3, 02.9, 02.5, 02.3, 00.10 092 인출 단계(Fetch Cycle) Micro Operation 의 미 MBR에\u0007있는\u0007명령어의\u0007번지\u0007부분을\u0007 • 명령어를\u0007주기억장치에서\u0007중앙처리장치의\u0007명령\u0007레지스 MAR\u0007←\u0007MBR[AD] MAR에\u0007전송함 터로\u0007가져와\u0007해독하는\u0007단계이다. 메모리에서\u0007MAR이\u0007지정하는\u0007위치 MBR\u0007←\u0007M[MAR] • 읽어와\u0007해석된\u0007명령어가\u00071Cycle\u0007명령이면\u0007이를\u0007수행한\u0007 의\u0007값을\u0007MBR에\u0007전송함 후\u0007다시\u0007Fetch\u0007Cycle로\u0007변천한다. No\u0007Operation 동작\u0007없음 • 1Cycle\u0007명령이\u0007아니면,\u0007해석된\u0007명령어의\u0007모드\u0007비트에\u0007 F에\u00071,\u0007R에\u00070을\u0007전송하여\u0007Execute\u0007 F\u0007←\u00071,\u0007R\u0007←\u00070 따라\u0007직접주소와\u0007간접주소를\u0007판단한다. 단계로\u0007변천함 -\u0007모드\u0007비트가\u00070이면\u0007직접주소이므로\u0007Execute\u0007단계 로\u0007변천한다. 핵심 12.8, 12.5, 11.8, 10.9, 09.5, 08.9, 05.4, 05.3, 04.5, 03.5, 02.9, 01.9, 01.6, 01.3, 00.3, 99.10 -\u0007모드\u0007비트가\u00071이면\u0007간접주소이므로\u0007Indirect\u0007단계로\u0007 094 인터럽트 단계(Interrept Cycle) 변천한다. • 인터럽트\u0007발생\u0007시\u0007복귀주소(PC)를\u0007저장시키고,\u0007제어순 서를\u0007인터럽트\u0007처리\u0007프로그램의\u0007첫\u0007번째\u0007명령으로\u0007옮기 는\u0007단계이다. 38 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 36] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 인터럽트\u0007단계를\u0007마친\u0007후에는\u0007항상\u0007Fetch\u0007단계로\u0007변천 STA(Store to AC) :\u0007M[AD]\u0007←\u0007AC 한다. Micro Operation 의 미 • Interrupt가\u0007발생할\u0007때만\u0007실행되어\u0007다른\u0007일을\u0007처리하고\u0007 MBR에\u0007있는\u0007명령어의\u0007번지\u0007부분을\u0007MAR에\u0007 돌아오기\u0007때문에\u0007하드웨어로\u0007실현되는\u0007서브부틴(부\u0007프 MAR\u0007←\u0007MBR[AD] 전송함 로그램)의\u0007호출이라고도\u0007한다. MBR\u0007←\u0007AC AC의\u0007값을\u0007MBR에\u0007전송함 • 동작 순서 MBR의\u0007값을\u0007메모리의\u0007MAR이\u0007지정하는\u0007 M(MAR)\u0007←\u0007MBR 위치에\u0007전송함 Micro Operation 의 미 MBR[AD]\u0007←\u0007PC, •\u0007PC가\u0007가지고\u0007있는,\u0007다음에\u0007실행할\u0007명령의\u0007 BSA(Branch and Save Return Address) 주소를\u0007MBR의\u0007주소\u0007부분으로\u0007전송함 PC\u0007←\u00070 •\u0007복귀주소를\u0007저장할\u00070번지를\u0007PC에\u0007전송함 Micro Operation 의 미 MAR\u0007←\u0007PC, •\u0007PC가\u0007가지고\u0007있는\u0007값\u00070번지를\u0007MAR에\u0007전송함 MAR\u0007←\u0007MBR[AD], •\u0007MBR에\u0007있는\u0007명령어의\u0007번지\u0007부분을\u0007 PC\u0007←\u0007PC\u0007+\u00071 •\u0007인터럽트\u0007처리\u0007루틴으로\u0007이동할\u0007수\u0007있는\u0007 MAR에\u0007전송함 인터럽트\u0007벡터의\u0007위치를\u0007지정하기\u0007위해\u0007 \u0007\u0007※\u0007MBR[AD]는\u0007복귀주소가\u0007저장될\u0007위치 PC의\u0007값을\u00071\u0007증가시켜\u00071로\u0007세트시킴 이면서\u0007부프로그램이\u0007시작되기\u0007바로\u0007 전\u0007번지임 M[MAR]\u0007←\u0007MBR, •\u0007MBR이\u0007가지고\u0007있는,\u0007다음에\u0007실행할\u0007명령의\u0007 MBR[AD]\u0007←\u0007PC, •\u0007PC의\u0007값(복귀주소)을\u0007MBR의\u0007주소\u0007부분 주소를\u0007메모리의\u0007MAR이\u0007가리키는\u0007위치(0\u0007 으로\u0007전송함 번지)에\u0007저장함 IEN\u0007←\u00070 •\u0007인터럽트\u0007단계가\u0007끝날\u0007때까지\u0007다른\u0007인터럽 \u0007\u0007※\u0007복귀주소를\u0007저장하기\u0007위한\u0007준비단계 트가\u0007발생하지\u0007않게\u0007IEN에\u00070을\u0007전송함 임 PC\u0007←\u0007MBR[AD] •\u0007MBR의\u0007주소\u0007부분을\u0007PC로\u0007전송함 F\u0007←\u00070,\u0007R\u0007←\u00070 F에\u00070,\u0007R에\u00070을\u0007전송하여\u0007Fetch\u0007단계로\u0007변천함 \u0007\u0007※\u0007부프로그램이\u0007시작되기\u0007바로\u0007전\u0007주소 를\u0007PC에\u0007전송함 M[MAR]\u0007←\u0007MBR[AD] •\u0007MBR에\u0007있는\u0007명령어의\u0007번지\u0007부분을\u0007메 핵심 14.3, 13.8, 12.8, 10.9, 10.3, 09.8, 08.9, 07.5, 06.5, 05.9, 04.9, 03.8, 02.9, 01.6 모리의\u0007MAR이\u0007가리키는\u0007위치에\u0007전송함 095 주요 명령의 마이크로 오퍼레이션 \u0007\u0007※\u0007부프로그램이\u0007시작되기\u0007바로\u0007전\u0007주소 에\u0007복귀주소를\u0007저장함 ADD :\u0007AC\u0007←\u0007AC\u0007＋\u0007M[AD] PC\u0007←\u0007PC+1 •\u0007PC의\u0007값을\u00071\u0007증가시킴 Micro Operation 의 미 \u0007\u0007※\u0007부프로그램의\u0007시작임 MBR에\u0007있는\u0007명령어의\u0007번지\u0007부분을\u0007MAR에\u0007 MAR\u0007←\u0007MBR[AD] 전송함 핵심 13.6, 10.9, 08.3, 02.3, 01.3 MBR\u0007←\u0007M[MAR] 메모리에서\u0007MAR이\u0007지정하는\u0007위치의\u0007값을\u0007 096 제어 데이터 MBR에\u0007전송함 누산기의\u0007값과\u0007MBR의\u0007값을\u0007더해\u0007누산기에\u0007 • 제어장치가\u0007제어\u0007신호를\u0007발생하기\u0007위한\u0007자료로서,\u0007 AC\u0007←\u0007AC\u0007+\u0007MBR 전송함 CPU가\u0007특정한\u0007메이저\u0007상태와\u0007타이밍\u0007상태에\u0007있을\u0007때\u0007 제어\u0007자료에\u0007따른\u0007제어\u0007규칙에\u0007의해\u0007제어\u0007신호가\u0007발생 LDA(Load to AC) :\u0007AC\u0007←\u0007M[AD] 한다. Micro Operation 의 미 • 제어\u0007데이터는\u0007종류 MBR에\u0007있는\u0007명령어의\u0007번지\u0007부분을\u0007MAR에\u0007 -\u0007메이저\u0007스테이트\u0007사이의\u0007변천을\u0007제어하는\u0007데이터 MAR\u0007←\u0007MBR[AD] 전송함 -\u0007중앙처리장치의\u0007제어점을\u0007제어하는\u0007데이터 MBR\u0007←\u0007M[MAR] •\u0007메모리에서\u0007MAR이\u0007지정하는\u0007위치의\u0007값을\u0007 -\u0007\u0007인스트럭션의\u0007수행\u0007순서를\u0007결정하는\u0007데\u0007필요한\u0007제어\u0007 MBR에\u0007전송함 데이터 AC\u0007←\u00070 •\u0007AC에\u00070을\u0007전송하여\u0007AC를\u0007초기화함 AC\u0007←\u0007AC\u0007+\u0007MBR •\u0007메모리에서\u0007가져온\u0007MBR과\u0007AC를\u0007더해\u0007 AC에\u0007전송함 \u0007\u0007※\u0007초기화된\u0007AC에\u0007더해지므로\u0007메모리의\u0007 값을\u0007AC로\u0007불러오는\u0007것이됨 39 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 37] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 제어\u0007기억장치의\u0007용량을\u0007줄일\u0007수\u0007있다.\u0007 구 분 Fetch Indirect Execute Interrupt • 마이크로\u0007명령어의\u0007코드화된\u0007비트들을\u0007해독하기\u0007위 State\u0007간\u0007 명령어\u0007종류\u0007 인터럽트\u0007 주소지정방식 \u0007없음 변이용 주소지정방식 요청\u0007신청 한\u0007지연이\u0007발생한다.\u0007 Interrupt\u0007 나노 명령(Nano Instruction) 제어점\u0007 명령어의\u0007 명령어 유효주소 체제에\u0007 제어용 연산자 • 나노\u0007메모리(Nano\u0007Memory)라는\u0007낮은\u0007레벨의\u0007메모 따라\u0007달라짐 리에\u0007저장된\u0007마이크로\u0007명령을\u0007나노\u0007명령이라\u0007한다. Interrupt\u0007 수행\u0007순서 • 수직\u0007마이크로\u0007명령을\u0007수행하는\u0007제어기에서\u0007디코더 PC 없음 PC 체제에\u0007 제어용 따라\u0007달라짐 를\u0007ROM(나노\u0007메모리)으로\u0007대치하여\u0007두\u0007메모리\u0007레 벨로\u0007구성한다. 핵심 14.8, 13.3, 06.9, 02.5, 99.10 097 제어장치의 비교 핵심 12.3, 11.6, 09.5, 09.3, 03.8, 03.5, 00.10, 99.10 099 입·출력장치의 구성 제어장치는\u0007필요한\u0007마이크로\u0007연산들이\u0007연속적으로\u0007수행 될\u0007수\u0007있도록\u0007제어\u0007신호를\u0007보내는\u0007역할을\u0007한다. (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:2658)(cid:2966) (cid:2737)(cid:1245)(cid:2480)(cid:2658)(cid:2966) 구 분 고정배선 제어장치 마이크로 프로그래밍 기법 (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:2658)(cid:2966)(cid:1)(cid:2689)(cid:2479)(cid:1245) (cid:2737) 반응\u0007속도 고속 저속 (cid:1245) (cid:2480) (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:1)(cid:2689)(cid:2479)(cid:1245) (cid:2635)(cid:3104)(cid:3221)(cid:2633)(cid:2333) (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:1)(cid:2017)(cid:2333) 회로\u0007복잡도 복잡 간단 (cid:2658) (cid:2966) 경제성 비경제적 경제적 (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:1)(cid:2689)(cid:2479)(cid:1245) (cid:2635)(cid:3104)(cid:3221)(cid:2633)(cid:2333) (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:1)(cid:2017)(cid:2333) (cid:2017) 융통성 없음 있음 (cid:2333) (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:2658)(cid:2966)(cid:1)(cid:2689)(cid:2479)(cid:1245) 구성 하드웨어 소프트웨어 (cid:2746)(cid:2452)(cid:2890)(cid:1851)(cid:2658)(cid:2966) (cid:2641)(cid:104)(cid:1)(cid:1)(cid:1)(cid:2937)(cid:1777)(cid:2658)(cid:2966) 잠깐만요 ! 마이크로 프로그램 내부\u0007제어신호를\u0007발생하는\u0007여러\u0007가지\u0007마이크로\u0007인스트럭션으로\u0007작성 된\u0007것으로,\u0007보통\u0007ROM에\u0007저장되어\u0007있습니다.\u0007 입·출력 제어장치 • 입·출력장치와\u0007컴퓨터\u0007사이의\u0007자료\u0007전송을\u0007제어하 는\u0007장치이다. 핵심 14.3, 12.5, 11.3, 07.9, 07.5, 04.9, 00.10, 99.8 098 마이크로 명령의 형식 • 데이터\u0007버퍼\u0007레지스터를\u0007이용하여\u0007두\u0007장치\u0007간의\u0007속 도\u0007차를\u0007조절한다. 수평 마이크로 명령(Horizontal Micro Instruction) • 제어\u0007신호의\u0007논리적,\u0007물리적\u0007변환과\u0007오류를\u0007제어한다. •마 이크로\u0007명령의\u0007한\u0007비트가\u0007한\u0007개의\u0007마이크로\u0007동작 • 종류 :\u0007DMA,\u0007채널,\u0007입·출력\u0007프로세서,\u0007입·출력\u0007컴 을\u0007관할하는\u0007명령이다. 퓨터\u0007등 •M icro\u0007Operation부가\u0007m\u0007Bit일\u0007때\u0007m개의\u0007마이크 입·출력 인터페이스 로\u0007동작을\u0007표현할\u0007수\u0007있다. • 동작\u0007방식이나\u0007데이터\u0007형식이\u0007서로\u0007다른\u0007컴퓨터\u0007내 •A ddress부의\u0007주소에\u0007의해\u0007다음\u0007마이크로\u0007명령의\u0007주 부의\u0007주기억장치나\u0007CPU의\u0007레지스터와\u0007외부\u0007입·출 소를\u0007결정한다. 력장치\u0007간의\u00072진\u0007정보를\u0007원활하게\u0007전송하기\u0007위한\u0007방 수직 마이크로 명령(Vertical Micro Instruction) 법을\u0007제공한다. •제 어\u0007메모리\u0007외부에서\u0007디코딩\u0007회로를\u0007필요로\u0007하는\u0007 • 입·출력\u0007인터페이스는\u0007컴퓨터와\u0007각\u0007주변장치와의\u0007 마이크로\u0007명령이다. 다음과\u0007같은\u0007차이점을\u0007해결하는\u0007것이\u0007목적이다. •한 \u0007개의\u0007마이크로\u0007명령으로\u0007한\u0007개의\u0007마이크로\u0007동작 -\u0007\u0007전자기\u0007혹은\u0007기계적인\u0007주변장치와\u0007전자적인\u0007CPU 만\u0007제어할\u0007수\u0007있다. 나\u0007메모리\u0007간\u0007동작\u0007방식의\u0007차이 •마 이크로\u0007명령어의\u0007비트\u0007수가\u0007감소된다.\u0007 -\u0007주변장치와\u0007CPU\u0007간의\u0007데이터\u0007전송\u0007속도의\u0007차이 40 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 38] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 -\u0007\u0007주변장치의\u0007데이터\u0007코드와\u0007CPU나\u0007메모리의\u0007워드\u0007 스풀링과 버퍼링의 비교 형식의\u0007차이 버퍼링도\u0007입·출력장치와\u0007CPU\u0007간의\u0007속도\u0007차이를\u0007해결 -\u0007\u0007전송\u0007사이클의\u0007길이\u0007등\u0007동작\u0007방식이\u0007서로\u0007다른\u0007주 하기\u0007위해\u0007사용하는\u0007목적은\u0007같지만\u0007다음과\u0007같은\u0007점이\u0007스 변장치들의\u0007간섭\u0007없는\u0007제어 풀링과\u0007다르다. -\u0007전압레벨의\u0007차이 구 분 버퍼링 스풀링 입·출력 버스 저장\u0007위치 주기억장치 보조기억장치 •주 기억장치와\u0007입·출력장치\u0007사이의\u0007데이터\u0007전송을\u0007 위해\u0007모든\u0007주변장치의\u0007인터페이스에\u0007공통으로\u0007연결 운영\u0007방식 단일\u0007작업 다중\u0007작업 된\u0007버스이다. 구현\u0007방식 하드웨어 소프트웨어 •입 ·출력\u0007버스는\u0007데이터\u0007버스,\u0007주소\u0007버스,\u0007제어\u0007 입·출력\u0007방식 큐 큐 버스로\u0007구성된다. 05.5, 05.3, 04.9, 04.3, 03.8, 03.5, 02.5, 02.3, 01.9, 01.6, 00.7, 00.3, 99.10 핵심 14.8, 13.8, 13.6, 13.3, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 09.8, 09.5, 08.9, 08.5, 08.3, 07.5, 07.3, 06.9, 06.5, 06.3, 핵심 05.5 102 입·출력(Input-Output) 제어 방식 100 기억장치와 입·출력장치의 동작 •\u0007원하는\u0007I/O가\u0007완료되었는지의\u0007여부를\u0007검사하기\u0007 기억장치는\u0007처리\u0007속도가\u0007nano(10-9)\u0007단위인\u0007전자적인\u0007장 위해서\u0007CPU가\u0007상태\u0007Flag를\u0007계속\u0007조사하여\u0007I/O가\u0007 치이고,\u0007입·출력장치는\u0007milli(10-3)\u0007단위인\u0007기계적인\u0007장 완료\u0007되었으면\u0007MDR(MBR)과\u0007AC\u0007사이의\u0007자료\u0007전 치이므로\u0007동작\u0007방식에는\u0007많은\u0007차이가\u0007있다. 송을\u0007CPU가\u0007직접\u0007처리하는\u0007I/O\u0007방식 Programmed •\u0007입·출력에\u0007필요한\u0007대부분의\u0007일을\u0007CPU가\u0007해주 I/O 므로\u0007interface는\u0007MDR,\u0007Flag,\u0007장치번호\u0007디코더로 비교 항목 입·출력장치 기억장치 만\u0007구성하면\u0007됨 동작의\u0007속도 느리다 빠르다 •\u0007\u0007I/O\u0007작업\u0007시\u0007CPU는\u0007계속\u0007I/O\u0007작업에\u0007관여해야\u0007하 기\u0007때문에\u0007다른\u0007작업을\u0007할\u0007수\u0007없다는\u0007단점이\u0007있음\u0007 동작의\u0007자율성 타율/자율 타율 •\u0007입·출력을\u0007하기\u0007위해\u0007CPU가\u0007계속\u0007Flag를\u0007검사 정보의\u0007단위 Byte(문자) Word 하지\u0007않고,\u0007데이터를\u0007전송할\u0007준비가\u0007되면\u0007입·출 착오\u0007발생률 많다 적다 력\u0007인터페이스가\u0007컴퓨터에게\u0007알려\u0007입·출력이\u0007 Interrupt 이루어지는\u0007방식 I/O •\u0007입·출력\u0007인터페이스는\u0007CPU에게\u0007인터럽트\u0007신호 를\u0007보내\u0007입·출력이\u0007있음을\u0007알림 핵심 10.5, 07.9, 06.3, 04.9, 03.5, 03.3, 02.9, 99.8 •\u0007CPU가\u0007계속\u0007Flag를\u0007검사하지\u0007않아도\u0007되기\u0007때문 101 스풀링(SPOOLING) 에\u0007Programmed\u0007I/O보다\u0007효율적임 •\u0007입·출력장치가\u0007직접\u0007주기억장치를\u0007접근(Access) • Simultaneous\u0007Peripheral\u0007Operation\u0007On-Line 하여\u0007Data\u0007Block을\u0007입·출력하는\u0007방식으로\u0007입· 의\u0007약자이다. 출력\u0007전송이\u0007CPU의\u0007레지스터를\u0007경유하지\u0007않고\u0007 • 다중\u0007프로그래밍\u0007환경하에서\u0007용량이\u0007크고\u0007신속한\u0007액세 수행됨 •\u0007CPU는\u0007I/O에\u0007필요한\u0007정보를\u0007DMA\u0007제어기에\u0007알려 스가\u0007가능한\u0007디스크를\u0007이용하여\u0007각\u0007사용자\u0007프로그램이\u0007 서\u0007I/O\u0007동작을\u0007개시시킨\u0007후\u0007I/O\u0007동작에\u0007더\u0007이상\u0007간 입·출력할\u0007데이터를\u0007직접\u0007I/O\u0007장치로\u0007보내지\u0007않고\u0007디 섭하지\u0007않고\u0007다른\u0007프로그램을\u0007할당하여\u0007수행함 스크에\u0007모았다가\u0007나중에\u0007한꺼번에\u0007입·출력함으로써\u0007 DMA •\u0007입·출력\u0007자료\u0007전송\u0007시\u0007CPU를\u0007거치지\u0007않기\u0007때문 입·출력장치의\u0007공유\u0007및\u0007상대적으로\u0007느린\u0007입·출력장 (Direct 에\u0007CPU의\u0007부담\u0007없이\u0007보다\u0007빠른\u0007데이터의\u0007전송이\u0007 Memory 가능함\u0007 치의\u0007처리\u0007속도를\u0007보완하는\u0007기법이다. Access)에 •\u0007DMA의\u0007우선순위는\u0007메모리\u0007참조의\u0007경우\u0007중앙처리 • 스풀링은\u0007고속의\u0007CPU와\u0007저속의\u0007입·출력장치가\u0007동시 의한 I/O 장치보다\u0007상대적으로\u0007높음 에\u0007독립적으로\u0007동작하게\u0007하여\u0007높은\u0007효율로\u0007여러\u0007작업 •\u0007인터럽트\u0007신호를\u0007발생시켜\u0007CPU에게\u0007입·출력\u0007종 료를\u0007알림 을\u0007병행\u0007작업할\u0007수\u0007있도록\u0007해줌으로써\u0007다중\u0007프로그래 •\u0007Cycle\u0007Steal\u0007방식을\u0007이용하여\u0007데이터를\u0007전송함 밍\u0007시스템의\u0007성능\u0007향상을\u0007가져올\u0007수\u0007있다. •CPU에서\u0007DMA\u0007제어기로\u0007보내는\u0007자료 • 스풀링은\u0007디스크\u0007일부를\u0007매우\u0007큰\u0007버퍼처럼\u0007사용한다. -\u0007I/O\u0007장치의\u0007주소 -\u0007데이터가\u0007있는\u0007주기억장치의\u0007시작\u0007주소 -\u0007DMA를\u0007시작시키는\u0007명령 41 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 39] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 -\u0007입·출력\u0007하고자\u0007하는\u0007자료의\u0007양 잠깐만요 ! Cycle Steal\u0007 -\u0007입력\u0007또는\u0007출력을\u0007결정하는\u0007명령 •\u0007\u0007데이터\u0007채널(DMA\u0007제어기)과\u0007CPU가\u0007주기억장치를\u0007동시에\u0007Access •DMA의\u0007구성\u0007요소 할\u0007때\u0007우선순위를\u0007데이터\u0007채널에게\u0007주는\u0007방식입니다. -\u0007\u0007인터페이스\u0007회로\u0007:\u0007CPU와\u0007입·출력\u0007장치와의\u0007통 •\u0007\u0007Cycle\u0007Steal은\u0007한\u0007번에\u0007한\u0007데이터\u0007워드를\u0007전송하고\u0007버스의\u0007제어를\u0007 신\u0007담당 CPU에게\u0007돌려줍니다. -\u0007\u0007주소\u0007레지스터(Address\u0007Register)\u0007및\u0007주소\u0007라인\u0007:\u0007 •\u0007\u0007Cycle\u0007Steal을\u0007이용하면\u0007입·출력\u0007자료의\u0007전송을\u0007빠르게\u0007처리해\u0007주 기억장치의\u0007위치\u0007지정을\u0007위한\u0007번지\u0007기억\u0007및\u0007전송 는\u0007장점이\u0007있습니다. -\u0007\u0007워드\u0007카운트\u0007레지스터(Word\u0007Count\u0007Register)\u0007:\u0007전 •\u0007\u0007Cycle\u0007Steal\u0007시\u0007중앙처리장치는\u0007메모리\u0007참조가\u0007필요\u0007없는\u0007오퍼레이 송되어야\u0007할\u0007워드의\u0007수\u0007기억 DMA 션을\u0007계속\u0007수행합니다. -\u0007제어\u0007레지스터(Control\u0007Register)\u0007:\u0007전송\u0007방식\u0007결정 (Direct •\u0007\u0007Interrupt와\u0007Cycle\u0007Steal의\u0007차이점 -\u0007\u0007데이터\u0007레지스터(Data\u0007Register)\u0007:\u0007전송에\u0007사용할\u0007 Memory 자료나\u0007주소를\u0007임시로\u0007기억하는\u0007버퍼\u0007역할을\u0007함 Interrupt Cycle Steal Access)에 •DMA의\u0007전송\u0007절차 의한 I/O 사이클\u0007스틸은\u0007CPU가\u0007내부적으 ❶\u0007CPU가\u0007DMA\u0007제어기에게\u0007명령을\u0007내림 로\u0007명령어를\u0007해독하거나\u0007연산을\u0007 ❷\u0007\u0007DMA\u0007제어기가\u0007CPU에게\u0007버스\u0007사용을\u0007요구함 수행하고\u0007있던\u0007Program은\u0007정 수행하는\u0007등\u0007시스템\u0007버스를\u0007사용 (Bus\u0007Request) 지되지만,\u0007인터럽트\u0007처리\u0007루틴 하지\u0007않는\u0007시간\u0007동안에만\u0007시스템\u0007 ❸\u0007\u0007CPU가\u0007DMA\u0007제어기에게\u0007버스\u0007사용을\u0007허가함 의\u0007명령을\u0007실행하기\u0007위하\u0007 버스를\u0007사용하기\u0007때문에\u0007CPU는\u0007 (Bus\u0007Grant) 여\u0007CPU는\u0007수행\u0007상태에\u0007있게\u0007 메모리\u0007참조가\u0007필요\u0007없는\u0007오퍼레 ❹\u0007\u0007DMA\u0007제어기가\u0007주기억장치에서\u0007데이터를\u0007읽어\u0007 된다. 이션을\u0007계속\u0007수행할\u0007수\u0007있지만\u0007 디스크로\u0007전송함(Data\u0007Transfer) 주기억장치에\u0007접근할\u0007수는\u0007없다. ❺\u0007\u0007❷~❹번을\u0007반복하다가\u0007데이터\u0007전송이\u0007완료되 면\u0007인터럽트(Interrupt)\u0007신호를\u0007보냄 주기억장치\u0007사이클이\u0007정지되 주기억장치\u0007사이클의\u0007한\u0007주기가\u0007 지\u0007않는다. 정지된다. •I\u0007/O를\u0007위한\u0007특별한\u0007명령어를\u0007I/O\u0007프로세서에 게\u0007수행토록\u0007하여\u0007CPU\u0007관여\u0007없이\u0007주기억장치 CPU의\u0007상태\u0007보존이\u0007필요하다. CPU의\u0007상태\u0007보존이\u0007필요\u0007없다. 와\u0007입·출력장치\u0007사이에서\u0007입·출력을\u0007제어하 는\u0007입·출력\u0007전용\u0007프로세서(IOP) •채\u0007 널은\u0007DMA\u0007방법으로\u0007입·출력을\u0007수행하므 02.3, 01.6, 01.3, 00.10, 00.7, 99.8 로\u0007DMA의\u0007확장된\u0007개념으로\u0007볼\u0007수\u0007있음 핵심 14.8, 12.8, 12.3, 10.3, 09.3, 08.5, 08.3, 07.9, 07.3, 06.5, 05.5, 05.4, 05.3, 04.9, 04.5, 04.3, 03.5, 03.3, 02.9, 02.5, •D\u0007MA\u0007제어기의\u0007한계를\u0007극복하기\u0007위하여\u0007고안 103 인터럽트의 종류 및 발생 원인 된\u0007방식임 •채\u0007 널\u0007제어기는\u0007채널\u0007명령어로\u0007작성된\u0007채널\u0007프 • 프로그램을\u0007실행하는\u0007도중에\u0007예기치\u0007않은\u0007상황이\u0007발생 로그램을\u0007해독하고\u0007실행하여\u0007입·출력\u0007동작을\u0007 할\u0007경우\u0007현재\u0007실행중인\u0007작업을\u0007즉시\u0007중단하고,\u0007발생된\u0007 처리함 상황을\u0007우선\u0007처리한\u0007후\u0007실행중이던\u0007작업으로\u0007복귀하여\u0007 •C\u0007PU로부터\u0007입·출력\u0007전송을\u0007위한\u0007명령어를\u0007받 계속\u0007처리하는\u0007것,\u0007일명\u0007“끼어들기”라고도\u0007한다. 으면\u0007CPU와는\u0007독립적으로\u0007동작하여\u0007입·출력 을\u0007완료함 • 인터럽트\u0007서비스\u0007루틴을\u0007실행할\u0007때,\u0007인터럽트\u0007플래그 Channel에 •채\u0007 널은\u0007주기억장치에\u0007기억되어\u0007있는\u0007채널\u0007프 (IF)를\u00070으로\u0007하면\u0007인터럽트\u0007발생을\u0007방지할\u0007수\u0007있다.\u0007 의한 I/O 로그램의\u0007수행과\u0007자료의\u0007전송을\u0007위하여\u0007주기 억장치에\u0007직접\u0007접근함 • 인터럽트는\u0007외부\u0007인터럽트,\u0007내부\u0007인터럽트,\u0007소프트웨어\u0007 •I\u0007/O\u0007장치는\u0007제어장치를\u0007통해\u0007채널과\u0007연결됨 인터럽트로\u0007분류하는데,\u0007외부나\u0007내부\u0007인터럽트는\u0007CPU •I\u0007/O\u0007채널은\u0007CPU의\u0007I/O\u0007명령을\u0007수행하지\u0007않고\u0007 의\u0007하드웨어에서의\u0007신호에\u0007의해\u0007발생하고\u0007소프트웨어\u0007 I/O\u0007채널\u0007내의\u0007특수목적\u0007명령을\u0007수행함 인터럽트는\u0007명령어의\u0007수행에\u0007의해\u0007발생한다. •C\u0007PU와\u0007인터럽트로\u0007통신함 •\u0007채\u0007 널의\u0007종류 -\u0007Selector\u0007Channel\u0007:\u0007고속\u0007입·출력장치(자기\u0007 •\u0007전원 이상 인터럽트(Power Fail Interrupt)\u0007:\u0007정전이\u0007 디스크,\u0007자기\u0007테이프,\u0007자기\u0007드럼)\u00071개와\u0007입· 되거나\u0007전원\u0007이상이\u0007있는\u0007경우 출력하기\u0007위해\u0007사용함 •\u0007기계 착오 인터럽트(Machine Check Interrupt)\u0007:\u0007 -\u0007Multiplexer\u0007Channel\u0007:\u0007저속\u0007입·출력장치(카 CPU의\u0007기능적인\u0007오류\u0007동작이\u0007발생한\u0007경우 드리더,\u0007프린터)\u0007여러\u0007개를\u0007동시에\u0007제어하는\u0007 •외\u0007 부 신호 인터럽트(External Interrupt) 채널.\u0007바이트\u0007멀티플렉서\u0007채널이라고도\u0007함 외부 \u0007\u0007-\u0007타이머에\u0007의해\u0007규정된\u0007시간(Time\u0007Slice)을\u0007알리는\u0007경우 - Block\u0007Multiplexer\u0007Channel\u0007:\u0007동시에\u0007여러\u0007개 인터럽트 \u0007\u0007-\u0007키보드로\u0007인터럽트\u0007키를\u0007누른\u0007경우 의\u0007고속\u0007입·출력장치를\u0007제어함 \u0007\u0007-\u0007외부장치로부터\u0007인터럽트\u0007요청이\u0007있는\u0007경우 •입\u0007 ·출력 인터럽트(Input-Output Interrupt) \u0007\u0007-\u0007입·출력\u0007Data의\u0007오류나\u0007이상\u0007현상이\u0007발생한\u0007경우 \u0007\u0007-\u0007입·출력장치가\u0007데이터의\u0007전송을\u0007요구하거나\u0007전송이\u0007 끝났음을\u0007알릴\u0007경우 42 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 40] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007잘못된\u0007명령이나\u0007데이터를\u0007사용할\u0007때\u0007발생하며,\u0007트랩 잠깐만요 ! \u0007 (Trap)이라고도\u0007부름 프로그램의 상태 보존 •\u0007프로그램 검사 인터럽트(Program Check Interrupt) 인터럽트\u0007발생\u0007시\u0007프로그램의\u0007상태\u0007보존이\u0007필요한\u0007이유는\u0007인터럽트\u0007 내부 \u0007\u0007\u0007-\u00070으로\u0007나누기(Divide\u0007by\u0007zero)가\u0007발생한\u0007경우 서비스를\u0007완료하고\u0007원래\u0007수행\u0007중이던\u0007프로그램으로\u0007복귀하기\u0007위해서 인터럽트 \u0007\u0007\u0007-\u0007Overflow\u0007또는\u0007Underflow가\u0007발생한\u0007경우 입니다. \u0007\u0007\u0007-\u0007프로그램에서\u0007명령어를\u0007잘못\u0007사용한\u0007경우 인터럽트 발생 시 PC의 값 보관 방법 \u0007\u0007\u0007-\u0007부당한\u0007기억장소의\u0007참조와\u0007같은\u0007프로그램의\u0007오류 인터럽트\u0007발생\u0007시\u0007상태를\u0007보존하기\u0007위한\u0007PC의\u0007값은\u0007메모리의\u00070번지,\u0007 •\u0007프로그램\u0007처리\u0007중\u0007명령의\u0007요청에\u0007의해\u0007발생하는\u0007것으 스택,\u0007인터럽트\u0007벡터\u0007중의\u0007한\u0007곳에\u0007저장합니다. 로,\u0007가장\u0007대표적인\u0007형태는\u0007감시\u0007프로그램을\u0007호출하는\u0007 인터럽트 벡터 소프트웨어 SVC(SuperVisor\u0007Call)\u0007인터럽트가\u0007있음 •\u0007중앙처리장치는\u0007인터럽트가\u0007발생한\u0007장치번호를\u0007받은\u0007후에는\u0007해당 인터럽트 •\u0007SVC(SuperVisor Call) 인터럽트 되는\u0007인터럽트\u0007서비스(취급)\u0007루틴으로\u0007분기하게\u0007됩니다.\u0007 \u0007\u0007\u0007-\u0007사용자가\u0007SVC\u0007명령을\u0007써서\u0007의도적으로\u0007호출한\u0007경우 \u0007\u0007\u0007-복잡한\u0007입·출력\u0007처리를\u0007해야\u0007하는\u0007경우 •\u0007이때\u0007기억장치\u0007내의\u0007특정한\u0007곳에는\u0007인터럽트\u0007취급\u0007루틴으로\u0007분기 하는\u0007명령어들만을\u0007기억하는\u0007영역이\u0007있는데,\u0007이를\u0007인터럽트\u0007벡터 라고\u0007합니다. •\u0007인터럽트\u0007벡터에는\u0007인터럽트가\u0007발생했을\u0007때\u0007프로세서의\u0007인터럽트\u0007 핵심 06.9, 04.3, 01.6 서비스가\u0007특정의\u0007장소로\u0007점프하도록\u0007점프할\u0007분기번지가\u0007기억되어\u0007 104 인터럽트 발생 시 CPU가 확인할 사항 있습니다. 인터럽트 체제의 기본 요소 • 프로그램\u0007카운터의\u0007내용 인터럽트\u0007요청\u0007신호,\u0007인터럽트\u0007처리\u0007루틴,\u0007인터럽트\u0007취급\u0007루틴 • 사용한\u0007모든\u0007레지스터의\u0007내용 • 상태\u0007조건의\u0007내용(PSW) 핵심 07.5, 04.5, 03.5, 01.9, 01.3, 00.3 106 인터럽트 우선순위 03.3, 02.5, 02.3, 01.9, 01.6, 99.8 핵심 13.3, 12.8, 11.6, 11.3, 10.9, 09.8, 09.5, 09.3, 08.5, 07.9, 07.3, 06.5, 06.3, 05.9, 05.5, 05.4, 04.9, 04.5, 03.8, 03.5, 105 인터럽트의 동작 순서 • 목적 : 여러\u0007장치에서\u0007동시에\u0007인터럽트가\u0007발생하였을\u0007때\u0007 먼저\u0007서비스할\u0007장치를\u0007결정하기\u0007위해서임 ➊ 인터럽트 요청 신호 발생 • 우선순위(높음 > 낮음) :\u0007전원\u0007이상(Power\u0007Fail)\u0007>\u0007기계\u0007 ➋ 프 로그램 실행을 중단함 : 현재\u0007실행중이던\u0007명령어 착오(Machine\u0007Check)\u0007>\u0007외부\u0007신호(External)\u0007>\u0007 (Micro\u0007Instruction)는\u0007끝까지\u0007실행함 입·출력(I/O)\u0007>\u0007명령어\u0007잘못\u0007>\u0007프로그램\u0007검사 ➌ 현 재의 프로그램 상태를 보존함 : 프로그램\u0007상태는\u0007다음 (Program\u0007Check)\u0007>\u0007SVC(SuperVisor\u0007Call) 에\u0007실행할\u0007명령의\u0007번지로서\u0007PC가\u0007가지고\u0007있음 ➍ 인 터럽트 처리 루틴을 실행함 : 인터럽트를\u0007요청한\u0007장치 03.3, 02.5, 02.3, 01.6, 01.3, 00.10 핵심 13.6, 13.3, 12.8, 11.8, 11.6, 11.3, 10.3, 08.9, 08.5, 08.3, 07.9, 07.3, 06.9, 05.9, 05.4, 05.3, 04.9, 04.5, 04.3, 03.8, 03.5, 를\u0007식별함 107 인터럽트 우선순위 판별 방법 ➎ 인 터럽트 서비스(취급) 루틴을 실행함 •\u0007Interrupt\u0007발생\u0007시\u0007가장\u0007높은\u0007우선순위의\u0007인터럽 • 실질적인\u0007인터럽트를\u0007처리함 트\u0007자원(Source)부터\u0007인터럽트\u0007요청\u0007플래그를\u0007차 례로\u0007검사해서,\u0007우선순위가\u0007가장\u0007높은\u0007Interrupt\u0007 • 현재\u0007처리하는\u0007인터럽트보다\u0007운선순위가\u0007높은\u0007인터럽 자원(Source)을\u0007찾아내어\u0007이에\u0007해당하는\u0007인터럽 트가\u0007발생하면\u0007그\u0007인터럽트를\u0007먼저\u0007처리해야\u0007함 트\u0007서비스\u0007루틴을\u0007수행하는\u0007방식 ➏ 상 태 복구 :\u0007인터럽트\u0007요청\u0007신호가\u0007발생했을\u0007때\u0007보관한\u0007 소프트웨어 •\u0007소프트웨어적인\u0007방식을\u0007폴링이라고\u0007함 적인 방법 : •\u0007우선순위\u0007변경이\u0007쉬우며,\u0007자기디스크와\u0007같이\u0007속 PC의\u0007값을\u0007다시\u0007PC에\u0007저장함 Polling 도가\u0007빠른\u0007장치에\u0007높은\u0007등급을\u0007부여함 ➐ 중 단된 프로그램 실행 재개 :\u0007PC의\u0007값을\u0007이용하여\u0007인터 •\u0007많은\u0007인터럽트가\u0007있을\u0007경우\u0007그들을\u0007모두\u0007조사하 는\u0007데\u0007많은\u0007시간이\u0007걸려\u0007반응\u0007시간이\u0007느리다는\u0007 럽트\u0007발생\u0007이전에\u0007수행중이던\u0007프로그램을\u0007계속\u0007실행함 단점이\u0007있음 •\u0007회로가\u0007간단하고\u0007융통성이\u0007있으며,\u0007별도의\u0007하드 웨어가\u0007필요\u0007없으므로\u0007경제적임 43 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 41] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007CPU와\u0007Interrupt를\u0007요청할\u0007수\u0007있는\u0007장치\u0007사이에\u0007 잠깐만요 ! 기억장치별 접근 속도(빠름 → 느림) 장치번호에\u0007해당하는\u0007버스를\u0007병렬이나\u0007직렬로\u0007연 CPU\u0007레지스터\u0007→\u0007Cache\u0007→\u0007RAM(Main\u0007Memory)\u0007→\u0007ROM\u0007→\u0007자기\u0007코 결하여\u0007요청\u0007장치의\u0007번호를\u0007CPU에\u0007알리는\u0007방식 어\u0007→\u0007자기\u0007디스크\u0007→\u0007자기\u0007테이프 •\u0007벡터\u0007인터럽트\u0007방식에서는\u0007인터럽트를\u0007발생한\u0007 장치가\u0007프로세서에게\u0007분기할\u0007곳에\u0007대한\u0007정보를\u0007 제공하는데,\u0007이\u0007정보를\u0007인터럽트\u0007벡터라\u0007함 •\u0007벡터\u0007인터럽트를\u0007하드웨어\u0007신호에\u0007의하여\u0007수행 핵심 10.9, 07.3, 06.5, 05.9, 00.7 109 ROM(Read Only Memory) 되는\u0007서브루틴이라고도\u0007함 •\u0007장치\u0007판별을\u0007위한\u0007별도의\u0007프로그램\u0007루틴이\u0007없어\u0007 응답\u0007속도가\u0007빠름 • 기억된\u0007내용을\u0007읽을\u0007수만\u0007있는\u0007기억장치로서\u0007일반적으 •\u0007회로가\u0007복잡하고\u0007융통성이\u0007없으며\u0007추가적인\u0007하 로\u0007쓰기는\u0007불가능하다. 드웨어가\u0007필요하므로\u0007비경제적임 하드웨어적인 •\u0007직렬(Serial) 우선순위 부여 방식 : 데이지 체인 • 전원이\u0007꺼져도\u0007기억된\u0007내용이\u0007지워지지\u0007않는\u0007비휘발성\u0007 방법 : (Daisy-Chain) 방식 메모리이다. Vectored -\u0007\u0007인터럽트가\u0007발생하는\u0007모든\u0007장치를\u0007한\u0007개의\u0007회 Interrupt 선에\u0007직렬로\u0007연결함 • 실제로\u0007ROM은\u0007주기억장치로\u0007사용하기보다는\u0007주로\u0007기 -\u0007\u0007우선순위가\u0007높은\u0007장치를\u0007선두에\u0007위치시키고\u0007 본\u0007입·출력\u0007시스템(BIOS),\u0007자가\u0007진단\u0007프로그램 나머지를\u0007우선순위에\u0007따라\u0007차례로\u0007연결함 (POST)\u0007같은\u0007변경\u0007가능성이\u0007희박한\u0007시스템\u0007소프트웨 •\u0007병렬(Parallel) 우선순위 부여 방식 어를\u0007기억시키는\u0007데\u0007이용한다. -\u0007\u0007인터럽트가\u0007발생하는\u0007각\u0007장치를\u0007개별적인\u0007회 선으로\u0007연결함 •ROM의 종류와 특징 -\u0007\u0007우선순위는\u0007Mask\u0007Register의\u0007비트\u0007위치에\u0007의 해서\u0007결정됨 -\u0007\u0007마스크\u0007레지스터는\u0007우선순위가\u0007높은\u0007것이\u0007서 종 류 특 징 비스\u0007받고\u0007있을\u0007때\u0007우선순위가\u0007낮은\u0007것을\u0007비활 제조\u0007공장에서\u0007프로그램화하여\u0007생산한\u0007ROM 성화\u0007시킬\u0007수\u0007있음 Mask ROM 으로,\u0007사용자가\u0007내용을\u0007변경시킬\u0007수\u0007없음 -\u0007\u0007우선순위가\u0007높은\u0007Interrupt는\u0007낮은\u0007Interrupt가\u0007 처리되는\u0007중에도\u0007우선\u0007처리됨 PROM\u0007프로그램\u0007장치라는\u0007특수\u0007장비를\u0007이용 PROM(Programm- 하여\u0007비어\u0007있는\u0007ROM에\u0007사용자가\u0007한\u0007번만\u0007내 able ROM) 용을\u0007기입할\u0007수\u0007있으며,\u0007이후엔\u0007읽기만\u0007가능함 핵심 14.3, 12.5, 12.3, 10.9, 09.3, 08.5, 05.5, 04.3, 03.8, 02.9, 02.3, 01.6, 99.4 •\u0007자외선을\u0007쏘여서\u0007기록한\u0007내용을\u0007지울\u0007수\u0007 108 기억장치의 특성을 결정하는 요소 있고,\u0007PROM\u0007프로그램\u0007장치로\u0007기록할\u0007수 EPROM 도\u0007있음 (Erasable PROM) •\u0007사용자가\u0007여러\u0007번\u0007반복해서\u0007지우거나\u0007기록 기억장치는\u0007무조건\u0007기억\u0007용량이\u0007큰\u0007것을\u0007사용한다 할\u0007수\u0007있음 기억 용량 고\u0007해서\u0007좋은\u0007것이\u0007아니라,\u0007사용\u0007목적에\u0007따라\u0007성능 당\u0007경비\u0007비율이\u0007적은\u0007것을\u0007사용하는\u0007것이\u0007바람직함\u0007 EAROM(Erasable 전기적\u0007특성을\u0007이용하여\u0007기록된\u0007정보의\u0007 Alterable ROM) 일부를\u0007바꿀\u0007수\u0007있는\u0007ROM •\u0007기억장치에\u0007읽기\u0007요청이\u0007발생한\u0007시간부터\u0007요구 한\u0007정보를\u0007꺼내서\u0007사용\u0007가능할\u0007때까지의\u0007시간 전기적인\u0007방법을\u0007이용하여\u0007기록된\u0007내용을\u0007 EEPROM(Electro- Access •\u0007한\u0007Word\u0007단위의\u0007정보를\u0007읽거나\u0007기록하는\u0007데\u0007걸 여러\u0007번\u0007수정하거나\u0007새로운\u0007내용을\u0007기록할\u0007 nic EPROM) Time 리는\u0007시간 수\u0007있는\u0007ROM •\u0007Access\u0007Time\u0007=\u0007Seek\u0007Time\u0007+\u0007Latency\u0007Time\u0007 (또는\u0007Search\u0007Time)\u0007+\u0007Transmission\u0007Time Cycle •\u0007기억장치에\u0007읽기\u0007신호를\u0007보낸\u0007후\u0007다시\u0007읽기\u0007신호 핵심 13.6, 07.3, 04.5, 02.9 를\u0007보낼\u0007수\u0007있을\u0007때까지의\u0007시간\u0007간격 110 RAM(Random Access Memory) Time •\u0007Cycle\u0007Time\u0007≥\u0007Access\u0007Time\u0007\u0007 • 자유롭게\u0007읽고\u0007쓸\u0007수\u0007있는\u0007기억장치로,\u0007RWM(Read\u0007 •\u0007메모리로부터\u0007또는\u0007메모리까지\u00071초\u0007동안\u0007전송되 는\u0007최대한의\u0007정보량으로\u0007기억장치의\u0007자료\u0007처리\u0007 Write\u0007Memory)이라고도\u0007한다. Bandwidth 속도를\u0007나타내는\u0007단위 (대역폭, • RAM에는\u0007현재\u0007사용중인\u0007프로그램이나\u0007데이터가\u0007저장 •\u0007메모리\u0007워드의\u0007길이가\u0007작을수록\u0007대역폭이\u0007좋음 전송률) •\u0007대역폭은\u0007하드웨어의\u0007특성상\u0007주기억장치가\u0007제공 되어\u0007있다. 할\u0007수\u0007있는\u0007정보\u0007전달능력의\u0007한계를\u0007의미함 • 전원이\u0007꺼지면\u0007기억된\u0007내용이\u0007모두\u0007사라지는\u0007휘발성\u0007메 모리이다. 44 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 42] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 일반적으로\u0007‘주기억장치’\u0007또는\u0007‘메모리’라고\u0007하면\u0007램을\u0007 RAM/ROM의 용량 계산 의미한다. • 위\u0007그림에서\u0007RAM은\u0007주소선이\u00077개이고,\u0007Data\u0007Bus가\u0007 • 정보가\u0007저장된\u0007위치는\u0007주소로\u0007구분한다. 8Bit이므로\u0007128(2\u00077)×8Bit의\u0007용량이고,\u0007ROM은\u0007주소 선이\u00079개이고,\u0007Data\u0007Bus가\u000716Bit이므로\u0007512(2\u00079)× • DRAM/SRAM의 특징 16Bit의\u0007용량이다. 동적 램(DRAM) 정적 램(SRAM) • 주소선의\u0007수는\u0007주소를\u0007지정하는\u0007MAR,\u0007그리고\u0007다음에\u0007 구성\u0007소자 콘덴서 플립플롭 실행할\u0007명령의\u0007주소를\u0007가지고\u0007있는\u0007PC의\u0007크기와\u0007같고,\u0007 전원이\u0007공급되어도\u0007일정\u0007 Data\u0007Bus의\u0007비트\u0007수는\u0007읽어온\u0007또는\u0007저장할\u0007자료를\u0007잠 시간이\u0007지나면\u0007전하가\u0007방 전원이\u0007공급되는\u0007동안에 시\u0007보관하는\u0007MBR,\u0007그리고\u0007읽어온\u0007명령어를\u0007저장하는\u0007 특징 전되므로\u0007주기적인\u0007재충 는\u0007기억\u0007내용이\u0007유지\u0007 IR의\u0007크기와\u0007같다. 전(Refresh)이\u0007필요함 • 주소선의\u0007수\u0007=\u0007MAR\u0007=\u0007PC,\u0007 전력\u0007소모 적음 많음 \u0007\u0007\u0007Data\u0007Bus의\u0007비트\u0007수\u0007=\u0007MBR\u0007=\u0007IR 접근\u0007속도 느림 빠름 집적도(밀도) 높음 낮음 핵심 09.3, 05.4, 03.8, 02.9, 00.7, 99.8 가격 저가 고가 112 자기 코어 용도 일반적인\u0007주기억장치 캐시\u0007메모리 • 자기\u0007코어는\u0007전류\u0007일치\u0007기술(Coincident-Current\u0007 Technique)에\u0007의하여\u0007기억장소를\u0007선별한다. 01.6, 01.3 핵심 14.8, 14.5, 14.3, 13.3, 12.3, 11.6, 11.3, 09.8, 08.5, 08.3, 06.9, 06.5, 06.3, 05.9, 05.5, 05.4, 03.5, 03.3, 02.9, 02.3, 01.9, • 자기\u0007코어는\u0007데이터를\u0007읽으면\u0007읽은\u0007내용이\u0007지워지는\u0007파 111 반도체 기억소자의 구성 괴\u0007메모리(DRO\u0007Memory)이므로,\u0007내용을\u0007읽은\u0007후\u0007지 RAM/ROM의 구성 워진\u0007내용을\u0007기록하기\u0007위한\u0007재저장(Restoration\u0007 Time)\u0007시간이\u0007필요하다. RAM은\u0007칩\u0007선택선,\u0007읽기\u0007쓰기\u0007선택선,\u0007주소선,\u0007양방향\u0007 데이터\u0007버스가\u0007있지만\u0007ROM은\u0007읽기만\u0007할\u0007수\u0007있도록\u0007정해 • 자기\u0007코어는\u0007중심을\u0007통과하는\u0007전선에\u0007흐르는\u0007전류의\u0007방 져\u0007있으므로\u0007읽기\u0007쓰기\u0007선택선이\u0007없고,\u0007데이터\u0007버스도\u0007단 향에\u0007따라\u00071\u0007혹은\u00070의\u0007값을\u0007갖는다.\u0007 방향이다.\u0007 • 자기\u0007코어는\u0007부피에\u0007비해\u0007용량이\u0007작고\u0007가격이\u0007비싸\u0007현 재는\u0007거의\u0007사용하지\u0007않는다. (cid:36)(cid:73)(cid:74)(cid:81)(cid:1)(cid:2230)(cid:3094)(cid:1)(cid:18) (cid:36)(cid:52)(cid:18) (cid:36)(cid:73)(cid:74)(cid:81)(cid:1)(cid:2230)(cid:3094)(cid:1)(cid:18) (cid:36)(cid:52)(cid:18) • 자기\u0007코어의\u0007구성 (cid:36)(cid:73)(cid:74)(cid:81)(cid:1)(cid:2230)(cid:3094)(cid:1)(cid:19) (cid:36)(cid:52)(cid:19) (cid:36)(cid:73)(cid:74)(cid:81)(cid:1)(cid:2230)(cid:3094)(cid:1)(cid:19) (cid:36)(cid:52)(cid:19) (cid:18)(cid:19)(cid:25)(cid:131)(cid:25) (cid:22)(cid:18)(cid:19)(cid:131)(cid:18)(cid:23) (cid:51)(cid:70)(cid:66)(cid:69) (cid:51)(cid:37) -구동선(X,\u0007Y)\u00072개\u0007:\u0007번지\u0007선택선 (cid:51)(cid:34)(cid:46) (cid:25)(cid:35)(cid:74)(cid:85)(cid:1)(cid:37)(cid:66)(cid:85)(cid:66)(cid:1) (cid:51)(cid:48)(cid:46) (cid:18)(cid:23)(cid:35)(cid:74)(cid:85)(cid:1)(cid:37)(cid:66)(cid:85)(cid:66)(cid:1) (cid:56)(cid:83)(cid:74)(cid:85)(cid:70) (cid:56)(cid:51) (cid:35)(cid:86)(cid:84) (cid:35)(cid:86)(cid:84) -센스\u0007선\u00071개\u0007:\u0007자기\u0007코어의\u0007상태\u0007검출 (cid:24)(cid:14)(cid:35)(cid:74)(cid:85)(cid:1)(cid:34)(cid:69)(cid:69)(cid:83) (cid:34)(cid:37)(cid:24) (cid:26)(cid:14)(cid:35)(cid:74)(cid:85)(cid:1)(cid:34)(cid:69)(cid:69)(cid:83) (cid:34)(cid:37)(cid:26) (cid:51)(cid:34)(cid:46) (cid:51)(cid:48)(cid:46) -\u0007금지선\u00071개\u0007:\u0007불필요하게\u0007자화되었을\u0007때\u0007금지\u0007전류를\u0007 •C S1, CS2 :\u0007칩\u0007선택선 흘려\u0007자화를\u0007소거시키는\u0007선 •R D :\u0007입력\u0007신호선 •W R : 출력\u0007신호선 핵심 14.8, 14.5, 14.3, 09.8, 07.3, 05.4, 05.3, 02.5, 01.3, 00.7, 00.3, 99.8 113 보조기억장치 •A D : 주소선,\u0007주소선의\u0007수는\u0007지정할\u0007수\u0007있는\u0007워드의\u0007수 를\u0007나타냄.\u0007주소선이\u0007n개라면\u00072n개의\u0007워드를\u0007지정할\u0007수\u0007 보조기억장치의 특징 있음 • 주기억장치에\u0007비해\u0007속도는\u0007느리지만\u0007저장\u0007용량이\u0007크다. •D ata Bus : 워드의\u0007크기를\u0007나타낸다.\u0007데이터\u0007버스가\u0007 • 전원이\u0007차단되어도\u0007내용이\u0007그대로\u0007유지된다. 8Bit라면\u0007워드의\u0007크기가\u00078Bit임 • 중앙처리장치와\u0007직접\u0007자료\u0007교환이\u0007불가능하다.\u0007 • 일반적으로\u0007주기억장치에\u0007데이터를\u0007저장할\u0007때는\u0007DMA\u0007 방식을\u0007사용한다.\u0007 45 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 43] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 보조기억장치의 종류 • 주소에\u0007의해서만\u0007접근이\u0007가능한\u0007기억장치보다\u0007정보\u0007검 색이\u0007신속하다.\u0007 •\u0007순차\u0007처리(SASD)만\u0007할\u0007수\u0007있는\u0007대용량\u0007저장\u0007매체 •\u0007가격이\u0007저렴하고\u0007용량이\u0007커서\u0007자료의\u0007백업용으로\u0007 • 캐시\u0007메모리나\u0007가상\u0007메모리\u0007관리\u0007기법에서\u0007사용하는\u0007 많이\u0007사용함 Mapping\u0007Table에\u0007사용된다. •\u0007\u0007자성\u0007물질이\u0007코팅된\u0007얇은\u0007플라스틱\u0007테이프를\u0007동 자기 테이프 그란\u0007릴에\u0007감아\u0007놓은\u0007형태 • 외부의\u0007인자와\u0007내용을\u0007비교하기\u0007위한\u0007병렬\u0007판독\u0007논리\u0007 •\u0007테이프의\u0007시작과\u0007끝\u0007부분을\u0007알리는\u0007은박지\u0007사이 회로를\u0007갖고\u0007있기\u0007때문에\u0007하드웨어\u0007비용이\u0007증가한다.\u0007 의\u0007정보\u0007저장\u0007부분을\u00077~9트랙으로\u0007구성함 •\u0007트랙별로\u00071비트를\u0007저장하므로\u0007동시에\u00077~9비트를\u0007 읽거나\u0007쓸\u0007수\u0007있음 핵심 14.8, 14.5, 14.3, 12.5, 11.6, 11.3, 10.5, 09.5, 09.3, 07.9, 07.5, 07.3, 06.9, 03.5, 00.10, 99.8, 99.4 •\u0007자성\u0007물질을\u0007입힌\u0007금속\u0007원판을\u0007여러\u0007장\u0007겹쳐서\u0007 116 메모리 인터리빙(Memory Interleaving) 만든\u0007기억\u0007매체로\u0007용량이\u0007크고\u0007접근\u0007속도가\u0007빠름 •\u0007순차,\u0007비순차(직접)\u0007처리가\u0007모두\u0007가능한\u0007DASD\u0007 • 여러\u0007개의\u0007독립된\u0007모듈로\u0007이루어진\u0007복수\u0007모듈\u0007메모리와\u0007 (Direct\u0007Access\u0007Storage\u0007Device)\u0007방식으로\u0007데이 CPU\u0007간의\u0007주소\u0007버스가\u0007한\u0007개로만\u0007구성되어\u0007있으면\u0007같 터를\u0007처리함 자기 디스크 •\u0007트랙(Track)\u0007:\u0007디스크\u0007표면에서\u0007회전축(스핀들\u0007모 은\u0007시각에\u0007CPU로부터\u0007여러\u0007모듈들로\u0007동시에\u0007주소를\u0007 (Magnetic 터)을\u0007중심으로\u0007데이터가\u0007기록되는\u0007동심원 전달할\u0007수\u0007없기\u0007때문에,\u0007CPU가\u0007각\u0007모듈로\u0007전송할\u0007주소 Disk) •섹\u0007 터(Sector)\u0007:\u0007Track들을\u0007일정한\u0007크기로\u0007구분한\u0007 를\u0007교대로\u0007분산\u0007배치한\u0007후\u0007차례대로\u0007전송하여\u0007여러\u0007모 부분이며,\u0007정보\u0007기록의\u0007기본\u0007단위임 •실\u0007 린더(Cylinder)\u0007:\u0007서로\u0007다른\u0007면들에\u0007있는\u0007동일\u0007 듈을\u0007병행\u0007접근하는\u0007기법이다. 위치의\u0007Track들의\u0007모임으로,\u0007실린더의\u0007수는\u0007한\u0007 • 중앙처리장치의\u0007쉬는\u0007시간을\u0007줄일\u0007수\u0007있고,\u0007단위시간당\u0007 면의\u0007트랙\u0007수와\u0007동일함 수행할\u0007수\u0007있는\u0007명령어의\u0007수를\u0007증가시킬\u0007수\u0007있다.\u0007 • 이\u0007기억장치를\u0007구성하는\u0007모듈의\u0007수\u0007만큼의\u0007단어들에\u0007동 핵심 09.5, 04.9, 00.10 시\u0007접근이\u0007가능하다.\u0007 114 디스크의 Access Time • 메모리\u0007인터리빙\u0007기법을\u0007사용하면\u0007기억장치의\u0007접근\u0007시 • 디스크\u0007시스템은\u0007디스크\u0007번호,\u0007디스크\u0007표면\u0007번호,\u0007트랙\u0007 간을\u0007효율적으로\u0007높일\u0007수\u0007있으므로\u0007캐시\u0007기억장치,\u0007고 번호,\u0007섹터\u0007번호를\u0007표현하는\u0007번지\u0007Bit를\u0007가지고\u0007디스크 속\u0007DMA\u0007전송\u0007등에서\u0007많이\u0007사용된다. 의\u0007기억공간을\u0007Access한다. 잠깐만요 ! 메모리\u0007인터리빙은\u0007인터리빙,\u0007디스크\u0007인터리빙으로\u0007혼용 • Access\u0007Time\u0007=\u0007Seek\u0007Time\u0007+\u0007Latency\u0007Time\u0007+\u0007 되어\u0007사용됩니다. Transmission\u0007Time • Seek Time(탐색 시간) : R/W\u0007Head가\u0007특정\u0007트랙까지\u0007 핵심 13.8, 13.6, 13.3, 12.5, 11.6, 10.5, 10.3, 08.9, 08.5, 07.3, 06.3, 05.3, 03.5, 02.3, 01.9, 01.6, 01.3, 00.3, 99.8, 99,4 이동하는\u0007데\u0007걸리는\u0007시간 117 캐시 메모리(Cache Memory) • Latency Time(회전 지연 시간, Rotational Delay Time) 또 • CPU의\u0007속도와\u0007메모리의\u0007속도\u0007차이를\u0007줄이기\u0007위해\u0007사 는 Search Time : R/W\u0007Head가\u0007특정\u0007트랙까지\u0007이동한\u0007 용하는\u0007고속\u0007Buffer\u0007Memory이다. 후\u0007디스크가\u0007회전하여\u0007트랙에\u0007포함되어\u0007있는\u0007특정\u0007섹터 • 캐시는\u0007주기억장치와\u0007CPU\u0007사이에\u0007위치한다. 가\u0007R/W\u0007Head까지\u0007도달하는\u0007데\u0007걸리는\u0007시간 • 캐시\u0007메모리는\u0007메모리\u0007계층\u0007구조에서\u0007가장\u0007빠른\u0007소자이 • Transmission Time(전송 시간) :\u0007R/W\u0007Head가\u0007Access 며,\u0007처리\u0007속도가\u0007거의\u0007CPU의\u0007속도와\u0007비슷할\u0007정도이다. 한\u0007Sector와\u0007주기억장치\u0007간의\u0007자료\u0007전송에\u0007걸리는\u0007시간 • 캐시를\u0007사용하면\u0007기억장치를\u0007접근(Access)하는\u0007횟수 가\u0007줄어들기\u0007때문에\u0007컴퓨터의\u0007처리\u0007속도가\u0007향상된다. 핵심 13.6, 10.9, 07.9, 07.3, 05.9, 05.4, 05.3, 04.9, 04.5, 04.3, 03.8, 03.3, 02.5, 01.9, 01.6, 01.3, 00.10 115 연관 기억장치(Associative Memory) • 최근에는\u0007명령어와\u0007데이터를\u0007따로\u0007분리하여\u0007각각의\u0007캐 시\u0007메모리에\u0007저장하는\u0007분리\u0007캐시를\u0007운용하기도\u0007한다.\u0007 • 기억장치에서\u0007자료를\u0007찾을\u0007때\u0007주소에\u0007의해\u0007접근하지\u0007않 분리\u0007캐시를\u0007사용하면\u0007적중률은\u0007떨어지지만\u0007캐시\u0007접근\u0007 고,\u0007기억된\u0007내용의\u0007일부를\u0007이용하여\u0007접근할\u0007수\u0007있는\u0007기 시\u0007충돌을\u0007방지\u0007할\u0007수\u0007있다. 억장치로,\u0007CAM(Content\u0007Addressable\u0007Memory)이 라고도\u0007한다. 46 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 44] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 명령어나\u0007자료를\u0007찾기\u0007위하여\u0007캐시\u0007메모리에\u0007접근하는\u0007 • 주기억장치의\u0007이용률과\u0007다중\u0007프로그래밍의\u0007효율을\u0007높 경우,\u0007원하는\u0007정보가\u0007캐시\u0007메모리에\u0007기억되어\u0007있을\u0007때\u0007 일\u0007수\u0007있다.\u0007 적중(Hit)되었다고\u0007하고,\u0007기억되어\u0007있지\u0007않으면\u0007실패 • 가상\u0007기억장치\u0007기법에서\u0007사용하는\u0007보조기억장치는\u0007디 했다고\u0007한다. 스크\u0007같은\u0007DASD\u0007장치이어야\u0007한다. \u0007\u0007\u0007\u0007 \u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007적중\u0007횟수 • 적중률\u0007=\u0007------------- • 주소의\u0007사용 \u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007총\u0007접근\u0007횟수\u0007 -\u0007가상\u0007기억장치\u0007기법에서는\u0007보조기억장치에\u0007저장된\u0007 매핑 프로세스(Mapping Process) 사용자\u0007프로그램을\u0007블록으로\u0007나누어\u0007블록에\u0007대한\u0007주 • 주기억장치로부터\u0007캐시\u0007메모리로\u0007데이터를\u0007전송하는\u0007 소를\u0007주기억장치와는\u0007별도의\u0007주소로\u0007표현하여\u0007필요\u0007 방법 시\u0007해당\u0007블록만을\u0007주기억장치에\u0007적재한다. • 종류\u0007:\u0007직접(Direct)\u0007매핑,\u0007어소시에이티브(Associ- -\u0007가상\u0007주소(논리\u0007주소)\u0007:\u0007보조기억장치\u0007상의\u0007주소로,\u0007 ative)\u0007매핑,\u0007세트-어소시에이티브(Set-Associative)\u0007 이들\u0007주소의\u0007집합을\u0007주소\u0007공간이라고\u0007한다.\u0007교체\u0007단 매핑 위는\u0007페이지를\u0007사용한다. • 직접\u0007매핑은\u0007같은\u0007인덱스를\u0007가졌지만\u0007다른\u0007tag를\u0007가진\u0007 -\u0007실기억\u0007주소(물리적\u0007주소)\u0007:\u0007주기억장치\u0007상의\u0007주소로\u0007 두\u0007개\u0007이상의\u0007워드가\u0007반복\u0007접근할\u0007경우\u0007적중률이\u0007낮아 물리적\u0007주소라고도\u0007하며,\u0007이들\u0007주소의\u0007집합을\u0007메모리\u0007 질\u0007수\u0007있다. 공간\u0007또는\u0007기억\u0007공간이라\u0007한다.\u0007교체\u0007단위는\u0007블록을\u0007 사용한다. 쓰기 정책 • 페이지\u0007부재(Page\u0007Fault) • 캐시에\u0007저장되어\u0007있는\u0007데이터에\u0007수정이\u0007발생했을\u0007때\u0007그\u0007 수정된\u0007내용을\u0007주기억장치에\u0007갱신하기\u0007위해\u0007시기와\u0007방 -\u0007CPU가\u0007액세스한\u0007가상\u0007페이지가\u0007주기억장치에\u0007없는\u0007 법을\u0007결정하는\u0007것이다. 경우를\u0007말한다. • Write-Through\u0007:\u0007캐시에\u0007쓰기\u0007동작이\u0007이루어질\u0007때마다\u0007 -\u0007Page\u0007Fault가\u0007발생하면\u0007요구된\u0007Page가\u0007주기억장 캐시\u0007메모리와\u0007주기억장치의\u0007내용을\u0007동시에\u0007갱신하는\u0007 치로\u0007옮겨질\u0007때까지\u0007프로그램\u0007수행이\u0007중단된다.\u0007 방식으로,\u0007쓰기\u0007동작에\u0007걸리는\u0007시간이\u0007길다. • 주소\u0007매핑 • Write-Back\u0007:\u0007캐시에\u0007쓰기\u0007동작이\u0007이루어지는\u0007동안은\u0007 -\u0007가상주소를\u0007실기억주소로\u0007변환하는\u0007작업이다. 캐시의\u0007내용만이\u0007갱신되고,\u0007캐시의\u0007내용이\u0007캐시로부터\u0007 -\u0007가상기억장치에\u0007보관\u0007중이던\u0007프로그램을\u0007실행하기\u0007 제거될\u0007때\u0007주기억장치에\u0007복사된다. 위해\u0007주기억장치에\u0007Load했다\u0007하더라도\u0007프로그램을\u0007 • Write-Once\u0007:\u0007캐시에\u0007쓰기\u0007동작이\u0007이루어질\u0007때\u0007한\u0007번만\u0007 구성하는\u0007각\u0007기계명령에\u0007포함된\u0007주소는\u0007가상주소로\u0007 기록하고\u0007이후의\u0007기록은\u0007모두\u0007무시한다. 남아\u0007있기\u0007때문에\u0007CPU에서\u0007주기억장치를\u0007Access하 기\u0007위해서는\u0007가상주소를\u0007실주소로\u0007변환해야\u0007한다. -\u0007주소\u0007매핑에는\u0007사상함수가\u0007사용된다. 핵심 13.8, 13.3, 12.8, 12.3, 11.6, 10.9, 10.3, 08.5, 08.3, 07.5, 05.9, 04.3, 03.3, 01.6, 00.3, 99.10 118 가상 기억장치(Virtual Memory) • 기억\u0007용량이\u0007작은\u0007주기억장치를\u0007마치\u0007큰\u0007용량을\u0007가진\u0007 핵심 14.5, 14.3, 13.6, 11.6, 10.5, 07.3, 06.5, 06.3, 05.4, 99.4 119 플린(Flynn)의 병렬 컴퓨터 분류 것처럼\u0007사용할\u0007수\u0007있도록\u0007하는\u0007운영체제의\u0007메모리\u0007운영\u0007 기법이다. •현재의\u0007보통\u0007컴퓨터\u0007구조임 • 가상\u0007기억장치의\u0007목적은\u0007주기억장치의\u0007용량\u0007확보이다. SISD(Single •명령\u0007하나가\u0007자료\u0007하나를\u0007처리하는\u0007구조임 Instruction •\u0007제어장치가\u0007한\u0007개의\u0007명령을\u0007번역한\u0007후\u0007처리기를\u0007 • 가상\u0007기억장치는\u0007하드웨어적으로\u0007실제로\u0007존재하는\u0007것 stream 작동시켜\u0007명령을\u0007처리할\u0007때\u0007기억장치에서\u0007한\u0007개 이\u0007아니고\u0007소프트웨어적인\u0007방법으로\u0007보조기억장치를\u0007 Single Data 의\u0007자료를\u0007꺼내서\u0007처리함\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007\u0007 stream) 주기억장치처럼\u0007사용하는\u0007것이다. •Pipeline에\u0007의한\u0007시간적\u0007병렬\u0007처리가\u0007가능함 • 사용자\u0007프로그램을\u0007여러\u0007개의\u0007작은\u0007블록으로\u0007나누어서\u0007 보조기억장치\u0007상에\u0007보관해\u0007놓고\u0007프로그램\u0007실행\u0007시\u0007필요 한\u0007부분들만\u0007주기억장치에\u0007적재한다. 47 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 45] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 3과목·운영체제 SIMD(Single •\u0007한\u0007개의\u0007명령으로\u0007여러\u0007Data를\u0007동시에\u0007처리하는\u0007 Instruction 구조임 stream •\u0007다수의\u0007처리기가\u0007한\u0007개의\u0007제어장치에\u0007의해\u0007제어됨 Multi Data •\u0007배열\u0007처리기(Array\u0007Processor)에\u0007의한\u0007동기적\u0007병 핵심 09.5, 08.3, 07.9, 06.5, 06.3, 04.5, 03.3, 02.5, 01.9, 01.6, 00.3, 99.10, 99.4 121 시스템 소프트웨어의 구성 stream) 렬\u0007처리가\u0007가능함 MISD(Multi •\u0007다수의\u0007처리기에\u0007의해\u0007각각의\u0007명령들이\u0007하나의\u0007 •\u0007제어 프로그램(Control Program)\u0007:\u0007시스템\u0007전체의\u0007작동\u0007 Instruction Data를\u0007처리하는\u0007구조임 상태\u0007감시,\u0007작업의\u0007순서\u0007지정(스케줄링),\u0007작업에\u0007사용 stream •\u0007실제로는\u0007사용되지\u0007않는\u0007구조임 Single Data 되는\u0007데이터\u0007관리,\u0007인터럽트\u0007처리\u0007등의\u0007역할을\u0007수행하 •\u0007Pipeline에\u0007의한\u0007비동기적\u0007병렬\u0007처리가\u0007가능함 stream) 는\u0007프로그램 •\u0007다수의\u0007처리기가\u0007각각\u0007다른\u0007명령\u0007흐름과\u0007자료\u0007흐 MIMD(Multi 름을\u0007가지고\u0007여러\u0007개의\u0007자료를\u0007처리하는\u0007구조임 감시(Supervisor) 각종\u0007프로그램의\u0007실행과\u0007시스템\u0007전체의\u0007작동\u0007 Instruction 프로그램 상태를\u0007감시·감독하는\u0007프로그램 •\u0007처리기들의\u0007상호\u0007연결\u0007시\u0007Tightly\u0007Coupled\u0007 stream System을\u0007다중\u0007처리기,\u0007Loosely\u0007Coupled\u0007 어떤\u0007업무를\u0007처리하고\u0007다른\u0007업무로의\u0007이행을\u0007 Multi Data 작업 제어(Job System을\u0007분산\u0007처리\u0007시스템이라\u0007함 자동으로\u0007수행하기\u0007위한\u0007준비\u0007및\u0007그\u0007처리에\u0007 stream) Control) 프로그램 •다중\u0007처리기에\u0007의한\u0007비동기적\u0007병렬\u0007처리가\u0007가능함 대한\u0007완료를\u0007담당하는\u0007프로그램 자료 관리(Data 주기억장치와\u0007보조기억장치\u0007사이의\u0007데이터\u0007 Management) 전송과\u0007보조기억장치의\u0007자료\u0007갱신\u0007및\u0007유지\u0007보 핵심 14.8, 14.5, 13.8, 12.3, 10.9, 10.5, 11.8, 06.5, 04.5, 99.10 프로그램 수\u0007기능을\u0007수행하는\u0007프로그램 120 병렬처리기법 •\u0007처리 프로그램 :\u0007제어\u0007프로그램의\u0007지시를\u0007받아\u0007사용자가\u0007 •\u0007CPU의\u0007처리속도를\u0007높이기\u0007위해\u00072개\u0007이상의\u0007명령 요구한\u0007문제를\u0007해결하기\u0007위한\u0007프로그램 (Instruction)을\u0007동시에\u0007병렬\u0007처리하는\u0007장치로,\u0007분업 화의\u0007원리를\u0007활용하여\u0007시간적\u0007병렬\u0007처리를\u0007함 언어 원시\u0007프로그램을\u0007기계어\u0007형태의\u0007목적\u0007프로 파이프라인 •\u0007입력\u0007태스크(Task)를\u0007입력의\u0007서브\u0007태스크(Sub\u0007 번역(Language 그램으로\u0007번역하는\u0007프로그램(어셈블러,\u0007컴 프로세서 Task)로\u0007나눈\u0007다음\u0007서브\u0007태스크별로\u0007동시에\u0007처리할\u0007 Translate) 프로그램 파일러,\u0007인터프리터) 수\u0007있도록\u0007하여\u0007처리능력을\u0007크게\u0007향상시킴 서비스(Service) 컴퓨터를\u0007효율적으로\u0007사용할\u0007수\u0007있는\u0007사용\u0007 •\u0007명령\u0007인출,\u0007명령\u0007해독,\u0007오퍼랜드\u0007인출,\u0007명령\u0007실행의\u0007 프로그램 빈도가\u0007높은\u0007프로그램 절차를\u0007거침 문제(Problem) 특정\u0007업무\u0007및\u0007해결을\u0007위해\u0007사용자가\u0007작성한\u0007 •\u0007산술\u0007및\u0007논리\u0007연산,\u0007비교,\u0007내적\u0007연산,\u0007최대·최소값\u0007 프로그램 프로그램 구하기\u0007등의\u0007벡터연산\u0007명령을\u0007빠르고\u0007효율적으로\u0007 벡터 수행하도록\u0007구성된\u0007처리기\u0007임 프로세서 •\u0007벡터\u0007처리기에서\u0007사용할\u0007수\u0007있는\u0007알고리즘으로\u0007가 07.3, 05.9, 05.5, 05.4, 05.3, 04.9, 03.8, 03.5, 03.3, 02.9, 02.5, 01.3, 00.10 00.3, 99.4 장\u0007적합한\u0007알고리즘은\u0007Systolic\u0007알고리즘임 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 07.9, 07.5, 122 운영체제의 개요 •\u0007PE(Processing\u0007Element)라고\u0007불리는\u0007다수의\u0007연산기 를\u0007갖는\u0007동기적\u0007병렬\u0007처리기임 •\u0007명령\u0007해독\u0007및\u0007제어는\u0007제어장치가\u0007하고,\u0007PE들은\u0007명 •\u0007컴퓨터\u0007시스템의\u0007자원들을\u0007효율적으로\u0007관리하며,\u0007사용자가\u0007 배열 령\u0007해독\u0007능력이\u0007결여된\u0007수동적\u0007장치로서\u0007명령\u0007처리 컴퓨터를\u0007편리하고\u0007효과적으로\u0007사용할\u0007수\u0007있도록\u0007환경을\u0007제 정의 프로세서 만\u0007함 공하는\u0007여러\u0007프로그램의\u0007모임 •종류：Windows,\u0007MS-DOS,\u0007UNIX,\u0007Linux\u0007등 •\u0007각\u0007PE들은\u0007데이터\u0007운행\u0007연결망에\u0007의해\u0007상호\u0007연결되 어\u0007PE(ALU)들을\u0007중복\u0007이용함으로써\u0007공간적\u0007병렬성 처리\u0007능력(Throughput)\u0007및\u0007신뢰도(Reliability)\u0007향상,\u0007사용\u0007가능도 을\u0007얻을\u0007수\u0007있음 목적 (Availability)\u0007향상,\u0007반환\u0007시간(Turn\u0007Around\u0007Time)\u0007단축 •\u0007기존의\u0007Von\u0007Neumann형인\u0007제어\u0007흐름(Control-Flow)\u0007 •\u0007처리 능력(Throughput)\u0007:\u0007일정\u0007시간\u0007내에\u0007시스템이\u0007처리하 컴퓨터와\u0007반대되는\u0007개념의\u0007컴퓨터\u0007구조임 는\u0007일의\u0007양 •\u0007어떤\u0007Instruction에서\u0007필요한\u0007피연산자가\u0007모두\u0007준비 •\u0007반환 시간(Turn Around Time)\u0007:\u0007시스템에\u0007작업을\u0007의뢰한\u0007 데이터 되었을\u0007때\u0007비로소\u0007그\u0007Instruction을\u0007수행하고,\u0007수행된\u0007 성능 시간부터\u0007처리가\u0007완료될\u0007때까지\u0007걸린\u0007시간 흐름 결과는\u0007그\u0007결과를\u0007필요로\u0007하는\u0007Instruction에\u0007보내주 평가 •\u0007사용 가능도(Availability)\u0007:\u0007시스템을\u0007사용할\u0007필요가\u0007있을\u0007때\u0007 컴퓨터 는\u0007방식임 기준 즉시\u0007사용\u0007가능한\u0007정도\u0007 •\u0007어떤\u0007Instruction이\u0007프로그램\u0007상의\u0007위치와\u0007상관없이\u0007 • 신뢰도(Reliability)\u0007:\u0007시스템이\u0007주어진\u0007문제를\u0007정확하게\u0007해결 그\u0007Instruction이\u0007처리할\u0007피연산자가\u0007모두\u0007준비되기 하는\u0007정도 만\u0007하면\u0007수행되기\u0007때문에\u0007PC가\u0007필요\u0007없음 48 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 46] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •프\u0007 로세스\u0007관리(프로세스\u0007생성과\u0007제거,\u0007중지\u0007및\u0007재수행\u0007등) •\u0007여러\u0007개의\u0007CPU와\u0007하나의\u0007주기억장치를\u0007이 •프로세서,\u0007기억장치,\u0007입·출력장치,\u0007파일\u0007및\u0007정보\u0007등의\u0007자원\u0007관리 용하여\u0007여러\u0007개의\u0007프로그램을\u0007동시에\u0007처리 •\u0007자원의\u0007스케줄링\u0007기능\u0007제공 다중 처리(Multi- 하는\u0007방식 •\u0007사용자와\u0007시스템\u0007간의\u0007편리한\u0007인터페이스\u0007제공 Processing) 시스템 •\u0007하나의\u0007CPU가\u0007고장나더라도\u0007다른\u0007CPU를\u0007 기능 이용하여\u0007업무를\u0007처리할\u0007수\u0007있으므로\u0007시스 •\u0007시스템의\u0007각종\u0007하드웨어와\u0007네트워크\u0007관리·제어 템의\u0007신뢰성과\u0007안정성이\u0007높음 •\u0007시스템의\u0007오류\u0007검사\u0007및\u0007복구,\u0007데이터\u0007관리,\u0007데이터\u0007및\u0007자원\u0007공유 •\u0007자원\u0007보호\u0007기능\u0007제공 •\u0007데이터\u0007발생\u0007즉시,\u0007또는\u0007데이터\u0007처리\u0007요구 •\u0007가상\u0007계산기\u0007기능\u0007제공 가\u0007있는\u0007즉시\u0007처리하여\u0007결과를\u0007산출하는\u0007방 식 실시간 처리(Real Time Processing) •\u0007우주선\u0007운행이나\u0007레이더\u0007추적기,\u0007핵물리학\u0007 04.5, 04.3, 03.5, 02.3, 01.9, 01.6, 00.3, 99.8, 99.4 실험\u0007및\u0007데이터\u0007수집,\u0007전화\u0007교환장치의\u0007제 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 10.9, 10.5, 09.8, 09.3, 08.9, 08.3, 07.9, 06.3, 05.5, 05.4, 시스템 어,\u0007은행의\u0007온라인\u0007업무,\u0007좌석\u0007예약\u0007업무,\u0007인 123 운영체제 운용 기법 및 발달 과정 공위성,\u0007군함\u0007등의\u0007제어\u0007업무\u0007등\u0007시간에\u0007제 한을\u0007두고\u0007수행되어야\u0007하는\u0007작업에\u0007사용됨 운영체제 운용 기법 다중 모드 처리 일괄\u0007처리\u0007시스템,\u0007시분할\u0007시스템,\u0007다중\u0007처리\u0007 •\u0007초기의\u0007컴퓨터\u0007시스템에서\u0007사용된\u0007형태로,\u0007 (Multi Mode 시스템,\u0007실시간\u0007처리\u0007시스템을\u0007한\u0007시스템에서\u0007 일정량\u0007또는\u0007일정\u0007기간\u0007동안\u0007데이터를\u0007모아 Processing) 모두\u0007제공하는\u0007방식 서\u0007한꺼번에\u0007처리하는\u0007방식 •\u0007여러\u0007개의\u0007컴퓨터(프로세서)를\u0007통신\u0007회선으 분산 처리 •\u0007컴퓨터\u0007시스템을\u0007효율적으로\u0007사용할\u0007수\u0007있 로\u0007연결하여\u0007하나의\u0007작업을\u0007처리하는\u0007방식 일괄 처리 (Batch 음 (Distributed •\u0007각\u0007단말장치나\u0007컴퓨터\u0007시스템은\u0007고유의\u0007운 Processing) 시스템 •\u0007사용자\u0007측면에서는\u0007반환(응답)\u0007시간이\u0007늦지 Processing) 시스템 영체제와\u0007CPU,\u0007메모리를\u0007가지고\u0007있음 만\u0007하나의\u0007작업이\u0007모든\u0007자원을\u0007독점하므로\u0007 CPU\u0007유휴\u0007시간이\u0007줄어듦 운영체제 발달 과정 •\u0007급여\u0007계산,\u0007지불\u0007계산,\u0007연말\u0007결산\u0007등의\u0007업무 에\u0007사용됨 일괄 처리 시스템 → 다중 프로그래밍, 다중 처리, 시분할, •\u0007하나의\u0007CPU와\u0007주기억장치를\u0007이용하여\u0007여러\u0007 실시간 처리 시스템 → 다중 모드 → 분산 처리 시스템 다중 프로그래밍 개의\u0007프로그램을\u0007동시에\u0007처리하는\u0007방식 (Multi-Programm- •\u0007하나의\u0007주기억장치에\u00072개\u0007이상의\u0007프로그램 ing) 시스템 을\u0007기억시켜\u0007놓고,\u0007하나의\u0007CPU와\u0007대화하면 핵심 07.3, 01.6, 00.3, 99.4, 99.4 서\u0007동시에\u0007처리한다. 124 컴파일러와 인터프리터 •\u0007여러\u0007명의\u0007사용자가\u0007사용하는\u0007시스템에서\u0007 컴퓨터가\u0007사용자들의\u0007프로그램을\u0007번갈아\u0007 •\u0007고급\u0007언어로\u0007작성된\u0007소스\u0007프로그램\u0007전체를\u0007목적\u0007 가며\u0007처리해\u0007줌으로써\u0007각\u0007사용자에게\u0007독립 프로그램으로\u0007번역한\u0007후,\u0007링킹\u0007작업을\u0007통해\u0007컴퓨 된\u0007컴퓨터를\u0007사용하는\u0007느낌을\u0007주는\u0007것이며,\u0007 터에서\u0007실행\u0007가능한\u0007실행\u0007프로그램을\u0007생성함 라운드\u0007로빈(Round\u0007Robin)\u0007방식이라고도\u0007 컴파일러 •\u0007번역\u0007과정이\u0007번거롭고,\u0007번역\u0007시간이\u0007오래\u0007걸리지 함 만\u0007실행\u0007속도가\u0007빠름 •\u0007여러\u0007사용자가\u0007각자의\u0007단말장치를\u0007통하여\u0007 •\u0007FORTRAN,\u0007COBOL,\u0007PASCAL,\u0007C,\u0007C++,\u0007PL/1\u0007 동시에\u0007운영체제와\u0007대화하면서\u0007각자의\u0007프 등이\u0007컴파일러를\u0007사용함 시분할 로그램을\u0007실행함 (Time Sharing)시스템 •\u0007하나의\u0007CPU는\u0007같은\u0007시점에서\u0007여러\u0007개의\u0007작 •\u0007고급\u0007언어로\u0007작성된\u0007프로그램을\u0007한\u0007줄\u0007단위로\u0007받 업을\u0007동시에\u0007수행할\u0007수\u0007없기\u0007때문에,\u0007CPU 아들여\u0007번역하고,\u0007번역과\u0007동시에\u0007프로그램을\u0007한\u0007 의\u0007전체\u0007사용\u0007시간을\u0007작은\u0007작업\u0007시간량 줄\u0007단위로\u0007즉시\u0007실행시키는\u0007프로그램 (Time\u0007Slice,\u0007Quantum)으로\u0007나누어서\u0007그\u0007시 •\u0007줄\u0007단위로\u0007번역\u0007실행되기\u0007때문에\u0007시분할\u0007시스템에\u0007 간량\u0007동안만\u0007번갈아\u0007가면서\u0007CPU를\u0007할당하 유용함 여\u0007각\u0007작업을\u0007처리함 인터 프리터 •\u0007프로그램이\u0007직접\u0007실행되므로\u0007목적\u0007프로그램이\u0007생 •\u0007다중\u0007프로그래밍\u0007방식과\u0007결합하여\u0007모든\u0007작 성되지\u0007않음 업이\u0007동시에\u0007진행되는\u0007것처럼\u0007대화식\u0007처리 •\u0007번역\u0007속도는\u0007빠르지만\u0007실행\u0007속도는\u0007느림 가\u0007가능함 •\u0007BASIC,\u0007SNOBOL,\u0007LISP,\u0007APL\u0007등이\u0007인터프리터를\u0007 사용함 49 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 47] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.8, 07.3, 04.9, 04.5, 04.3, 03.3, 02.3, 01.3, 00.7, 99.10 •\u0007Compile And Go 로더\u0007:\u0007별도의\u0007로더\u0007없이\u0007언어\u0007번역\u0007프 125 매크로와 매크로 프로세서 로그램이\u0007로더의\u0007기능까지\u0007수행하는\u0007방식(할당,\u0007재배치,\u0007 적재\u0007작업을\u0007모두\u0007언어\u0007번역\u0007프로그램이\u0007담당) • 매크로 : 프로그램 작성 시 한 프로그램 내에서 동일한 •\u0007절대 로더(Absolute Loader)\u0007:\u0007로더의\u0007역할이\u0007축소되어\u0007 코드가 반복될 경우 반복되는 코드를 한 번만 작성하 가장\u0007간단한\u0007프로그램으로\u0007구성되었으며,\u0007목적\u0007프로그램 여 특정 이름으로 정의한 후 그 코드가 필요할 때마다 을\u0007기억\u0007장소에\u0007적재시키는\u0007기능만\u0007수행하는\u0007로더(할당\u0007 종류 및\u0007연결은\u0007프로그래머가,\u0007재배치는\u0007언어\u0007번역\u0007프로그램이\u0007 정의된 이름을 호출하여 사용하는 것으로, 매크로는 담당) 매크로 이름이 호출되면 호출된 횟수만큼 정의된 매크 •\u0007직접 연결 로더(Direct Linking Loader)\u0007:\u0007일반적인\u0007기능 로 코드가 해당 위치에 삽입되어 실행되며, 매크로 정 의\u0007로더로,\u0007로더의\u0007기능\u00074가지를\u0007모두\u0007수행하는\u0007로더 의 내에 또 다른 매크로를 정의할 수 있다. •\u0007동적 적재 로더(Dynamic Loding Loader)\u0007:\u0007프로그램을\u0007 한꺼번에\u0007적재하는\u0007것이\u0007아니라\u0007실행\u0007시\u0007필요한\u0007일부분 • 매크로 프로세서 : 원시 프로그램에 존재하는 매크로 호 만을\u0007적재하는\u0007로더로,\u0007Load-On-Call이라고도\u0007함 출 부분에 매크로(Macro) 프로그램을 삽입하여 확장 된 원시 프로그램을 생성하는 시스템 소프트웨어 핵심 14.8, 14.5, 14.3, 13.8, 12.3, 11.8, 11.3, 10.5, 08.9, 08.5, 07.5, 07.3, 06.9, 04.5, 04.3, 99.10 • 매크로 프로세서 처리 과정 : 매크로 정의 인식 → 매크 127 프로세스 로 정의 저장 → 매크로 호출 인식 → 매크로 확장과 인수(매개 변수) 치환 •프 로세스(Process)는 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램이나, 시스템 00.3 프로그램을 의미하는 것으로, 프로세스는 필요한 각종 핵심 14.8, 13.8, 13.3, 12.5, 11.8, 11.6, 09.8, 09.3, 08.5, 07.5, 06.9, 06.5, 06.3, 05.3, 04.9, 04.3, 03.3, 02.9, 01.6, 01.3, 00.5, 자원을 요구한다. 126 링커 / 로더 •프 로세스의 여러 가지 정의 링커 - 실행중인 프로그램, PCB를 가진 프로그램, 실기억 •언 어 번역 프로그램이 생성한 목적 프로그램들과 라이브 장치에 저장된 프로그램 러리, 또 다른 실행 프로그램(로드 모듈) 등을 연결하여 - 프로세서가 할당되는 실체, 프로시저가 활동중인 것 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어이다. - 비동기적 행위를 일으키는 주체, 지정된 결과를 얻 •연 결 기능만 수행하는 로더의 한 형태로, 링커에 의해 수 기 위한 일련의 계통적 동작 행되는 작업을 링킹(Linking)이라 한다. - 목적 또는 결과에 따라 발생되는 사건들의 과정 로더 - 프로세서가 할당하는 개체로서 디스패치가 가능한 컴퓨터\u0007내부로\u0007정보를\u0007들여오거나,\u0007로드\u0007모듈을\u0007디스크\u0007등 단위 정의 의\u0007보조기억장치로부터\u0007주기억장치에\u0007적재하는\u0007시스템\u0007소 프트웨어 •\u0007할당(Allocation)\u0007:\u0007실행\u0007프로그램을\u0007실행시키기\u0007위해\u0007기 핵심 14.3, 13.6, 12.5, 11.6, 10.9, 09.3, 05.5, 04.5, 03.8, 03.3, 02.5, 01.9, 00.10, 00.3, 99.4 억장치\u0007내에\u0007옮겨놓을\u0007공간을\u0007확보하는\u0007기능 128 PCB(Process Control Block) •\u0007연결(Linking)\u0007:\u0007부프로그램\u0007호출\u0007시\u0007그\u0007부프로그램이\u0007할 당된\u0007기억장소의\u0007시작주소를\u0007호출한\u0007부분에\u0007등록하여\u0007연 • PCB : 운영체제가 프로세스에 대한 중요한 정보를 저 결하는\u0007기능 장해 놓는 곳으로 각 프로세스가 생성될 때마다 고유의 기능 •\u0007재배치(Relocation)\u0007:\u0007디스크\u0007등의\u0007보조기억장치에\u0007저장 PCB가 생성되고, 프로세스가 완료되면 PCB가 제거됨 된\u0007프로그램이\u0007사용하는\u0007각\u0007주소들을\u0007할당된\u0007기억장소의\u0007 실제\u0007주소로\u0007배치시키는\u0007기능 •P CB에 저장되어 있는 정보 : 프로세스의 현재 상태, 포 •\u0007적재(Loading)\u0007:\u0007실행\u0007프로그램을\u0007할당된\u0007기억공간에\u0007실 인터(부모 프로세스에 대한 포인터, 자식 프로세스에 제로\u0007옮기는\u0007기능 대한 포인터, 프로세스가 위치한 메모리에 대한 포인 터, 할당된 자원에 대한 포인터), 프로세스 고유 식별 자, 스케줄링 및 프로세스의 우선순위, CPU 레지스터 정보(누산기, 인덱스 레지스터, 프로그램 카운터 등), 주기억장치 관리 정보, 입·출력 상태 정보, 계정 정보 50 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 48] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.8, 14.3, 12.5, 12.3, 11.6, 11.3, 10.3, 09.8, 08.5, 08.3, 07.9, 06.3, 05.4, 01.3, 00.7, 99.4 •\u0007준비상태\u0007큐에\u0007있는\u0007프로세스가\u0007프로세서를\u0007할당 129 스레드 / 프로세스 상태 전이 받아\u0007실행되는\u0007상태 •\u0007프로세스\u0007수행이\u0007완료되기\u0007전에\u0007프로세스에게\u0007주 스레드(Thread) 실행(Run) 어진\u0007프로세서\u0007할당\u0007시간이\u0007종료(Time\u0007Run\u0007Out) 되면\u0007프로세스는\u0007준비\u0007상태로\u0007전이됨 •하 나의 프로세스 내에서 병행성을 증대시키기 위한 메 •\u0007실행중인\u0007프로세스에\u0007입·출력(I/O)\u0007처리가\u0007필요 커니즘으로 시스템의 여러 자원을 할당받아 실행하는 하면\u0007실행중인\u0007프로세스는\u0007대기\u0007상태로\u0007전이됨 프로그램의 단위이다. 대기(Wait), 입·출력\u0007요구가\u0007발생되어\u0007현재\u0007실행중인\u0007프로세스 •독 립적인 스케줄링의 최소 단위로서, 동일 프로세스 보류, 가\u0007중단되고,\u0007입·출력\u0007처리가\u0007완료될\u0007때까지\u0007대기 블록(Block) 하고\u0007있는\u0007상태 환경에서 서로 독립적인 다중 수행이 가능하다. •스 레드는 독립적인 스케줄링의 최소 단위로서 프로세 프로세스 상태 전이 관련 용어 스의 역할을 담당한다. 준비\u0007상태에서\u0007대기하고\u0007있는\u0007프로세스\u0007중\u0007하나가\u0007 •하 나의 프로세스에 하나의 스레드가 존재하는 경우에 Dispatch 프로세서를\u0007할당받아\u0007실행\u0007상태로\u0007전이되는\u0007과정 는 단일 스레드, 하나 이상의 스레드가 존재하는 경우 입·출력\u0007작업이\u0007완료되어\u0007프로세스가\u0007대기\u0007상태에 에는 다중 스레드라고 한다. Wake-Up 서\u0007준비\u0007상태로\u0007전이되는\u0007과정 •스 레드는 프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 한다. 핵심 11.8, 09.3, 07.5, 07.3, 06.9, 06.5, 05.4, 05.3, 04.9, 03.5, 03.3, 01.6, 00.10, 99.10 •스레드의 분류 130 스케줄링 / 문맥 교환 •\u0007사용자가\u0007만든\u0007라이브러리를\u0007사용하여\u0007스레드를\u0007 • 스케줄링 정의 : 프로세스가 생성되어 실행될 때 필요한 사용자 수준의 운용함 스레드 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업 •속도는\u0007빠르지만\u0007구현이\u0007어려움 • 스케줄링 목적 : 공정성, 처리율 증가, CPU 이용률 증 커널 수준의 •운영체제의\u0007커널에\u0007의해\u0007스레드를\u0007운용함 스레드 •구현은\u0007쉽지만\u0007속도가\u0007느림 가, 우선순위 제도, 오버헤드 최소화, 응답 시간 최소 화, 반환 시간 최소화, 대기 시간 최소화, 균형 있는 자 •스레드 사용의 장점 원의 사용, 무한 연기 회피 - 하나의 프로세스를 여러 개의 스레드로 생성하여 병 • 문맥 교환(Context Switching) : 하나의 프로세스에서 다 행성을 증진시킬 수 있다. 른 프로세스로 CPU가 할당되는 과정에서 발생되는 - 하드웨어, 운영체제의 성능과 응용 프로그램의 처리 것으로, 새로운 프로세스에게 CPU를 할당하기 위해 율을 향상시킬 수 있다. 현재 CPU가 할당된 프로세스의 상태 정보를 저장하 - 응용 프로그램의 응답 시간(Response Time)을 단 고, 새로운 프로세스의 상태 정보를 설정한 후 CPU를 축시킬 수 있다. 할당하여 실행되도록 하는 작업이며, 운영체제에서 Overhead의 발생 요인 중 하나임 - 실행 환경을 공유시켜 기억장소 및 자원의 낭비가 줄어든다. - 공통적으로 접근 가능한 기억장치를 통해 효율적으 로 통신한다. 프로세스의 주요 상태 프로세스가\u0007프로세서를\u0007할당받기\u0007위해\u0007기다리고\u0007있 준비(Ready) 는\u0007상태 51 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 49] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 10.3, 08.9, 07.3, 06.9, 06.5, 03.3, 02.9, 02.3, 01.9, 01.3, 00.3, 99.10, 99.8 •\u0007프로세스에게\u0007일정한\u0007시간을\u0007주어\u0007그\u0007시간\u0007안에\u0007 131 프로세서 스케줄링의 종류 프로세스를\u0007완료하도록\u0007하는\u0007기법 기한부 •\u0007시스템은\u0007프로세스에게\u0007할당할\u0007정확한\u0007시간을\u0007 •\u0007이미\u0007할당된\u0007CPU를\u0007다른\u0007프로세스가\u0007강제로\u0007빼앗아\u0007 (Deadline) 추정해야\u0007하며,\u0007이를\u0007위해서\u0007사용자는\u0007시스템이\u0007 사용할\u0007수\u0007없는\u0007스케줄링\u0007기법 요구한\u0007프로세스에\u0007대한\u0007정확한\u0007정보를\u0007제공해 •\u0007프로세스가\u0007CPU를\u0007할당받으면\u0007해당\u0007프로세스가\u0007완 야\u0007함 료될\u0007때까지\u0007CPU를\u0007사용함 준비상태\u0007큐에서\u0007기다리는\u0007각\u0007프로세스마다\u0007우선순 •\u0007모든\u0007프로세스에\u0007대한\u0007요구를\u0007공정하게\u0007처리할\u0007수\u0007 우선순위 비선점(Non- 위를\u0007부여하여\u0007그\u0007중\u0007가장\u0007높은\u0007프로세스에게\u0007먼저\u0007 있음 (Priority) Preemptive) CPU를\u0007할당하는\u0007기법 •\u0007일괄\u0007처리\u0007방식에\u0007적합하며,\u0007중요한\u0007작업(짧은\u0007작업)이\u0007 스케줄링 중요하지\u0007않은\u0007작업(긴\u0007작업)을\u0007기다리는\u0007경우가\u0007발생 할\u0007수\u0007있음 •\u0007응답\u0007시간\u0007예측이\u0007용이함 핵심 04.5, 04.3, 02.5, 00.10, 00.7 133 에이징(Aging) 기법 •종\u0007 류\u0007:\u0007FCFS(FIFO),\u0007SJF,\u0007우선순위,\u0007HRN,\u0007기한부\u0007등 의\u0007알고리즘\u0007 • 시스템에서 특정 프로세스의 우선순위가 낮아 무한정 •\u0007하나의\u0007프로세스가\u0007CPU를\u0007할당받아\u0007실행\u0007하고\u0007있 기다리게 되는 경우, 한번 양보하거나 기다린 시간에 비 을\u0007때\u0007우선순위가\u0007높은\u0007다른\u0007프로세스가\u0007CPU를\u0007 강제로\u0007빼앗아\u0007사용할\u0007수\u0007있는\u0007스케줄링\u0007기법 례하여 일정 시간이 지나면 우선순위를 한 단계씩 높여 •\u0007우선순위가\u0007높은\u0007프로세스를\u0007빠르게\u0007처리할\u0007수\u0007 가까운 시간 안에 자원을 할당받도록 하는 기법이다. 있음 선점 • SJF나 우선순위 기법에서 발생할 수 있는 무한 연기 •\u0007주로\u0007빠른\u0007응답시간을\u0007요구하는\u0007대화식\u0007시분할\u0007시 (Preemptive) 스템에\u0007사용됨 상태, 기아 상태를 예방할 수 있다. 스케줄링 •\u0007선점으로\u0007인한\u0007많은\u0007오버헤드를\u0007초래함 •\u0007선점을\u0007위해\u0007시간\u0007배당을\u0007위한\u0007인터럽트용\u0007타이머\u0007 클럭(Clock)이\u0007필요함 핵심 14.5, 12.8, 12.5, 10.9, 09.3, 08.5, 08.3, 06.5, 05.5, 04.9, 04.5, 03.8, 03.5, 02.3, 01.9, 01.6, 01.3, 99.10 134 선점 스케줄링의 종류 •종\u0007 류\u0007:\u0007SRT,\u0007선점\u0007우선순위,\u0007RR(Round\u0007Robin),\u0007다 단계\u0007큐,\u0007다단계\u0007피드백\u0007큐\u0007등의\u0007알고리즘\u0007 준비상태\u0007큐의\u0007프로세스들\u0007중에서\u0007우선순위가\u0007 선점 우선순위 가장\u0007높은\u0007프로세스에게\u0007먼저\u0007CPU를\u0007할당하는\u0007 05.3, 04.3, 03.8, 03.5 기법 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 09.8, 09.5, 08.9, 07.9, 07.3, 06.9,06.5, 05.9, 05.5, 132 비선점 스케줄링의 종류 비선점\u0007기법인\u0007SJF\u0007알고리즘을\u0007선점\u0007형태로\u0007변 SRT 경한\u0007기법으로,\u0007현재\u0007실행중인\u0007프로세스의\u0007남은\u0007 (Shortest 시간과\u0007준비상태\u0007큐에\u0007새로\u0007도착한\u0007프로세스의\u0007 FCFS •\u0007준비상태\u0007큐에\u0007도착한\u0007순서에\u0007따라\u0007차례로\u0007CPU Remaining 실행\u0007시간을\u0007비교하여\u0007가장\u0007짧은\u0007실행\u0007시간을\u0007요 (First-Come 를\u0007할당하는\u0007기법 Time) 구하는\u0007프로세스에게\u0007CPU를\u0007할당하는\u0007기법 First-Service) •\u0007먼저\u0007도착한\u0007것이\u0007먼저\u0007처리되어\u0007공평성은\u0007유지 = FIFO(First 되지만\u0007짧은\u0007작업이\u0007긴\u0007작업을,\u0007중요한\u0007작업이\u0007중 •\u0007시분할\u0007시스템(Time\u0007Sharing\u0007System)을\u0007위해\u0007 In First Out) 요하지\u0007않은\u0007작업을\u0007기다리게\u0007됨 고안된\u0007방식으로,\u0007FCFS\u0007알고리즘을\u0007선점\u0007형태 로\u0007변형한\u0007기법 •\u0007실행\u0007시간이\u0007가장\u0007짧은\u0007프로세스에\u0007먼저\u0007CPU를\u0007 SJF •\u0007FCFS(FIFO)\u0007기법과\u0007같이\u0007준비상태\u0007큐에\u0007먼저\u0007 할당하는\u0007기법 (Shortest Job 들어온\u0007프로세스가\u0007먼저\u0007CPU를\u0007할당받지만\u0007 •\u0007가장\u0007적은\u0007평균\u0007대기\u0007시간을\u0007제공하는\u0007최적\u0007알고 First) RR 각\u0007프로세스는\u0007할당된\u0007시간(Time\u0007Slice,\u0007 리즘 (Round Robin) Quantum)\u0007동안만\u0007실행한\u0007후\u0007실행이\u0007완료되지\u0007 •\u0007실행\u0007시간이\u0007긴\u0007프로세스에\u0007불리한\u0007SJF\u0007기법을\u0007 않으면\u0007다음\u0007프로세스에게\u0007CPU를\u0007넘겨주고\u0007 보완하기\u0007위한\u0007것으로,\u0007대기\u0007시간과\u0007서비스(실행)\u0007 준비상태\u0007큐의\u0007가장\u0007뒤로\u0007배치됨 시간을\u0007이용하는\u0007기법 •\u0007할당되는\u0007시간이\u0007클\u0007경우\u0007FCFS\u0007기법과\u0007같아지 HRN(Hightest 대기\u0007시간\u0007+\u0007서비스\u0007시간 고,\u0007할당되는\u0007시간이\u0007작을\u0007경우\u0007문맥\u0007교환\u0007및\u0007 Response- •\u0007우선순위\u0007계산\u0007공식\u0007=\u0007 서비스\u0007시간 오버헤드가\u0007자주\u0007발생됨 ratio Next) •\u0007우선\u0007순위\u0007계산\u0007결과값이\u0007높은\u0007것부터\u0007우선\u0007순위 프로세스를\u0007특정\u0007그룹으로\u0007분류할\u0007수\u0007있을\u0007경우\u0007 가\u0007부여되는데,\u0007대기\u0007시간이\u0007긴\u0007프로세스일\u0007경우\u0007 다단계 큐(Multi 그룹에\u0007따라\u0007각기\u0007다른\u0007준비상태\u0007큐를\u0007사용하는\u0007 계산\u0007결과값이\u0007높게\u0007나옴 level Queue) 기법 52 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 50] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 다단계 피드백 특정\u0007그룹의\u0007준비상태\u0007큐에\u0007들어간\u0007프로세스가\u0007 하드웨어적 Test\u0007&\u0007Set\u0007기법,\u0007Swap\u0007명령어\u0007기법 큐(Multi level 다른\u0007준비상태\u0007큐로\u0007이동할\u0007수\u0007없는\u0007다단계\u0007큐\u0007 구현 방법 Feedback 기법을\u0007준비상태\u0007큐\u0007사이를\u0007이동할\u0007수\u0007있도록\u0007개 Queue) 선한\u0007기법 세마포어(Semaphore) •각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법이다. 핵심 13.3, 10.5, 10.3, 09.8, 09.3, 05.9, 04.3, 03.3, 01.9, 00.7, 00.3 135 임계구역 / 상호 배제 / 세마포어 • E.J.Dijkstra가 제안하였으며, P와 V라는 2개의 연산 에 의해서 동기화를 유지시키고, 상호 배제의 원리를 보 임계 구역(Critical Section) 장한다. • 다중 프로그래밍 운영체제에서 여러 개의 프로세스가 • 여러 개의 프로세스가 동시에 값을 수정하지 못한다. 공유하는 데이터 및 자원에 대하여 어느 한 시점에서는 하나의 프로세스만 자원 또는 데이터를 사용하도록 지 • S는 P와 V 연산으로만 접근 가능한 세마포어 변수로, 정된 공유 자원(영역)을 의미한다. 공유 자원의 개수를 나타내며 0과 1 혹은 0과 양의 값을 가질 수 있다. • 임계 구역에는 하나의 프로세스만 접근할 수 있으며, 해 당 프로세스가 자원을 반납한 후에만 다른 프로세스가 • P 연산 : 자원을 사용하려는 프로세스들의 진입 여부를 자원이나 데이터를 사용할 수 있다. 자원의 개수(S)를 통해 결정하는 것으로, 자원의 개수를 감소시켜(S=S-1) 자원이 점유되었음을 알림(Wait 동 • 임계 구역은 특정 프로세스가 독점할 수 없다. 작) • 임계 구역의 자원이나 데이터는 여러 프로세스가 사용 • V 연산 : 대기중인 프로세스를 깨우는 신호(Wake Up) 해야 하므로 임계 구역 내에서의 작업은 신속하게 이루 로서, 자원의 개수를 증가시켜(S=S+1) 자원이 반납되 어져야 한다. 었음을 알림(Signal 동작) • 프로세스가 임계 구역에 대한 진입을 요청하면 일정 시 간 내에 진입을 허락해야 한다. • 현재 임계 구역에서 실행되는 프로세스가 없다면 잔류 핵심 08.3, 04.9, 04.5, 03.5, 02.5, 01.6, 01.3 136 모니터(Monitor) 영역에서 임계 구역 사용을 기다리고 있는 프로세스의 사용을 허락해야 하며, 그 이외에 있는 프로세스는 임계 •동 기화를 구현하기 위한 특수 프로그램 기법으로 특정 구역에 진입할 수 없다. 공유 자원을 프로세스에게 할당하는 데 필요한 데이터 상호 배제(Mutual Exclusion) 와 이 데이터를 처리하는 프로시저로 구성된다. • 특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 •자 료 추상화와 정보 은폐 개념을 기초로 하며 공유 자 프로세스가 해당 공유 자원을 사용하지 못하게 제어하 원을 할당하기 위한 병행성 구조로 이루어져 있다. 는 기법이다. •모 니터 내의 공유 자원을 사용하려면 프로세스는 반드 • 여러 프로세스가 동시에 공유 자원을 사용하려 할 때 각 시 모니터의 진입부를 호출해야 한다. 프로세스가 번갈아가며 공유 자원을 사용하도록 하는 • 외부의 프로시저는 직접 액세스할 수 없으며, 모니터 것으로 임계 구역을 유지하는 기법이다. 의 경계에서 상호 배제가 시행된다. • 상호 배제 기법을 사용함으로써 임계 구역 내에서는 인터 • 한순간에 하나의 프로세스만 진입하여 자원을 사용할 럽트, 교착상태, 무한반복이 발생되지 않도록 해야 한다. 수 있다. • 상호 배제 구현 기법 •\u00072개의\u0007프로세스\u0007기준\u0007:\u0007데커(Dekker)\u0007알고리즘,\u0007 소프트웨어적 피터슨(Peterson)\u0007알고리즘 구현 방법 •\u0007여러\u0007개의\u0007프로세스\u0007기준\u0007:\u0007Lamport의\u0007빵집\u0007알고 리즘 53 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 51] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 06.9, 06.5, 03.8, 02.5, 01.6, 99.4 •\u0007Dijkstra가\u0007제안한\u0007것으로,\u0007은행에서\u0007모든\u0007고 137 교착 상태(Deadlock) 객의\u0007요구가\u0007충족되도록\u0007현금을\u0007할당하는\u0007데 서\u0007유래한\u0007기법 상호\u0007배제에\u0007의해\u0007나타나는\u0007문제점으로,\u0007둘\u0007이상의\u0007프로세 은행원 알고리즘 •\u0007각\u0007프로세스에게\u0007자원을\u0007할당하여\u0007교착\u0007상태 정의 스들이\u0007자원을\u0007점유한\u0007상태에서\u0007서로\u0007다른\u0007프로세스가\u0007점 가\u0007발생하지\u0007않으며\u0007모든\u0007프로세스가\u0007완료될\u0007 유하고\u0007있는\u0007자원을\u0007요구하며\u0007무한정\u0007기다리는\u0007현상 수\u0007있는\u0007상태를\u0007안전\u0007상태,\u0007교착\u0007상태가\u0007발생 할\u0007수\u0007있는\u0007상태를\u0007불안전\u0007상태라고\u0007함 •상\u0007 호 배제(Mutual Exclusion)\u0007:\u0007한\u0007번에\u0007한\u0007개의\u0007프로세 스만이\u0007공유\u0007자원을\u0007사용할\u0007수\u0007있어야\u0007함 • 발견(Detection) 기법 : 시스템에 교착 상태가 발생했는 •\u0007점유와 대기(Hold & Wait)\u0007:\u0007최소한\u0007하나의\u0007자원을\u0007점유 하고\u0007있으면서\u0007다른\u0007프로세스에\u0007할당되어\u0007사용되고\u0007있는\u0007 지 점검하여 교착 상태에 있는 프로세스와 자원을 발 자원을\u0007추가로\u0007점유하기\u0007위해\u0007대기하는\u0007프로세스가\u0007있어 견하는 것으로, 자원 할당 그래프 등을 사용함 필요 야\u0007함 충분 •\u0007비선점(Non-preemptive)\u0007:\u0007다른\u0007프로세스에\u0007할당된\u0007자 • 회복(Recovery) 기법 : 교착 상태를 일으킨 프로세스를 종 조건 원은\u0007사용이\u0007끝날\u0007때까지\u0007강제로\u0007빼앗을\u0007수\u0007없어야\u0007함 료하거나 교착 상태의 프로세스에 할당된 자원을 선점하 •환\u0007 형 대기(Circular Wait)\u0007:\u0007공유\u0007자원과\u0007공유\u0007자원을\u0007사 여 프로세스나 자원을 회복하는 것 용하기\u0007위해\u0007대기하는\u0007프로세스들이\u0007원형으로\u0007구성되어\u0007 있어\u0007자신에게\u0007할당된\u0007자원을\u0007점유하면서\u0007앞이나\u0007뒤에\u0007 있는\u0007프로세스의\u0007자원을\u0007요구해야\u0007함 06.9, 06.3 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 07.9, 07.3, 139 기억장치 관리 전략 00.10, 99.8 핵심 13.6, 13.3, 12.8, 12.3, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 08.9, 08.5, 08.3, 07.9, 07.5, 06.3, 05.5, 05.4, 05.3, 04.5, 01.3, • 반입(Fetch) 전략 : 보조기억장치에 보관 중인 프로그램 138 교착 상태 해결 방법 이나 데이터를 언제 주기억장치로 적재할 것인지를 결 •예 방(Prevention) 기법 : 교착 상태가 발생되지 않도록 정하는 전략 사전에 시스템을 제어하는 방법으로, 교착 상태 발생 실행\u0007중인\u0007프로그램이\u0007특정\u0007프로그램이나\u0007데이터\u0007등 의 4가지 조건 중에서 어느 하나를 제거(부정)함으로 요구 반입 의\u0007참조를\u0007요구할\u0007때\u0007적재하는\u0007방법 써 수행되며 일반적으로 자원의 낭비가 가장 심함 실행\u0007중인\u0007프로그램에\u0007의해\u0007참조될\u0007프로그램이나\u0007데 예상 반입 이터를\u0007미리\u0007예상하여\u0007적재하는\u0007방법 한\u0007번에\u0007여러\u0007개의\u0007프로세서가\u0007공유\u0007자원을\u0007사용할\u0007 상호 배제 부정 수\u0007있도록\u0007하는\u0007것이지만,\u0007실제로는\u0007구현하지\u0007않음 •배 치(Placement) 전략 : 새로 반입되는 프로그램이나 데 프로세스가\u0007실행되기\u0007전\u0007필요한\u0007모든\u0007자원을\u0007할 이터를 주기억장치의 어디에 위치시킬 것인지를 결정 점유 및 대기 당하여\u0007프로세스\u0007대기를\u0007없애거나\u0007자원이\u0007점유되 부정 하는 전략 지\u0007않은\u0007상태에서만\u0007자원을\u0007요구하도록\u0007함 자원을\u0007점유하고\u0007있는\u0007프로세스가\u0007다른\u0007자원을\u0007 최초 적합 프로그램이나\u0007데이터가\u0007들어갈\u0007수\u0007있는\u0007크기의\u0007빈\u0007영 비선점 부정 요구할\u0007때\u0007점유하고\u0007있는\u0007자원을\u0007반납하고,\u0007요구 (First Fit) 역\u0007중에서\u0007첫\u0007번째\u0007분할\u0007영역에\u0007배치시키는\u0007방법\u0007 한\u0007자원을\u0007사용하기\u0007위해\u0007기다리게\u0007함 프로그램이나\u0007데이터가\u0007들어갈\u0007수\u0007있는\u0007크기의\u0007빈\u0007영 최적 적합 자원을\u0007선형\u0007순서로\u0007분류하여\u0007고유\u0007번호를\u0007할당 역\u0007중에서\u0007단편화를\u0007가장\u0007작게\u0007남기는\u0007분할\u0007영역에\u0007 (Best Fit) 하고,\u0007각\u0007프로세스는\u0007현재\u0007점유한\u0007자원의\u0007고유\u0007번 배치시키는\u0007방법\u0007 환형 대기 부정 호보다\u0007앞이나\u0007뒤\u0007어느\u0007한쪽\u0007방향으로만\u0007자원을\u0007 요구하도록\u0007하는\u0007것 프로그램이나\u0007데이터가\u0007들어갈\u0007수\u0007있는\u0007크기의\u0007빈\u0007영 최악 적합 역\u0007중에서\u0007단편화를\u0007가장\u0007크게\u0007남기는\u0007분할\u0007영역에\u0007 (Worst Fit) 배치시키는\u0007방법 • 회피(Avoidance) 기법 : 교착 상태가 발생할 가능성을 배제하지 않고, 교착 상태가 발생하면 적절히 피해나 • 교체(Replacement) 전략 : 주기억장치의 모든 영역이 가는 방법으로, 주로 은행원 알고리즘(Banker’s 이미 사용중인 상태에서 가상기억장치의 필요한 페이 Algorithm)이 사용됨 지를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인 지를 결정하는 전략으로, FIFO, OPT, LRU, LFU, NUR, SCR 등이 있음 54 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 52] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 12.8, 10.3, 08.5, 08.3, 07.5, 05.9, 05.5, 05.4, 03.8, 02.5, 02.3, 01.3, 00.10, 00.7 • 가상 기억장치 구현 기법 140 단편화 / 단편화 해결 방법 •\u0007가상\u0007기억장치에\u0007보관되어\u0007있는\u0007프로그램과\u0007주기 단편화 억장치의\u0007영역을\u0007동일한\u0007크기로\u0007나눈\u0007후\u0007나눠진\u0007 • 분할된 주기억장치에 프로그램을 할당하고 반납하는 페이징 프로그램(페이지)을\u0007동일하게\u0007나눠진\u0007주기억장치 (Paging) 의\u0007영역(페이지\u0007프레임)에\u0007적재시켜\u0007실행하는\u0007기법 과정을 반복하면서 사용되지 않고 남는 기억장치의 빈 기법 •\u0007외부\u0007단편화는\u0007발생하지\u0007않으나\u0007내부\u0007단편화는\u0007발 공간 조각을 의미한다. 생할\u0007수\u0007있음 •\u0007페이지\u0007맵\u0007테이블이\u0007필요함 • 내부(Internal) 단편화 : 분할된 영역이 할당될 프로그램 의 크기보다 크기 때문에 프로그램이 할당된 후 사용 •\u0007가상\u0007기억장치에\u0007보관되어\u0007있는\u0007프로그램을\u0007다양 한\u0007크기의\u0007논리적인\u0007단위로\u0007나눈\u0007후\u0007주기억장치에\u0007 되지 않고 남아 있는 빈 공간 적재시켜\u0007실행시키는\u0007기법 • 외부(External) 단편화 : 분할된 영역이 할당될 프로그램 •\u0007프로그램을\u0007배열이나\u0007함수\u0007등과\u0007같은\u0007논리적인\u0007 크기로\u0007나눈\u0007단위를\u0007세그먼트라고\u0007하며,\u0007각\u0007세그 의 크기보다 작기 때문에 프로그램이 할당될 수 없어 사 세그먼테이션 먼트는\u0007고유한\u0007이름과\u0007크기를\u0007갖고\u0007있음 용되지 않고 빈 공간으로 남아 있는 분할된 전체 영역 (Segmenta- •\u0007다른\u0007세그먼트에게\u0007할당된\u0007영역을\u0007침범할\u0007수\u0007없으 tion) 기법 단편화 해결 방법 며,\u0007이를\u0007위해\u0007기억장치\u0007보호키(Storage\u0007 Protection\u0007Key)가\u0007필요함 • 통 합(Coalescing) 기법 : 주기억장치 내에 인접해 있는 •\u0007내부\u0007단편화는\u0007발생하지\u0007않으나\u0007외부\u0007단편화는\u0007발 단편화된 공간을 하나의 공간으로 통합하는 작업 생할\u0007수\u0007있음 •\u0007세그먼트\u0007맵\u0007테이블이\u0007필요함 • 압축(Compaction) 기법, 집약 : 주기억장치 내에 분산되 어 있는 단편화된 빈 공간을 결합하여 하나의 큰 가용 • 주소 변환 : 가상 기억장치에 있는 프로그램이 주기억 공간을 만드는 작업으로, 여러 위치에 분산되어 있는 장치에 적재되어 실행될 때 논리적인 가상주소를 물리 단편화된 빈 공간을 주기억장치의 한쪽 끝으로 옮겨서 적인 실기억주소로 변환하는 것으로, 주소 사상 또는 큰 기억공간을 만듦 주소 매핑(Mapping)이라고도 함 핵심 14.3, 11.8, 11.3, 10.5, 09.8, 09.5, 09.3, 08.9, 08.3, 07.9, 06.5, 05.5, 05.3, 04.5, 00.7, 99.10, 99.8 05.5, 05.4 141 가상 기억장치 핵심 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 08.5, 07.9, 07.5, 07.3, 06.9, 06.5, 06.3, 142 페이지 교체 알고리즘 • 보조기억장치(하드디스크)의 일부를 주기억장치처럼 페이지 부재가 발생했을 때 가상 기억장치의 필요한 페 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 이지를 주기억장치에 적재해야 하는데, 이때 주기억장치 용량을 가진 것처럼 사용하는 것으로, 현재 사용되는 의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레 운영체제에서 흔히 사용되는 기법이다. 임을 선택하여 교체할지 결정하는 기법이다. • 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 •\u0007앞으로\u0007가장\u0007오랫동안\u0007사용하지\u0007않을\u0007페이지 사용한다. OPT(OPTimal 를\u0007교체하는\u0007기법 Replacement, • 가상 기억장치에 저장된 프로그램을 실행하려면 가상 •\u0007각\u0007페이지의\u0007호출\u0007순서와\u0007참조\u0007상황을\u0007미리\u0007 최적 교체) 기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 예측해야\u0007하므로\u0007실현\u0007가능성이\u0007희박함 변환 작업(주소 매핑)이 필요하다. •\u0007각\u0007페이지가\u0007주기억장치에\u0007적재될\u0007때마다\u0007그 때의\u0007시간을\u0007기억시켜\u0007가장\u0007먼저\u0007들어와서\u0007 •블 록 단위로 나누어 사용하므로 연속 할당 방식에서 가장\u0007오래\u0007있었던\u0007페이지를\u0007교체하는\u0007기법 발생할 수 있는 단편화를 해결할 수 있다. •\u0007이해하기\u0007쉽고,\u0007프로그래밍\u0007및\u0007설계가\u0007간단함 FIFO(First In •기 억장치의 이용률과 다중 프로그래밍의 효율을 높일 First Out) •\u0007페이지\u0007프레임\u0007수가\u0007많으면\u0007페이지\u0007부재의\u0007 수가\u0007줄어드는\u0007것이\u0007일반적이지만,\u0007페이지\u0007프 수 있다. 레임\u0007수를\u0007증가시켰는데도\u0007불구하고\u0007페이지\u0007 •운 영체제의 설계가 복잡해지고 주소 변환을 위한 테이 부재가\u0007더\u0007많이\u0007일어나는\u0007벨레이디의\u0007모순 (Belady’s\u0007Anomaly)\u0007현상이\u0007발생함 블을 사용하므로 기억장소를 낭비할 수 있다. 55 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 53] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007최근에\u0007가장\u0007오랫동안\u0007사용하지\u0007않은\u0007페이지 핵심 14.8, 13.8, 13.6, 12.5, 10.5, 10.3, 08.5, 07.3, 06.5, 04.9, 04.5, 03.8, 03.5, 03.3, 02.9, 01.9, 01.6, 01.3, 00.7, 00.3, 99.10 144 국부성(Locality, 구역성) 를\u0007교체하는\u0007기법 LRU(Least •\u0007각\u0007페이지마다\u0007계수기나\u0007스택을\u0007두어\u0007현\u0007시 Recently Used) •실 행중인 프로세스가 주기억장치를 참조할 때는 일부 페 점에서\u0007가장\u0007오랫동안\u0007사용하지\u0007않은\u0007즉,\u0007가 장\u0007오래\u0007전에\u0007사용된\u0007페이지를\u0007교체함 이지만 집중적으로 참조하는 성질이 있다는 이론으로 Denning에 의해 증명되었다. •\u0007사용\u0007빈도가\u0007가장\u0007적은\u0007페이지를\u0007교체하는\u0007 LFU(Least 기법 • 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 된다. Frequently •\u0007프로그램\u0007실행\u0007초기에\u0007많이\u0007사용된\u0007페이지가\u0007 • 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법 Used) 그\u0007후로\u0007사용되지\u0007않을\u0007경우에도\u0007프레임을\u0007 계속\u0007차지할\u0007수\u0007있음 중 하나로, 가상 기억장치 관리의 이론적인 근거가 된다. •\u0007최근에\u0007사용하지\u0007않은\u0007페이지를\u0007교체하는\u0007기 • 캐시 메모리 시스템의 이론적 근거이다. 법 • Locality 종류 •\u0007최근의\u0007사용\u0007여부를\u0007확인하기\u0007위해서\u0007각\u0007페 이지마다\u0007참조\u0007비트(Reference\u0007Bit)와\u0007변형\u0007비 •\u0007프로세스가\u0007실행되면서\u0007하나의\u0007페이지를\u0007일정\u0007시 트(Modified\u0007Bit,\u0007Dirty\u0007Bit),\u0007즉\u00072개의\u0007비트가\u0007사 간\u0007동안\u0007집중적으로\u0007액세스하는\u0007현상 용됨 시간 구역성 •\u0007시간 구역성이 이루어지는 기억장소\u0007:\u0007Loop(반복,\u0007 •\u0007참조\u0007비트와\u0007변형\u0007비트의\u0007값에\u0007따라\u0007교체될\u0007 (Temporal NUR(Not Used 순환),\u0007스택(Stack),\u0007부프로그램(Sub\u0007Routine),\u0007 페이지의\u0007순서가\u0007결정됨 Locality) Recently) Counting(1씩\u0007증감),\u0007Totaling(집계)에\u0007사용되는\u0007변 교체\u0007순서 참조\u0007비트 변형\u0007비트 수(기억장소) 1 0 0 •\u0007프로세스\u0007실행\u0007시\u0007일정\u0007위치의\u0007페이지를\u0007집중적으 2 0 1 로\u0007액세스하는\u0007현상 3 1 0 공간 구역성 •\u0007공간 구역성이 이루어지는 기억장소\u0007:\u0007배열\u0007순회 4 1 1 (Spatial (Array\u0007Traversal),\u0007순차적\u0007코드의\u0007실행,\u0007프로그래 Locality) 머들이\u0007관련된\u0007변수(데이터를\u0007저장할\u0007기억장소)들 을\u0007서로\u0007근처에\u0007선언하여\u0007할당되는\u0007기억장소,\u0007같 SCR(Second 가장\u0007오랫동안\u0007주기억장치에\u0007있던\u0007페이지\u0007중\u0007 은\u0007영역에\u0007있는\u0007변수를\u0007참조할\u0007때\u0007사용 Chance 자주\u0007사용되는\u0007페이지의\u0007교체를\u0007방지하기\u0007위한\u0007 Replacement) 것으로,\u0007FIFO\u0007기법의\u0007단점을\u0007보완한\u0007기법\u0007 핵심 14.3, 13.8, 13.6, 08.9, 07.3, 04.5, 03.3, 02.9, 02.5, 00.10, 00.7, 99.8 145 워킹 셋 / 페이지 부재 핵심 14.8, 12.5, 11.8, 11.6, 08.9, 07.5, 06.9, 04.9, 04.3, 03.3, 01.3, 99.4 143 페이지 크기 • 워킹 셋(Working Set) •\u0007페이지의\u0007단편화가\u0007감소되고,\u0007한\u0007개의\u0007페이지 - 프로세스가 일정 시간 동안 자주 참조하는 페이지들 를\u0007주기억장치로\u0007이동하는\u0007시간이\u0007줄어듦 의 집합이다. •\u0007프로세스(프로그램)\u0007수행에\u0007필요한\u0007내용만\u0007주 기억장치에\u0007적재할\u0007수\u0007있고,\u0007Locality(국부성) - 데닝(Denning)이 제안한 프로그램의 움직임에 대한 페이지 크기가 에\u0007더\u0007일치할\u0007수\u0007있기\u0007때문에\u0007기억장치\u0007효율 모델로, 프로그램의 Locality(구역성) 특징을 이용 작을 경우 이\u0007높아짐 한다. •\u0007페이지\u0007정보를\u0007갖는\u0007페이지\u0007맵\u0007테이블의\u0007크 기가\u0007커지고,\u0007매핑\u0007속도가\u0007늦어짐 - 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으 •\u0007디스크\u0007접근\u0007횟수가\u0007많아져서\u0007전체적인\u0007입· 로써 페이지 부재 및 페이지 교체 현상을 줄인다. 출력\u0007시간은\u0007늘어남 - 시간이 지남에 따라 자주 참조하는 페이지들의 집합 •\u0007페이지\u0007정보를\u0007갖는\u0007페이지\u0007맵\u0007테이블의\u0007크 이 변화하기 때문에 워킹 셋은 시간에 따라 바뀌게 기가\u0007작아지고,\u0007매핑\u0007속도가\u0007빨라짐 •\u0007디스크\u0007접근\u0007횟수가\u0007줄어들어\u0007전체적인\u0007입· 된다. 페이지 크기가 출력의\u0007효율성이\u0007증가함 •페 이지 부재는 프로세스 실행 시 참조할 페이지가 주 클 경우 •\u0007페이지의\u0007단편화가\u0007증가되고,\u0007한\u0007개의\u0007페이지 기억장치에 없는 현상이며, 페이지 부재 빈도(PFF; 를\u0007주기억장치로\u0007이동하는\u0007시간이\u0007늘어남 •\u0007프로그램\u0007수행에\u0007불필요한\u0007내용까지도\u0007주기 Page Fault Frequency)는 페이지 부재가 일어나는 억장치에\u0007적재될\u0007수\u0007있음 횟수를 의미한다. 56 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 54] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 페이지 부재 빈도 방식 : 페이지 부재율(Page Fault •\u0007탐색\u0007거리가\u0007가장\u0007짧은\u0007트랙에\u0007대한\u0007요청을\u0007먼 Rate)에 따라 주기억장치에 있는 페이지 프레임의 수 저\u0007서비스하는\u0007기법 •\u0007현재\u0007헤드\u0007위치에서\u0007가장\u0007가까운\u0007거리에\u0007있는\u0007 를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유 SSTF 트랙으로\u0007헤드를\u0007이동시킴 지하는 방식 (Shortest •\u0007FCFS보다\u0007처리량이\u0007많고,\u0007평균\u0007탐색\u0007시간이\u0007짧음 Seek Time •\u0007탐색\u0007패턴이\u0007편중되어\u0007안쪽이나\u0007바깥쪽\u0007트랙이\u0007 01.6, 01.3, 00.7, 99.4 First) 가운데\u0007트랙보다\u0007서비스를\u0007덜\u0007받는\u0007경향이\u0007있 핵심 14.5, 13.8, 13.6, 12.8, 12.5, 10.9, 09.5, 08.5, 08.3, 07.9, 06.9, 06.5, 06.3, 05.4, 04.5, 04.3, 03.5, 03.3, 02.9, 02.3, 01.9, 으며,\u0007헤드에서\u0007멀리\u0007떨어진\u0007요청은\u0007기아\u0007상태 146 스래싱(Thrashing) 가\u0007발생할\u0007수\u0007있음 •처리량이\u0007많은\u0007일괄\u0007처리\u0007시스템에\u0007유용함 •프 로세스의 처리 시간보다 페이지 교체 시간이 더 많 •\u0007SSTF가\u0007갖는\u0007탐색\u0007시간의\u0007편차를\u0007해소하기\u0007위 아지는 현상이다. 한\u0007기법 •다 중 프로그래밍 시스템이나 가상 기억장치를 사용하 •\u0007현재\u0007헤드의\u0007위치에서\u0007진행\u0007방향이\u0007결정되면\u0007 SCAN 탐색\u0007거리가\u0007짧은\u0007순서에\u0007따라\u0007그\u0007방향의\u0007모든\u0007 는 시스템에서 하나의 프로세스 수행 과정중 자주 페 요청을\u0007서비스하고,\u0007끝까지\u0007이동한\u0007후\u0007역방향의\u0007 이지 부재가 발생함으로 인해 나타나는 현상으로 전체 요청\u0007사항을\u0007서비스함 시스템의 성능이 저하된다. •\u0007항상\u0007바깥쪽에서\u0007안쪽으로\u0007움직이면서\u0007가장\u0007짧 은\u0007탐색\u0007거리를\u0007갖는\u0007요청을\u0007서비스하는\u0007기법 • 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용 C-SCAN •\u0007헤드는\u0007트랙의\u0007바깥쪽에서\u0007안쪽으로\u0007한\u0007방향으 률은 어느 특정 시점까지는 높아지지만 다중 프로그래 (Circular 로만\u0007움직이며\u0007서비스하여\u0007끝까지\u0007이동한\u0007후,\u0007 밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 SCAN) 안쪽에\u0007더\u0007이상의\u0007요청이\u0007없으면\u0007헤드는\u0007가장\u0007 이용률은 급격히 감소된다. 바깥쪽의\u0007끝으로\u0007이동한\u0007후\u0007다시\u0007안쪽으로\u0007이 동하면서\u0007요청을\u0007서비스함\u0007 •C PU 이용률을 높이고, 스래싱 현상을 방지하는 방법 SCAN\u0007기법의\u0007무한\u0007대기\u0007발생\u0007가능성을\u0007제거한\u0007 - 다중 프로그래밍의 정도를 적정 수준으로 유지 것으로,\u0007어떤\u0007방향의\u0007진행이\u0007시작될\u0007당시에\u0007대기 N-Step 중이던\u0007요청들만\u0007서비스하고,\u0007진행\u0007도중\u0007도착한\u0007 - 부족한 자원 증설 SCAN 요청들은\u0007한데\u0007모아서\u0007다음의\u0007반대\u0007방향\u0007진행\u0007때\u0007 - 일부 프로세스 중단 서비스하는\u0007기법 - 페이지 부재 빈도(Page Fault Frequency) 조절 •\u0007부하가\u0007매우\u0007큰\u0007항공\u0007예약\u0007시스템을\u0007위해\u0007개발 - Working Set 유지 되었음 •\u0007탐색\u0007시간과\u0007회전\u0007지연\u0007시간을\u0007최적화하기\u0007위 - 적정 프레임 수 제공 에션바흐 한\u0007최초의\u0007기법 (Eschenbach) •\u0007헤드는\u0007C-SCAN처럼\u0007움직이며,\u0007모든\u0007실린더는\u0007 05.9, 05.5 그\u0007실린더에\u0007요청이\u0007있던\u0007없던\u0007간에\u0007전체\u0007트랙 핵심 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.6, 11.3, 10.9, 10.3, 09.8, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 07.3, 06.9, 이\u0007한\u0007바퀴\u0007회전할\u0007동안에\u0007서비스를\u0007받음 147 디스크 스케줄링 •\u0007SLTF는\u0007섹터\u0007큐잉(Sector\u0007Queuing)이라고\u0007하 며,\u0007회전\u0007시간의\u0007최적화를\u0007위해\u0007구현된\u0007기법임 • 사용할 데이터가 디스크 상의 여러 곳에 저장되어 있 SLTF(Shortest •\u0007디스크\u0007대기\u0007큐에\u0007있는\u0007여러\u0007요청을\u0007섹터\u0007위치 을 경우 데이터를 액세스하기 위해 디스크 헤드가 움 Latency Time 에\u0007따라\u0007재정렬하고,\u0007가장\u0007가까운\u0007섹터를\u0007먼저\u0007 직이는 경로를 결정하는 기법이다. First) 서비스함 •\u0007헤드의\u0007이동이\u0007거의\u0007없는\u0007고정\u0007헤드\u0007장치인\u0007드 • 디스크 스케줄링의 목적 : 처리량 최대화, 평균 응답 시 럼과\u0007같은\u0007장치에서\u0007사용됨 간의 최소화, 응답 시간 편차의 최소화 SCAN\u0007기법을\u0007기초로\u0007사용하되\u0007진행\u0007방향의\u0007마지 LOOK 막\u0007요청을\u0007서비스한\u0007후\u0007그\u0007방향의\u0007끝으로\u0007이동하는\u0007 •\u0007가장\u0007간단한\u0007스케줄링으로,\u0007디스크\u0007대기\u0007큐에\u0007 것이\u0007아니라\u0007바로\u0007역방향으로\u0007진행하는\u0007기법 가장\u0007먼저\u0007들어온\u0007트랙에\u0007대한\u0007요청을\u0007먼저\u0007서 FCFS 비스하는\u0007기법 (First Come •\u0007디스크\u0007대기\u0007큐에\u0007들어온\u0007순서대로\u0007서비스하기\u0007 First Service) 때문에\u0007더\u0007높은\u0007우선순위의\u0007요청이\u0007입력되어도\u0007 순서가\u0007바뀌지\u0007않아\u0007공평성이\u0007보장\u0007\u0007 57 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 55] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.3, 12.3, 11.6, 11.3, 10.5, 09.3, 08.9, 07.3, 05.9, 05.5 핵심 11.6, 10.9, 10.5, 09.8, 07.5, 07.3, 06.9, 05.4, 04.9, 04.3, 03.3, 01.9, 99.8 148 파일 / 파일 시스템 150 순차 파일 / 색인 순차 파일 파일 순차 파일(Sequential File) •파 일은 사용자가 작성한 서로 관련 있는 레코드의 집 •레 코드를 논리적인 처리 순서에 따라 연속된 물리적 합체를 의미한다. 저장공간에 기록하는 것이다. • 프로그램 구성의 기본 단위가 되며, 보조기억장치에 •급 여 관리 등과 같이 변동 사항이 크지 않고 기간별로 저장된다. 일괄 처리를 주로 하는 경우에 적합하다. •각 파일마다 이름, 위치, 크기, 작성 시기 등의 여러 속 •주 로 순차 접근이 가능한 자기 테이프에서 사용한다. 성을 가지고 있다. • 장점 : 파일의 구성 용이, 기억공간의 이용 효율 높음, 레 파일 시스템의 기능 코드를 기록할 때 사용한 키 순서대로 레코드를 처리할 경 우 다른 편성법보다 처리 속도가 빠름, 처리비용 절감, 어 • 파일 시스템 : 파일의 저장, 액세스, 공유, 보호 등 보조 떤 기억 매체든 실현 가능 기억장치에서의 파일을 총괄하는 파일 관리 기술 • 단점 : 파일에 새로운 레코드를 삽입하거나 삭제하는 경 • 사용자와 보조기억장치 사이에서 인터페이스를 제공한다. 우 파일 전체를 복사한 후 수행해야 하므로 시간이 많이 •사 용자가 파일을 생성, 수정, 제거할 수 있도록 한다. 걸림, 검색 효율이 낮고, 접근 시간/응답 시간 느림 • 적절한 제어 방식을 통해 타인의 파일을 공동으로 사 색인 순차 파일(Indexed Sequential File) 용할 수 있도록 한다. •순 차 파일과 직접 파일에서 지원하는 편성 방법이 결 • 사용자가 적합한 구조로 파일을 구성할 수 있도록 한다. 합된 형태이다. •불 의의 사태를 대비하여 파일의 예비(Backup)와 복구 • 각 레코드를 키 값 순으로 논리적으로 저장하고, 시스템 (Recovery) 등의 기능을 제공한다. 은 각 레코드의 실제 주소가 저장된 색인을 관리한다. •정 보를 암호화(Encryption)하고 해독(Decrypt)할 수 •레 코드를 참조하려면 색인을 탐색한 후 색인이 가리키 있다. 는 포인터(주소)를 사용하여 직접 참조할 수 있다. • 기본 영역, 색인 영역, 오버플로 영역으로 구성되며, 핵심 14.8, 14.5, 13.8, 12.8, 12.5, 12.3, 11.8, 11.3, 10.9, 10.3, 09.5, 08.5, 08.3, 07.5, 05.9, 04.9, 03.5, 02.9, 01.6, 00.7 색인 영역은 트랙 색인 영역, 실린더 색인 영역, 마스 149 파일 디스크립터(File Descriptor) 터 색인 영역으로 분류된다. • 장점 : 순차 처리와 임의 처리가 모두 가능, 효율적인 •파 일을 관리하기 위해 시스템(운영체제)이 필요로 하 검색 가능, 삭제, 삽입, 갱신이 용이함 는 파일에 대한 정보를 갖고 있는 제어 블록(파일 제어 블록, FCB)이다. • 단점 : 색인이나 오버플로 처리를 위한 추가 기억공간 이 필요함, 접근 시간이 직접 파일보다 느림 • 보통 파일 디스크립터는 보조기억장치 내에 저장되어 있 다가, 해당 파일이 Open될 때 주기억장치로 옮겨진다. • 파일마다 독립적으로 존재하며, 시스템에 따라 다른 핵심 13.8, 13.6, 11.6, 09.3, 08.3, 05.3, 03.5, 00.10 151 직접 파일(Direct File), 직접 접근방식 구조를 가질 수 있다. •파 일 시스템이 관리하므로 사용자가 직접 참조할 수 없다. • 파일을 구성하는 레코드를 임의의 물리적 저장공간에 기 • 파일 디스크립터의 정보 : 파일의 ID번호, 파일 이름, 파 록하는 것이다. 일 크기, 보조기억장치에서의 파일 위치, 파일 구조, • 레코드에 특정 기준으로 키가 할당되며, 해싱 함수 보조기억장치의 유형, 액세스 제어 정보, 파일 유형, (Hashing Function)를 이용하여 이 키에 대한 보조기 생성 날짜와 시간, 제거 날짜와 시간, 최종 수정 날짜 억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 및 시간, 액세스한 횟수 주소에 레코드를 저장한다. 58 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 56] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •레 코드는 해싱 함수에 의해 계산된 물리적 주소를 통해 직 •\u0007트리\u0007구조에\u0007링크(Link)를\u0007첨가시켜\u0007순환을\u0007허용하는\u0007 접 접근이 가능하다. 일반적인 그래프\u0007구조 그래프 •디렉터리와\u0007파일\u0007공유에\u0007완전한\u0007융통성이\u0007있음 • 임의 접근이 가능한 자기 디스크나 자기 드럼을 사용한다. 디렉터리 •\u0007불필요한\u0007파일을\u0007제거하여\u0007사용\u0007공간을\u0007늘리기\u0007위하 • 장점 : 파일의 각 레코드에 직접 접근하거나 기록할 수 있 여\u0007참조\u0007계수기(카운터)가\u0007필요함 음, 접근 시간이 빠르고, 레코드의 삽입, 삭제, 갱신이 용 이함 핵심 14.8, 14.3, 12.8, 12.5, 10.5, 08.3, 07.9, 05.4, 04.5, 03.8, 01.9, 01.7 • 단점 : 레코드의 주소 변환 과정이 필요하며, 이 과정으로 153 자원 보호 기법 인해 시간이 소요됨, 기억공간의 효율이 저하됨, 기억장치 의 물리적 구조에 대한 지식이 필요함 •자 원 보호 기법은 컴퓨터 시스템에서 사용자, 프로세 스 등과 같은 주체가 프로세서, CPU, 기억장치 등과 같은 객체(자원)에 불법적으로 접근하는 것을 제어하 02.3, 01.6, 00.7, 00.3, 99.10 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.3, 11.8, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 07.9, 04.5, 04.3, 02.9, 고, 객체(자원)의 물리적인 손상을 예방하는 것이다. 152 디렉터리의 구조 •자 원 보호 기법의 종류 디렉터리는 파일 시스템 내부에 있는 것으로, 효율적인 - 접근 제어 행렬(Access Control Matrix) : 자원 파일 사용을 위해 디스크에 존재하는 파일에 대한 여러 보호의 일반적인 모델로, 객체에 대한 접근 권한을 정보를 가지고 있는 특수한 형태의 파일이다. 행렬로써 표시한 기법 •\u0007가장\u0007간단하고,\u0007모든\u0007파일이\u0007하나의\u0007디렉터리\u0007내에\u0007위 - 전역 테이블(Global Table) : 가장 단순한 구현 방 치하여\u0007관리되는\u0007구조 법으로, 3개의 순서쌍인 영역, 객체, 접근 권한의 집 1단계 •모든\u0007파일들이\u0007유일한\u0007이름을\u0007가지고\u0007있어야\u0007함 합을 목록 형태로 구성한 기법 디렉터리 •\u0007모든\u0007파일이\u0007같은\u0007디렉터리\u0007내에\u0007유지되므로\u0007이해가\u0007 용이하지만,\u0007파일의\u0007수나\u0007사용자의\u0007수가\u0007증가하면\u0007파 - 접근 제어 리스트(Access Control List) : 접근 제 일\u0007관리가\u0007복잡해짐 어 행렬에 있는 각 열, 즉 객체를 중심으로 접근 리 •\u0007중앙에\u0007마스터\u0007파일\u0007디렉터리(MFD)가\u0007있고,\u0007그\u0007아래 스트를 구성한 기법 에\u0007사용자별로\u0007서로\u0007다른\u0007파일\u0007디렉터리(UFD)가\u0007있는\u0007 - 권한(자격) 리스트(Capability List) : 접근 제어 행 2\u0007계층\u0007구조 2단계 •\u0007마스터\u0007파일\u0007디렉터리는\u0007사용자\u0007파일\u0007디렉터리를\u0007관 렬에 있는 각 행, 즉 영역을 중심으로 구성한 것으로 디렉터리 리하고,\u0007사용자\u0007파일\u0007디렉터리는\u0007사용자별\u0007파일을\u0007관 서 각 사용자에 대한 자격들로 구성되며, 자격은 객 리함 체와 그 객체에 허용된 연산 리스트임 •\u0007서로\u0007다른\u0007디렉터리에서는\u0007동일한\u0007파일\u0007이름을\u0007사용 할\u0007수\u0007있음 •\u0007하나의\u0007루트\u0007디렉터리와\u0007여러\u0007개의\u0007종속(서브)\u0007디렉터 핵심 13.6, 12.5, 11.3, 10.3, 09.8 리로\u0007구성된\u0007구조 154 보안 •\u0007DOS,\u0007Windows,\u0007UNIX\u0007등의\u0007운영체제에서\u0007사용되는\u0007 디렉터리\u0007구조 보안의 정의 트리 •동일한\u0007이름의\u0007파일이나\u0007디렉터리를\u0007생성할\u0007수\u0007있음 디렉터리 • 보안은 컴퓨터 시스템 내에 있는 프로그램과 데이터에 •디렉터리의\u0007생성과\u0007파괴가\u0007비교적\u0007용이함 대하여 통제된 접근 방식을 어떻게 제공할 것인가를 •\u0007각\u0007디렉터리는\u0007서브\u0007디렉터리나\u0007파일을\u0007가질\u0007수\u0007있음\u0007 •\u0007포인터를\u0007사용하여\u0007디렉터리를\u0007탐색하며,\u0007경로명은\u0007절대\u0007 다루는 것이다. 경로명과\u0007상대\u0007경로명을\u0007사용함 • 물리적, 환경적 취약점을 이용한 침입, 방해, 절도 등 •\u0007하위\u0007파일이나\u0007하위\u0007디렉터리를\u0007공동으로\u0007사용할\u0007수\u0007 의 행위로부터 컴퓨터 시스템 내의 자원을 보호하고 있는\u0007것으로,\u0007사이클이\u0007허용되지\u0007않는\u0007구조 비순환 대응하기 위한 일련의 정책과 행위를 말한다. •\u0007하나의\u0007파일이나\u0007디렉터리가\u0007여러\u0007개의\u0007경로\u0007이름을\u0007 그래프 가질\u0007수\u0007있음 • 컴퓨터 시스템에 의해 정의된 자원에 대하여 프로그 디렉터리 •\u0007공유된\u0007파일을\u0007삭제할\u0007경우\u0007고아\u0007포인터(Dangling\u0007 램, 프로세스 또는 사용자의 허용된 권한 외의 접근 Pointer)가\u0007발생할\u0007수\u0007있음 을 제한하여 자원의 손상 및 유출 등을 방지하는 기법 이다. 59 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 57] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 보안의 요건 핵심 05.5, 00.10 156 암호화 기법 • 기밀성(Confidentiality, 비밀성) : 시스템 내의 정보와 자 원은 인가된 사용자에게만 접근이 허용되며, 정보가 •데 이터를 보낼 때 송신자가 지정한 수신자 이외에는 전송중에 노출되더라도 데이터를 읽을 수 없음 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것이다. • 무결성(Integrity) : 시스템 내의 정보는 오직 인가된 사용 자만 수정할 수 있음 •비 밀키 시스템(Private Key System, 개인키 시스템) : 동 일한 키로 데이터를 암호화하고, 해독(복호화)하는 대 • 가용성(Availability) : 인가받은 사용자는 언제라도 사용 칭 암호화 기법으로, 대표적인 암호화 방식에는 DES 할 수 있음 가 있음 • 인증(Authentication) : 시스템 내의 정보와 자원을 사용 • 공용키 시스템(Public Key System, 공개키 시스템) : 서로 하려는 사용자가 합법적인 사용자인지를 확인하는 모 다른 키로 데이터를 암호화하고, 해독하는 비대칭 암 든 행위를 말하며, 대표적인 방법으로는 패스워드, 인 호화 기법으로, 대표적인 암호화 방식에는 RSA가 있 증용 카드, 지문 검사 등이 있음 으며 키의 분배가 용이함 • 부인 방지(NonRepudiation) : 데이터를 송·수신한 자가 송·수신 사실을 부인할 수 없도록 송·수신 증거를 제공함 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 11.8, 11.6, 10.5, 10.3, 09.8, 08.5, 03.8, 00.3 157 프로세서 연결 방식 핵심 14.5, 13.3, 11.8, 10.9, 09.5, 08.5, 07.5, 06.9, 06.5, 05.9, 05.3, 04.9, 03.5, 02.5, 02.3, 01.6 •\u0007프로세서,\u0007주변장치,\u0007기억장치\u0007등의\u0007각종\u0007장치들 155 파일 보호 기법 / 보안 유지 기법 을\u0007‘버스’라는\u0007단일\u0007경로로\u0007연결한\u0007방식 시분할 및 •\u0007장치\u0007연결이\u0007단순하고,\u0007경제적이며,\u0007융통성이\u0007있 공유 버스 파일 보호 기법 으며\u0007장치\u0007추가가\u0007용이함 •\u0007한\u0007시점에서는\u0007하나의\u0007전송만이\u0007가능함 • 파일 보호 기법은 파일에 대한 일방적인 접근과 손상 및 파괴를 방지하기 위한 기법이다. •\u0007시분할\u0007및\u0007공유\u0007버스\u0007방식에서\u0007버스의\u0007수를\u0007기 억장치\u0007수만큼\u0007증가시켜\u0007연결한\u0007방식 • 파일 보호 기법의 종류 크로스바 교환 •\u0007\u0007각\u0007기억장치마다\u0007다른\u0007경로를\u0007사용할\u0007수\u0007있으 - 파일의 명명(Naming) : 접근하고자 하는 파일 이름 행렬 며,\u0007두\u0007개의\u0007서로\u0007다른\u0007기억장치를\u0007동시에\u0007참조 할\u0007수\u0007있음 을 모르는 사용자를 접근 대상에서 제외시키는 기법 •\u0007\u0007장치의\u0007연결이\u0007복잡해짐 - 비밀번호(Password, 암호) : 각 파일에 판독 암호 •\u0007다수의\u0007프로세서들을\u0007연결하는\u0007방식으로\u0007비교 와 기록 암호를 부여하여 암호를 아는 사용자에게만 적\u0007경제적인\u0007방식임 접근을 허용하는 기법 •\u00074개의\u0007프로세서를\u00072개씩\u0007서로\u0007이웃하게\u0007연결한\u0007 사각형\u0007모양의\u00072차원\u0007하이퍼\u0007큐브를\u0007만들고,\u00072 - 접근 제어(Access Control) : 사용자에 따라 공유 차원\u0007하이퍼\u0007큐브의\u0007대응점을\u0007각각\u0007연결하여\u00073 데이터에 접근할 수 있는 권한을 제한하는 방법 차원\u0007하이퍼\u0007큐브를\u0007형성하고,\u0007이런\u0007형식으로\u00074 하이퍼 큐브 차원,\u00075차원\u0007…\u0007하이퍼\u0007큐브를\u0007형성함 보안 유지 기법 •\u0007다수의\u0007프로세서를\u0007연결할\u0007수\u0007있으며,\u0007확장성이\u0007 좋음 •\u0007시설 보안\u0007:\u0007천재지변이나\u0007외부\u0007침입자로부터 •\u0007하나의\u0007프로세서에\u0007연결되는\u0007다른\u0007프로세서의\u0007 의\u0007보안 외부 보안 수(연결점)가\u0007n개일\u0007경우\u0007프로세서는\u0007총\u00072n개가\u0007 •\u0007운용 보안\u0007:\u0007전산소\u0007관리\u0007및\u0007경영자들의\u0007정책 필요함 과\u0007통제에\u0007의해\u0007이루어지는\u0007보안 •\u0007시분할\u0007및\u0007공유\u0007버스\u0007방식과\u0007크로스바\u0007교환\u0007행 운영체제가\u0007사용자의\u0007신원을\u0007확인한\u0007후\u0007권한이\u0007 사용자 렬\u0007방식을\u0007혼합한\u0007형태의\u0007방식 있는\u0007사용자에게만\u0007시스템의\u0007프로그램과\u0007데이 다중 포트 인터페이스 보안 •\u0007많은\u0007수의\u0007프로세서를\u0007쉽게\u0007연결할\u0007수\u0007있음 터를\u0007사용할\u0007수\u0007있게\u0007하는\u0007보안\u0007기법 기억장치 •\u0007다양한\u0007연결이\u0007가능하며,\u0007전송\u0007시간이\u0007비교적\u0007 하드웨어나\u0007운영체제의\u0007내장된\u0007보안\u0007기능을\u0007이 느림 내부 보안 용하여\u0007시스템의\u0007신뢰성을\u0007유지하고,\u0007보안\u0007문제 를\u0007해결하는\u0007기법 60 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 58] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 99.10, 99.4 핵심 14.5, 14.3, 13.8, 13.6, 13.3, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.5, 08.9, 08.5, 08.3, 07.9, 07.5, 06.9, 04.3, 02.9, •\u0007동일\u0007운영체제하에서\u0007여러\u0007개의\u0007프로세서가\u0007하나의\u0007 158 다중 처리기의 운영체제 구조 메모리를\u0007공유하여\u0007사용하는\u0007시스템으로,\u0007다중\u0007처리\u0007 시스템이라고도\u0007함 •\u0007하나의\u0007프로세서를\u0007Master(주프로세서)로\u0007지정 강결합 •\u0007하나의\u0007운영체제가\u0007모든\u0007프로세서와\u0007시스템\u0007하드웨 하고,\u0007나머지들은\u0007Slave(종프로세서)로\u0007지정하는\u0007 (밀결합, 어를\u0007제어함 비대칭\u0007구조 Tightly •\u0007프로세서\u0007간의\u0007통신은\u0007공유\u0007메모리를\u0007통해서\u0007이루 주/종 처리기 •\u0007주프로세서가\u0007고장나면\u0007전체\u0007시스템이\u0007다운됨 Coupled) 어짐 •\u0007주프로세서\u0007:\u0007입·출력과\u0007연산\u0007담당,\u0007운영체제\u0007 시스템 •\u0007하나의\u0007메모리를\u0007사용하므로\u0007CPU\u0007간의\u0007결합력이\u0007 수행 강함 •\u0007종프로세서\u0007:\u0007연산만\u0007담당 •\u0007공유\u0007메모리를\u0007차지하려는\u0007프로세서\u0007간의\u0007경쟁을\u0007최 소화해야\u0007함 •\u0007주/종\u0007처리기의\u0007비대칭성을\u0007보완하여\u0007각\u0007프로세 서가\u0007독자적인\u0007운영체제를\u0007가지고\u0007있도록\u0007구성 한\u0007구조 03.5, 03.3, 02.9, 02.5, 02.3, 01.9, 01.6, 01.3, 00.7, 99.10, 99.4 분리 실행 •\u0007\u0007각\u0007프로세서에서\u0007발생하는\u0007인터럽트는\u0007해당\u0007프 핵심 14.8, 14.5, 13.3, 12.8, 12.3, 11.8, 11.6, 10.9, 10.3, 09.8, 09.5, 09.3, 08.9, 07.5, 07.3, 06.5, 06.3, 05.9, 05.4, 05.3, 04.9, 처리기 로세서에서\u0007해결 160 분산 처리 시스템의 목적 / 장·단점 •\u0007\u0007각\u0007프로세서가\u0007독자적인\u0007운영체제를\u0007가지고\u0007있 기\u0007때문에\u0007한\u0007프로세서가\u0007고장나더라도\u0007전체\u0007시 분산 처리 시스템의 목적 스템이\u0007다운되지\u0007않음 각\u0007시스템이\u0007통신망을\u0007통해\u0007연결되어\u0007있으므로\u0007 •\u0007여러\u0007프로세서들이\u0007완전한\u0007기능을\u0007갖춘\u0007하나의\u0007 자원 공유 유용한\u0007자원을\u0007공유하여\u0007사용할\u0007수\u0007있음 운영체제를\u0007공유하여\u0007수행하는\u0007구조 •\u0007가장\u0007복잡한\u0007구조를\u0007가지고\u0007있으나\u0007가장\u0007강력한\u0007 하나의\u0007일을\u0007여러\u0007시스템에\u0007분산시켜\u0007처리함으 연산 속도 향상 시스템임 로써\u0007연산\u0007속도가\u0007향상됨 •\u0007여러\u0007개의\u0007프로세서가\u0007동시에\u0007수행될\u0007수\u0007있고,\u0007 여러\u0007시스템\u0007중\u0007하나의\u0007시스템에\u0007오류가\u0007발생하 대칭적 처리기 시스템의\u0007전반적인\u0007정보를\u0007통일적이고\u0007일관성\u0007 신뢰도 향상 더라도\u0007다른\u0007시스템은\u0007계속\u0007일을\u0007처리할\u0007수\u0007있으 있게\u0007운영함 므로\u0007신뢰도가\u0007향상됨 •\u0007프로세서의\u0007수를\u0007늘린다고\u0007해도\u0007시스템\u0007효율은\u0007 향상되지\u0007않음 지리적으로\u0007멀리\u0007떨어져\u0007있더라도\u0007통신망을\u0007통해\u0007 컴퓨터 통신 정보를\u0007교환할\u0007수\u0007있음 •\u0007프로세서\u0007간의\u0007통신은\u0007공유\u0007메모리를\u0007통해\u0007이루 어짐 분산 처리 시스템의 장·단점 • 장점 : 통신 용이, 장치 공유, 데이터 공유, 중앙 컴퓨터 핵심 14.8, 12.5, 10.9, 10.5, 09.9, 09.8, 08.3, 06.9, 05.4, 04.9, 01.9, 99.8 과부하 줄임, 컴퓨터의 위치를 몰라도 자원 사용 가능, 159 프로세서의 결합도 시스템의 점진적 확장 가능 등 다중 처리기는 각 프로세서 간의 결합도에 따라 다음과 같 • 단점 : 중앙 집중형 시스템에 비해 소프트웨어 개발이 이 약결합 시스템과 강결합 시스템으로 분류할 수 있다. 어려움, 보안 문제 발생, 설계 복잡 등 •\u0007각\u0007프로세서마다\u0007독립된\u0007메모리를\u0007가진\u0007시스템으로,\u0007 분산\u0007처리\u0007시스템이라고도\u0007함 핵심 12.8, 12.5, 07.5, 05.5, 04.9, 02.5, 02.3 •\u0007둘\u0007이상의\u0007독립된\u0007컴퓨터\u0007시스템을\u0007통신망(통신\u0007링 161 분산 처리 시스템의 투명성 크)을\u0007통하여\u0007연결한\u0007시스템 약결합 •각\u0007시스템마다\u0007독자적인\u0007운영체제를\u0007가지고\u0007있음 • 투명성(Transparency, Transparence) : 분산 처리 운영 (Loosely Coupled) •\u0007각\u0007시스템은\u0007독립적으로\u0007작동할\u0007수도\u0007있고,\u0007필요한\u0007 체제에서 구체적인 시스템 환경을 사용자가 알 수 없도 경우에는\u0007상호\u0007통신할\u0007수도\u0007있음 시스템 록 하며, 또한 사용자들로 하여금 이에 대한 정보가 없 •\u0007프로세서\u0007간의\u0007통신은\u0007메시지\u0007전달이나\u0007원격\u0007프로시 어도 원하는 작업을 수행할 수 있도록 지원하는 개념 저\u0007호출을\u0007통해서\u0007이루어짐 •\u0007각\u0007시스템마다\u0007독자적인\u0007운영이\u0007가능하므로\u0007CPU\u0007간 •여 러 유형의 투명성을 통해 자원의 위치나 정보가 변 의\u0007결합력이\u0007약함 경되더라도 사용자가 이를 인식하지 못하게 된다. 61 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 59] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 투명성의 종류 •\u0007모든\u0007사이트가\u0007하나의\u0007중앙\u0007사이트에\u0007직접\u0007연 결되어\u0007있고,\u0007그\u0007외의\u0007다른\u0007사이트와는\u0007연결되 사용자가\u0007하드웨어나\u0007소프트웨어와\u0007같은\u0007자원 어\u0007있지\u0007않은\u0007구조 위치(Location) (정보\u0007객체)의\u0007물리적\u0007위치를\u0007모르더라도\u0007자원 투명성 스타(Star) 형/ •\u0007기본\u0007비용은\u0007사이트의\u0007수에\u0007비례하며,\u0007통신\u0007비 에\u0007접근할\u0007수\u0007있도록\u0007함 성형 용은\u0007적게\u0007듦 사용자나\u0007응용\u0007프로그램의\u0007동작에\u0007영향을\u0007받 •\u0007중앙\u0007사이트를\u0007제외한\u0007사이트의\u0007고장이\u0007다른\u0007 이주(Migration) 지\u0007않고\u0007시스템\u0007내에\u0007있는\u0007자원을\u0007이동할\u0007수\u0007 사이트에\u0007영향을\u0007미치지\u0007않지만,\u0007중앙\u0007사이트 투명성 있도록\u0007함 가\u0007고장\u0007날\u0007경우\u0007모든\u0007통신이\u0007단절됨 복제(Replication) 자원의\u0007복제를\u0007사용자에게\u0007통지할\u0007필요\u0007없이\u0007 •\u0007시스템\u0007내의\u0007각\u0007사이트가\u0007인접하는\u0007다른\u0007두\u0007사 투명성 자유로이\u0007수행할\u0007수\u0007있음 이트와만\u0007직접\u0007연결된\u0007구조 링(Ring)형/ •정보는\u0007단방향\u0007또는\u0007양방향으로\u0007전달될\u0007수\u0007있음 병행(Concurrency) 자원의\u0007위치를\u0007모르더라도\u0007다중\u0007사용자들이\u0007자 환형 •\u0007기본\u0007비용은\u0007사이트\u0007수에\u0007비례하고,\u0007목적\u0007사이 투명성 원을\u0007병행하여\u0007처리하고,\u0007공유할\u0007수\u0007있도록\u0007함 트에\u0007데이터를\u0007전달하기\u0007위해\u0007링을\u0007순환할\u0007경 접근(Access) 각\u0007프로세서의\u0007로그인\u0007등과\u0007같은\u0007동작을\u0007사용 우\u0007통신\u0007비용이\u0007증가함 투명성 하여\u0007지역이나\u0007원격\u0007자원에\u0007접근할\u0007수\u0007있음 •\u0007시스템\u0007내의\u0007모든\u0007사이트들이\u0007공유\u0007버스에\u0007연 성능(Performance) 여러\u0007부하에\u0007대해\u0007성능을\u0007증가시키기\u0007위하여\u0007 결된\u0007구조 투명성 시스템을\u0007재구성할\u0007수\u0007있도록\u0007함 다중 접근 버스 •\u0007기본\u0007비용은\u0007사이트\u0007수에\u0007비례하고,\u0007통신\u0007비용 연결(Multi 은\u0007일반적으로\u0007저렴함 시스템이나\u0007응용\u0007프로그램들이\u0007시스템\u0007구조나\u0007 규모(Scaling) Access Bus •\u0007사이트의\u0007고장은\u0007다른\u0007사이트의\u0007통신에\u0007영향을\u0007 응용\u0007알고리즘에\u0007대한\u0007변경\u0007없이\u0007규모에\u0007맞추 투명성 Connection)형 주지\u0007않지만,\u0007버스의\u0007고장은\u0007전체\u0007시스템에\u0007영 어\u0007확장할\u0007수\u0007있도록\u0007함 향을\u0007줌 사용자나\u0007응용\u0007프로그램이\u0007하드웨어나\u0007소프트 고장(Failure) •\u0007사이트의\u0007추가와\u0007삭제가\u0007용이함 웨어\u0007구성\u0007요소의\u0007고장에도\u0007불구하고\u0007그들의\u0007 투명성 작업을\u0007완료할\u0007수\u0007있도록\u0007함 03.5, 02.3, 01.9, 01.6, 01.3, 00.7, 00.3, 99.10, 99.4 핵심 14.8, 14.5, 13.8, 12.8, 12.5, 11.6, 11.3, 10.5, 10.3, 09.5, 07.5, 06.9, 06.5, 06.3, 05.5, 05.4, 04.5, 03.8, 01.6, 00.10, 00.7, 99.8 163 UNIX의 특징 핵심 14.3, 13.6, 12.5, 12.3, 11.3, 10.5, 08.3, 07.9, 07.3, 06.9, 06.5, 05.9, 05.5, 05.4, 05.3, 03.8, 03.5, 03.3, 02.9, 02.5, 02.3, 162 위상에 따른 분산 처리 시스템의 분류 •시 분할 시스템을 위해 설계된 대화식 운영체제로, 소 스가 공개된 개방형 시스템(Open System)이다. •\u0007각\u0007사이트들이\u0007시스템\u0007내의\u0007다른\u0007모든\u0007사이트 들과\u0007직접\u0007연결된\u0007구조 •대 부분 C 언어로 작성되어 있어 이식성이 높으며 장 n(n-1) 완전 연결 •\u0007사이트의\u0007수가\u0007n개이면\u0007링크(연결)\u0007수는\u0007 치, 프로세스 간의 호환성이 높다. 2 (Fully 개임 • 크기가 작고 이해하기가 쉬우며, Multi-User(다중 Connection)형 •\u0007기본\u0007비용은\u0007많이\u0007들지만\u0007통신\u0007비용은\u0007적게\u0007들 고,\u0007신뢰성이\u0007높음 사용자), Multi-Tasking(다중 작업)을 지원한다. •\u0007사이트\u0007간의\u0007메시지\u0007전달이\u0007매우\u0007빠름 • 많은 네트워킹 기능을 제공하므로 통신망(Network) •\u0007시스템\u0007내의\u0007일부\u0007사이트들\u0007간에만\u0007직접\u0007연결 관리용 운영체제로 적합하다. 된\u0007형태로,\u0007직접\u0007연결되지\u0007않은\u0007사이트는\u0007연결 부분 연결 된\u0007다른\u0007사이트를\u0007통해\u0007통신하는\u0007구조 • 트리 구조의 파일 시스템으로, 전문적인 프로그램 개 (Partially •\u0007기본\u0007비용은\u0007완전\u0007연결형보다\u0007적게\u0007들고,\u0007통신\u0007 발에 용이하다. Connection)형 비용은\u0007완전\u0007연결형보다\u0007많이\u0007듦 • 백그라운드에서 작업을 수행할 수 있으므로 여러 개의 •완전\u0007연결형보다\u0007신뢰성이\u0007낮음 작업을 병행 처리할 수 있다. •\u0007분산\u0007처리\u0007시스템의\u0007가장\u0007대표적인\u0007형태로,\u0007각\u0007 사이트들이\u0007트리\u0007형태로\u0007연결된\u0007구조 • 다양한 유틸리티 프로그램들이 존재하며, 정보와 유틸 •\u0007기본\u0007비용은\u0007부분\u0007연결형보다\u0007적게\u0007들고,\u0007통신\u0007 리티들을 공유하여 편리하게 작업을 수행할 수 있다. 트리(Tree)/계층 비용은\u0007트리의\u0007깊이에\u0007비례함 (Hierarchy)형 •\u0007부모(상위)\u0007사이트의\u0007자식(하위)\u0007사이트들은\u0007그\u0007 부모\u0007사이트를\u0007통해\u0007통신이\u0007이루어짐 •\u0007부모\u0007사이트가\u0007고장나면\u0007그\u0007자식\u0007사이트들은\u0007 통신이\u0007불가능함 62 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 60] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 05.5, 05.3, 04.9, 04.3, 03.8, 03.5, 03.3, 02.9, 02.5, 02.3, 01.9, 01.6, 00.10 04.9, 04.3, 03.3, 02.9, 02.3, 00.7, 00.3, 99.10, 99.8, 99.4 핵심 14.3, 13.8, 13.6, 12.5, 12.3, 11.8, 11.6, 10.9, 10.5, 09.8, 09.3, 08.9, 08.5, 07.5, 06.9, 06.5, 06.3, 05.9, 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.5, 12.3, 11.8, 10.9, 10.3, 08.9, 08.5, 08.3, 07.9, 07.3, 06.9, 06.5, 06.3, 05.9, 05.3, 164 UNIX 시스템의 구성 166 UNIX의 주요 명령어 •UNIX의\u0007가장\u0007핵심적인\u0007부분 명령어 의 미 •\u0007하드웨어를\u0007보호(캡슐화)하고,\u0007프로그램들과\u0007하드 \u0007새로운\u0007프로세스\u0007생성(하위\u0007프로세스\u0007호출,\u0007프로세스\u0007 웨어\u0007간의\u0007인터페이스\u0007역할을\u0007담당함 fork 복제) •\u0007프로세스\u0007관리,\u0007기억장치\u0007관리,\u0007파일\u0007관리,\u0007입·출 커널(Kernel) 력\u0007관리,\u0007프로세스\u0007간\u0007통신,\u0007데이터\u0007전송\u0007및\u0007변환\u0007 exec 새로운\u0007프로세스\u0007수행 등\u0007여러\u0007가지\u0007기능을\u0007수행함 & 백그라운드\u0007처리를\u0007위해\u0007명령의\u0007끝에\u0007입력 •\u0007컴퓨터\u0007부팅\u0007시\u0007주기억장치에\u0007적재되어\u0007상주하면 서\u0007실행됨 \u0007fork후\u0007exec에\u0007의해\u0007실행되는\u0007프로세스의\u0007상위\u0007프로 wait 세스가\u0007하위\u0007프로세스\u0007종료\u0007등의\u0007event를\u0007기다림 •\u0007사용자의\u0007명령어를\u0007인식하여\u0007프로그램을\u0007호출하 고,\u0007명령을\u0007수행하는\u0007명령어\u0007해석기 exit 프로세스\u0007수행\u0007종료 •시스템과\u0007사용자\u0007간의\u0007인터페이스를\u0007담당함 cat 내용을\u0007화면에\u0007표시(DOS\u0007명령\u0007중\u0007‘TYPE’과\u0007유사) •DOS의\u0007COMMAND.COM과\u0007같은\u0007기능을\u0007수행함 쉘(Shell) chmod 파일의\u0007사용\u0007허가\u0007지정 •\u0007주기억장치에\u0007상주하지\u0007않고,\u0007명령어가\u0007포함된\u0007파 일\u0007형태로\u0007존재하며\u0007보조기억장치에서\u0007교체\u0007처리 chown 소유자\u0007변경 가\u0007가능함 \u0007파일\u0007시스템을\u0007마운팅(새로운\u0007파일\u0007시스템을\u0007기존\u0007파 •\u0007종류\u0007:\u0007Bourne\u0007Shell,\u0007C\u0007Shell,\u0007Korn\u0007Shell\u0007등 mount 일\u0007시스템의\u0007서브\u0007디렉터리에\u0007연결하는\u0007것)\u0007함 •\u0007일반\u0007사용자가\u0007작성한\u0007응용\u0007프로그램을\u0007처리하는\u0007 유틸리티 mkfs 파일\u0007시스템\u0007생성 데\u0007사용함 (Utility) •DOS에서의\u0007외부\u0007명령어에\u0007해당\u0007\u0007 chdir 현재\u0007사용할\u0007디렉터리\u0007위치\u0007변경 fsck 파일\u0007시스템을\u0007검사\u0007및\u0007보수하여\u0007무결성을\u0007검사\u0007함 05.5, 05.4, 04.9, 04.5, 04.3, 03.5, 03.3, 02.5, 01.9, 01.6, 01.3, 00.10, 99.10, 99.4 rmdir 디렉터리\u0007삭제 핵심 14.8, 14.5, 14.3, 13.6, 13.3, 12.8, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.5, 09.3, 08.9, 08.3, 07.9, 07.3, 165 UNIX 파일 시스템의 구조 ls 현재\u0007디렉터리\u0007내의\u0007파일\u0007목록\u0007확인 getpid 자신의\u0007프로세스\u0007아이디를\u0007얻음 •부 트 블록 : 부팅 시 필요한 코드를 저장하고 있는 블록 getppid 부모\u0007프로세스의\u0007아이디를\u0007얻음 • 슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장하고 있는 블록으로 사용 가능한 I-node, 사용 가능한 디 cp 파일\u0007복사 스크 블록의 개수를 알 수 있으며, File 시스템마다 각 mv 파일\u0007이동\u0007및\u0007이름\u0007변경 각의 슈퍼 블록을 가지고 있음 rm 파일\u0007삭제 • I-node 블록 : 각 파일이나 디렉터리에 대한 모든 정보 finger 사용자\u0007정보를\u0007\u0007표시함 를 저장하고 있는 블록으로, 파일 소유자의 사용자 번 호(UID) 및 그룹 번호(GID), 파일 크기, 파일 타입, 생 성 시기, 최종 변경 시기, 최근 사용 시기, 파일의 보호 권한, 파일 링크 수, 데이터가 저장된 블록의 시작 주 소 등의 정보를 가지고 있음 4과목·소프트웨어 공학 • 데이터 블록 : 디렉터리별로 디렉터리 엔트리와 실제 파 01.9, 00.7, 99.8 일에 대한 데이터가 저장된 블록 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 08.3, 07.5, 06.5, 03.5, 02.9, 02.5, 167 소프트웨어와 시스템 / 소프트웨어 위기 소프트웨어와 시스템 • 소프트웨어 : 하드웨어를 동작시켜 사용자가 작업을 편 리하게 수행하도록 하는 프로그램과 자료 구조 등을 총 칭하며, 프로그램 자체뿐만 아니라 프로그램의 개발, 운 용 및 유지 보수에 관련된 모든 문서와 정보를 포함함 63 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 61] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 소프트웨어의 특징 핵심 12.5, 12.3, 11.8, 09.3, 08.9, 08.3, 06.5, 06.3, 05.9, 05.5, 05.4, 04.3, 03.3 168 소프트웨어 공학의 개념과 기본 원칙 상품성 개발된\u0007소프트웨어는\u0007상품화되어\u0007판매됨 소프트웨어 공학의 개념 견고성 일부\u0007수정으로\u0007소프트웨어\u0007전체에\u0007영향을\u0007줄\u0007수\u0007있음\u0007 소프트웨어 공학(SE, Software Engineering)은 소프 개발\u0007과정이\u0007복잡하고\u0007비표준화되어\u0007이해와\u0007관리가\u0007 복잡성 트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이 어려움 며 여러 가지 방법론과 도구, 관리 기법들을 통하여 소프 순응성 사용자의\u0007요구나\u0007환경\u0007변화에\u0007적절히\u0007변경할\u0007수\u0007있음 트웨어의 품질과 생산성 향상을 목적으로 한다. 소프트웨어의\u0007구조가\u0007외관으로\u0007나타나지\u0007않고,\u0007코드\u0007 비가시성 • IEEE의 소프트웨어 공학 표준 용어사전 : 소프트웨어 속에\u0007숨어\u0007있음\u0007 의 개발, 운용, 유지보수, 폐기 처분에 대한 체계적인 접근 비마모성 사용에\u0007의해\u0007마모되거나\u0007소멸되지\u0007않음 방안 하드웨어처럼\u0007제작되지\u0007않고\u0007논리적인\u0007절차에\u0007맞게\u0007 비제조성 • Fairley : 지정된 비용과 기간 내에 소프트웨어를 체 개발됨 계적으로 생산하고 유지보수하는 데 관련된 기술적이 소프트웨어\u0007개발\u0007자체는\u0007수학적이거나\u0007과학적인\u0007것이\u0007 비과학성 고 관리적인 원리 아니라\u0007조직,\u0007인력,\u0007시간,\u0007비용,\u0007절차\u0007등이\u0007중심이\u0007됨 • Boehm : 과학적인 지식을 소프트웨어 설계와 제작에 • 시스템 : 공통의 목적이나 목표를 달성하기 위하여 여 응용하는 것이며 이를 개발, 운용, 유지보수하는 데 필 러 가지 상호 관련된 요소들을 유기적으로 결합한 것 요한 문서 작성 과정 으로 구성 요소는 입력, 처리, 출력, 제어, 피드백으로 • 소프트웨어 공학은 제품을 단지 생산하는 것이 아니라 가 나눌 수 있음 장 경제적인 방법으로 양질의 제품을 생산하는 것이다. - 피드백(Feedback) : 출력된 결과가 예정된 목표를 만족 • 소프트웨어 공학은 안정적이며 효율적으로 작동하는 시키지 못할 경우 목표 달성을 위해 반복 처리하는 것 소프트웨어를 생산하고, 유지보수 활동을 체계적이고 소프트웨어 위기(Crisis) 경제적으로 수행하기 위해 계층화 기술을 사용한다. • 여러 가지 원인에 의해 소프트웨어 개발 속도가 하드 소프트웨어 공학의 기본 원칙 웨어 개발 속도를 따라가지 못해 소프트웨어에 대한 • 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다. 사용자들의 요구사항을 처리할 수 없는 문제가 발생한 •개 발된 소프트웨어의 품질이 유지되도록 지속적으로 것을 의미한다. 검증해야 한다. • 소프트웨어 위기의 원인과 결과 • 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기 록을 유지해야 한다. •\u0007소프트웨어의\u0007특성에\u0007대한\u0007이해\u0007부족 •\u0007소프트웨어의\u0007관리\u0007부재 좋은 품질의 소프트웨어 원인 •\u0007프로그래밍에만\u0007치중 •사용자가 요구하는 대로 동작해야 한다. •\u0007소프트웨어\u0007개발\u0007기술에\u0007대한\u0007교육\u0007부족 •하드웨어 자원을 효율적으로 이용할 수 있어야 한다. •\u0007개발\u0007인력의\u0007부족과\u0007그로\u0007인한\u0007인건비\u0007상승 •일 정 시간 내에 주어진 조건하에서 원하는 기능을 실 •\u0007성능\u0007및\u0007신뢰성의\u0007부족 행할 수 있어야 한다. 결과 •\u0007개발\u0007기간의\u0007지연\u0007및\u0007개발\u0007비용의\u0007증가 •\u0007유지보수가\u0007어렵고,\u0007이에\u0007따른\u0007비용\u0007증가 •애 매모호함이 없이 처리 절차에 맞게 수행되어 정확하 •\u0007소프트웨어의\u0007생산성\u0007저하,\u0007소프트웨어의\u0007품질\u0007저하\u0007 게 결과가 산출되어야 한다. •소 프트웨어의 개발, 유지보수 등이 초기 예상한 비용 이내에서 수행되어야 한다. •적 당한 사용자 인터페이스 제공으로 사용하기가 편리 해야 한다. •유 지보수가 용이해야 한다. 64 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 62] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •가 능한한 잠재적인 에러가 적어야 한다. • 소프트웨어의 일부가 될 매뉴얼을 작성해야 한다. •신 뢰성이 높고 효율적이어야 한다. • 개발 순서 : 타당성 검토 → 계획 → 요구 분석 → 설계 → 구현(코딩) → 시험(검사) → 유지보수 핵심 07.5, 06.5, 04.3, 03.8, 03.3, 02.3, 01.9, 99.8, 99.4 •\u0007모형의\u0007적용\u0007경험과\u0007성공\u0007사례가\u0007많음 169 일반적인 소프트웨어 생명 주기 •\u0007단계별\u0007정의가\u0007분명하고,\u0007전체\u0007공조의\u0007이해가\u0007용이함 장점 •\u0007단계별\u0007산출물이\u0007정확하여\u0007개발\u0007공정의\u0007기준점을\u0007잘\u0007 •정 의 단계 : ‘무엇(What)’을 처리하는 소프트웨어를 개 제시함 발할 것인지 정의하는 단계로, 관리자와 사용자가 가 •\u0007개발\u0007과정중에\u0007발생하는\u0007새로운\u0007요구나\u0007경험을\u0007반영하기\u0007 장 많이 참여하는 단계 어려우므로\u0007처음부터\u0007사용자들이\u0007모든\u0007요구사항들을\u0007 명확하게\u0007제시해야\u0007함 개발할\u0007소프트웨어가\u0007법적,\u0007경제적,\u0007기술적으로\u0007 단점 •\u0007단계별로\u0007오류\u0007없이\u0007다음\u0007단계로\u0007진행해야\u0007하는데\u0007 타당성 검토 단계 실현\u0007가능성이\u0007있는지\u0007조사하는\u0007단계 현실적으로\u0007오류\u0007없이\u0007다음\u0007단계로\u0007진행하기는\u0007어려움 •\u0007개발된\u0007프로그램을\u0007업무에\u0007운용할\u0007때\u0007검출되지\u0007않은\u0007 소프트웨어\u0007개발에\u0007사용될\u0007자원과\u0007비용을\u0007 개발 계획 단계 오류로\u0007인하여\u0007사용자들이\u0007큰\u0007인내심을\u0007가져야\u0007함 측정하는\u0007단계 요구사항 분석 사용자가\u0007요구한\u0007문제를\u0007보다\u0007상세하고\u0007정확히\u0007 00.10, 00.7, 00.3, 99.10, 99.8 단계 분석하는\u0007단계 핵심 13.8, 12.5, 10.9, 09.3, 08.5, 08.3, 07.9, 07.3, 06.9, 06.5, 06.3, 05.9, 05.4, 05.3, 04.9, 04.3, 03.3, 01.9, 01.6, 01.3, 171 소프트웨어 생명 주기 모형 - 프로토타입 •개 발 단계 : ‘어떻게(How)’에 초점을 두고 실제적으로 모형 소프트웨어를 개발하는 단계 •프 로토타입 모형(Prototype Model)은 사용자의 요구 사항을 정확히 파악하기 위해 실제 개발될 소프트웨어 소프트웨어의\u0007구조,\u0007알고리즘,\u0007자료\u0007구조\u0007등을\u0007 설계 단계 작성하는\u0007단계로,\u0007에러가\u0007가장\u0007많이\u0007발생하는\u0007단계 에 대한 견본(시제)품(Prototype)을 만들어 최종 결과 물을 예측하는 모형이다. 설계\u0007단계에서\u0007작성된\u0007문서를\u0007기초로\u0007하여\u0007코딩하고\u0007 구현 단계 번역하는\u0007단계 •시 제품은 사용자와 시스템 사이의 인터페이스에 중점 구현된\u0007소프트웨어에\u0007내재되어\u0007있는\u0007오류를\u0007찾는\u0007 을 두어 개발한다. 테스트 단계 단계 • 시스템의 일부 혹은 시스템의 모형을 만드는 과정으로 • 유지보수 단계 : 소프트웨어를 직접 운용하며, ‘변경 서, 요구된 소프트웨어의 일부를 구현하는데, 이는 추 (Change)’에 초점을 두고 여러 환경 변화에 따라 소프 후 구현 단계에서 사용될 골격 코드가 된다. 트웨어를 적응 및 유지시키는 단계로, 시간과 비용이 • 프로토타입은 요구 분석 단계에서 사용하게 되며, 프 가장 많이 투입되는 단계 로토타입의 평가가 끝나고 개발이 승인되면 다른 모형 을 이용하여 본격적인 개발이 이루어진다. • 소프트웨어 생명주기에서 유지보수 단계가 없어지고 핵심 13.6, 09.5, 07.9, 06.9, 05.3, 03.8, 03.5, 03.3, 02.9, 02.5, 01.9, 01.6, 01.3, 00.10, 99.8, 99.4 170 소프트웨어 생명 주기 모형 - 폭포수 모형 개발 단계 안에서 유지보수가 이루어진다. • 개발 순서 : 요구 수집 → 빠른 설계 → 프로토타입 구 •폭 포수 모형(Waterfall Model)은 소프트웨어 개발 축 → 고객 평가 → 프로토타입 조정 → 구현 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토 하여 승인 과정을 거친 후에 다음 단계를 진행하며 이 •\u0007요구사항을\u0007충실히\u0007반영하며,\u0007요구사항의\u0007변경이\u0007용이함 전 단계로 되돌아갈 수 없는 방식이다. •\u0007최종\u0007결과물이\u0007만들어지기\u0007전에\u0007의뢰자가\u0007최종\u0007결과물의\u0007 장점 일부\u0007또는\u0007모형을\u0007볼\u0007수\u0007있음 • 소프트웨어 공학에서 가장 오래되고 가장 폭넓게 사용 •\u0007프로토타입은\u0007의뢰자나\u0007개발자\u0007모두에게\u0007공동의\u0007참조\u0007모 된 전통적인 소프트웨어 생명 주기 모형(고전적 생명 델을\u0007제공함 주기 모형)이다. •\u0007미리\u0007제작된\u0007소프트웨어를\u0007사용할\u0007경우\u0007실제\u0007소프트웨어와 • 소프트웨어 개발 과정의 앞 단계가 끝나야만 다음 단 의\u0007차이가\u0007발생할\u0007수\u0007있어\u0007사용자에게\u0007혼란을\u0007줄\u0007수\u0007있음 단점 계로 넘어갈 수 있는 선형 순차적 모형이다. •\u0007단기간에\u0007제작해야\u0007하기\u0007때문에\u0007비효율적인\u0007언어나\u0007알고 리즘을\u0007사용할\u0007수\u0007있음 65 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 63] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.5, 14.3, 13.3, 12.8, 11.3, 10.3, 09.8, 09.5, 08.9, 05.5, 04.9, 04.5, 03.5, 02.9, 02.3, 99.8, 99.4 • 효과적인 프로젝트 관리를 위한 3P(3대 요소) 172 소프트웨어 생명 주기 모형 - 나선형 모형 사람(People) 프로젝트\u0007관리에서\u0007가장\u0007기본이\u0007되는\u0007인적\u0007자원 • 나선형 모형(Spiral Model, 점진적 모형)은 보헴 문제(Problem) 사용자\u0007입장에서\u0007문제를\u0007분석하여\u0007인식함 (Boehm)이 제안한 것으로, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다. 소프트웨어\u0007개발에\u0007필요한\u0007전체적인\u0007작업\u0007계획\u0007 프로세스(Process) 및\u0007구조(Framework) • 나선을 따라 돌 듯이 여러 번의 소프트웨어 개발 과정 을 거쳐 점진적으로(프로토타입을 지속적으로 발전시 켜) 완벽한 최종 소프트웨어를 개발하는 것이다. 핵심 13.3, 12.5, 12.3, 11.8, 11.6, 10.5, 10.3, 09.5, 08.5, 08.3, 07.9, 05.9, 03.5, 00.10, 99.10, 99.8, 99.4 174 프로젝트 계획 수립 • 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리 하고 최소화하는 것을 목적으로 한다. 소프트웨어 개발 영역 결정 • 개발 순서 : 계획 및 정의(Planning) → 위험 분석 • 프로젝트 계획 수립의 첫 번째 업무로, 개발될 소프트 (Risk Analysis) → 공학적 개발(Engineering) → 웨어의 영역을 결정하는 것이다. 고객 평가(Customer Evaluation) • 소프트웨어 개발 영역을 결정하는 주요 요소 : 처리될 데 이터와 소프트웨어에 대한 기능, 성능, 제약조건, 인터 •\u0007가장\u0007현실적인\u0007모형으로,\u0007대규모\u0007시스템에\u0007적합함 •\u0007점진적으로\u0007개발\u0007과정이\u0007반복되므로\u0007누락되거나\u0007추가된\u0007 페이스 및 신뢰도 등 장점 요구사항을\u0007첨가할\u0007수\u0007있고,\u0007정밀하며,\u0007유지보수\u0007과정이\u0007 잠깐만요 ! 인터페이스에 포함되는 사항 필요\u0007없음 •\u0007소프트웨어에\u0007의해\u0007간접적으로\u0007제어되는\u0007장치와\u0007소프트웨어를\u0007실 •\u0007위험성\u0007평가에\u0007크게\u0007의존하기\u0007때문에\u0007이를\u0007발견하지\u0007않으 행하는\u0007프로세서나\u0007하드웨어 면\u0007반드시\u0007문제가\u0007발생함 •\u0007운영체제,\u0007서브루틴\u0007패키지와\u0007같이\u0007새로운\u0007소프트웨어에\u0007연결되어 단점 •\u0007비교적\u0007최신기법이므로\u0007폭포수\u0007모형이나\u0007프로토타입\u0007모형 야\u0007하는\u0007소프트웨어 보다\u0007널리\u0007사용되지\u0007않음 •\u0007키보드나\u0007기타\u0007I/O\u0007장치들을\u0007통하여\u0007소프트웨어를\u0007사용하는\u0007사람 •\u0007순서적인\u0007연산에\u0007의해\u0007소프트웨어를\u0007실행하는\u0007절차 04.3, 02.3, 01.9, 00.10, 00.7, 99.8 자원 추산 핵심 14.8, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 09.8, 09.3, 08.3, 07.9, 07.3, 06.9, 05.5, 05.4, 173 프로젝트 관리 대상 소프트웨어 개발에 필요한 자원을 예측하는 것으로 인적 자원, 재사용 소프트웨어 자원, 환경 자원으로 나눌 수 프로젝트 관리(Project Management) 있다. •주 어진 기간 내에 최소의 비용으로 사용자를 만족시키 소프트웨어 프로젝트 추산 는 시스템을 개발하기 위한 전반적인 활동 프로젝트 수행에 필요한 비용을 예측하는 것으로, 신뢰 • 소프트웨어 개발 계획을 세우고 분석, 설계, 구현 등의 할 만한 비용을 예측하기 위해서는 다음과 같은 방법을 작업을 통해 하는 것으로 소프트웨어 생명 주기의 전 사용한다. 과정을 걸쳐 진행된다. •프 로젝트 관리의 후반까지 프로젝트 예측을 가능한 한 프로젝트 관리 대상 연기한다. • 계획 관리 : 프로젝트 계획, 비용 산정, 일정 계획, 조직 • 이미 수행된 유사 프로젝트를 참고한다. 계획 • 프로젝트를 상대적으로 잘게 분리하여 예측하는 분해 • 품질 관리 : 품질 통제, 품질 보증 기법을 사용한다. • 위험 관리 : 위험 식별, 위험 분석 및 평가, 위험 관리 • 하나 이상의 경험적 예측(실험) 모델을 활용한다. 계획, 위험 감시 및 조치 • 자동화 도구를 도입하여 활용한다. 66 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 64] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 프로젝트 비용 결정 요소 • 소프트웨어 개발 유형 프로젝트 요소 제품의\u0007복잡도,\u0007시스템의\u0007크기,\u0007요구되는\u0007신뢰도 •\u0007기관\u0007내부에서\u0007개발된\u0007중·소규모의\u0007소프트웨어로\u0007 일괄\u0007자료\u0007처리나\u0007과학\u0007기술\u0007계산용,\u0007비즈니스\u0007자 자원 요소 인적\u0007자원,\u0007하드웨어\u0007자원,\u0007소프트웨어\u0007자원 조직형 료\u0007처리용으로\u00075만(50KDSI)\u0007라인\u0007이하의\u0007소프트웨 (Organic 생산성 요소 개발자의\u0007능력,\u0007경험,\u0007주어진\u0007개발\u0007기간 어를\u0007개발하는\u0007유형 Mode) •\u0007사무\u0007처리용,\u0007업무용,\u0007과학용\u0007응용\u0007소프트웨어\u0007개 발에\u0007적합함 핵심 14.8, 14.3, 13.6, 11.8, 10.9, 09.3, 08.9, 08.5, 08.3, 06.3, 04.3, 02.5, 01.6, 01.3 •\u0007조직형과\u0007내장형의\u0007중간형으로\u0007트랜잭션\u0007처리\u0007시 175 비용 산정 기법 - LOC 기법 반분리형 스템이나\u0007운영체제,\u0007데이터베이스\u0007관리\u0007시스템\u0007등 (Semi- 의\u000730만(300KDSI)\u0007라인\u0007이하의\u0007소프트웨어를\u0007개 •L OC(원시 코드 라인 수) 기법은 소프트웨어 각 기능의 Detached 발하는\u0007유형 Mode) •\u0007컴파일러,\u0007인터프리터와\u0007같은\u0007유틸리티\u0007개발에\u0007적 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하 합함 여 예측치를 구하고 이를 이용하여 비용을 산정하는 •\u0007초대형\u0007규모의\u0007트랜잭션\u0007처리\u0007시스템이나\u0007운영체 기법이다. 내장형 제\u0007등의\u000730만(300KDSI)\u0007라인\u0007이상의\u0007소프트웨어 (Embedded 를\u0007개발하는\u0007유형 • 측정이 용이하고, 이해가 쉬워 가장 많이 사용된다. Mode) •\u0007신호기\u0007제어\u0007시스템,\u0007미사일\u0007유도\u0007시스템,\u0007실시간\u0007 • 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용 처리\u0007시스템\u0007등의\u0007시스템\u0007프로그램\u0007개발에\u0007적합함 을 산정한다. a + 4 m + b ( 단, a : 낙관치, b : 비관치, • 예측치 = 6 m : 중간치(기대치)) 핵심 177 C05.5 O, 04.5 C, 02 O.3, 00 M.10, 0 O0.7, 0 0 모.3, 99.1 형0 의 종류 • 산정 공식 •비 용 산정 단계 및 적용 변수의 구체화 정도에 따라 기 •\u0007개발\u0007기간\u0007×\u0007투입\u0007인원\u0007 본(Basic), 중간(Intermediate), 발전(Detailed)형으 노력(인월) •\u0007LOC\u0007/\u00071인당\u0007월평균\u0007생산\u0007코드\u0007라인\u0007수 로 구분할 수 있다. 개발 비용 노력(인월)\u0007×\u0007단위\u0007비용(1인당\u0007월평균\u0007인건비) • 기본(Basic)형 COCOMO : 소프트웨어의 크기와 개발 개발 기간 노력(인월)\u0007/\u0007투입\u0007인원\u0007 유형만을 이용하여 비용을 산정하는 모형 생산성 LOC\u0007/\u0007노력(인월) • 중간(Intermediate)형 COCOMO : 기본 COCOMO 공식 을 토대로 사용하나, 제품의 특성, 컴퓨터의 특성, 개 발 요원의 특성, 프로젝트 특성에 의해 비용을 산정하 핵심 11.3, 09.5, 04.9, 04.3, 03.5, 03.3, 01.9, 01.3. 99.10 는 모형 176 비용 산정 기법 - COCOMO • 발전(Detailed)형 COCOMO : 중간(Intermediate)형 • Boehm이 제안한 것으로 원시 프로그램의 규모(LOC) COCOMO를 보완하여 만들어진 방법으로, 개발 공정 에 의한 비용 산정 기법이다. 별로 보다 자세하고 정확하게 노력을 산출하여 비용을 • 개발할 소프트웨어의 규모를 예측한 후 이를 소프트웨 산정하는 모형 어 종류에 따라 다르게 책정되는 비용 산정 방정식(공 식)에 대입하여 비용을 산정한다. 03.5, 02.9, 01.9, 01.6, 00.10, 00.7, 00.3 핵심 14.8, 14.5, 14.3, 13.8, 12.3, 11.8, 10.3, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 07.3, 06.9, 05.9, 05.3, 04.9, 04.5, 03.8, • 비용 견적의 강도 분석 및 비용 견적의 유연성이 높아 178 프로젝트 일정 계획 소프트웨어 개발비 견적에 널리 통용되고 있다. - 브룩스 법칙 / PERT / CPM 브룩스(Brooks)의 법칙 프로젝트 진행중에 새로운 인력을 투입할 경우 작업 적 응 기간과 부작용으로 인해 일정을 더욱 지연시키고, 프 로젝트에 혼란을 가져오게 된다는 법칙이다. 67 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 65] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 PERT/CPM • 자원 배치와 인원 계획에 유용하게 사용된다. • 프로젝트의 지연을 방지하고 계획대로 진행되게 하기 •다 양한 형태로 변경하여 사용할 수 있다. 위한 일정을 계획하는 것으로, 대단위 계획의 조직적인 •작 업 경로는 표시할 수 없으며, 계획의 변화에 대한 적응 추진을 위해 자원의 제약하에 비용을 적게 사용하면서 성이 약하다. 최단시간 내 계획 완성을 위한 프로젝트 일정 방법이다. •이 정표, 작업 일정, 작업 기간, 산출물로 구성되어 있다. •프 로젝트 개발 기간을 결정하는 임계 경로(CP; Critical Path)를 제공한다. 핵심 12.5, 10.5, 08.9, 06.3, 05.9, 99.8a • 통계적 모델을 적용해서 개별 작업에 대한 가장 근접 180 프로젝트 팀 구성 한 시간 측정의 기준이 된다. • 각 작업에 대한 시작 시간을 정의하여 작업들 간의 경 •\u0007팀원\u0007모두가\u0007의사\u0007결정에\u0007참여하는\u0007비이기적인\u0007구성\u0007방식 (민주주의식\u0007팀) 계 시간을 계산할 수 있게 한다. •\u0007의사\u0007결정을\u0007민주주의식으로\u0007하며\u0007팀\u0007구성원의\u0007참여도와\u0007 작업\u0007만족도를\u0007높이고\u0007이직률을\u0007낮게\u0007함 •\u0007프로젝트에\u0007필요한\u0007전체\u0007작업의\u0007상호\u0007관계를\u0007표시하는\u0007 분산형 •\u0007팀\u0007구성원\u0007각자가\u0007서로의\u0007일을\u0007검토하고\u0007다른\u0007구성원이\u0007 네트워크로\u0007각\u0007작업별로\u0007낙관적인\u0007경우,\u0007가능성이\u0007있는\u0007 팀 일한\u0007결과에\u0007대하여\u0007같은\u0007그룹의\u0007일원으로\u0007책임을\u0007지며,\u0007 경우,\u0007비관적인\u0007경우로\u0007나누어\u0007각\u0007단계별\u0007종료\u0007시기를\u0007 장기\u0007프로젝트\u0007개발에\u0007적합함 결정하는\u0007방법 •\u0007다양한\u0007의사\u0007교류로\u0007인해\u0007의사\u0007결정\u0007시간이\u0007늦어지고,\u0007개 PERT •\u0007노드와\u0007간선으로\u0007구성되며,\u0007원\u0007노드에는\u0007작업을,\u0007 개인의\u0007생산성\u0007및\u0007책임감이\u0007낮아질\u0007수\u0007있음 간선에는\u0007낙관치,\u0007기대치,\u0007비관치를\u0007표시함 n(n-1) •\u0007의사소통\u0007경로의\u0007수\u0007=\u0007 \u0007(n\u0007:\u0007팀원\u0007수) •\u0007작업에\u0007대한\u0007경계\u0007시간,\u0007작업\u0007간의\u0007상호\u0007관련성,\u0007작업의\u0007 2 결정\u0007경로를\u0007확인할\u0007수\u0007있음\u0007 •\u0007한\u0007관리자가\u0007의사결정을\u0007하고,\u0007팀\u0007구성원들은\u0007그\u0007결정을\u0007 따르는\u0007구성\u0007방식으로\u0007책임\u0007프로그래머\u0007팀이라고도\u0007함 •\u0007프로젝트\u0007완성에\u0007필요한\u0007작업을\u0007나열하고\u0007작업에\u0007필요 •\u0007프로젝트\u0007수행에\u0007따른\u0007모든\u0007권한과\u0007책임을\u0007한\u0007관리자에게\u0007 한\u0007소요\u0007기간을\u0007예측하는\u0007데\u0007사용하는\u0007기법 위임하고,\u0007기술\u0007및\u0007관리\u0007지원을\u0007위해\u0007인력을\u0007투입하는\u0007형태 •\u0007CPM은\u0007노드와\u0007간선으로\u0007구성된\u0007네트워크로\u0007노드는\u0007작 •\u0007의사결정이\u0007빠르고,\u0007의사\u0007교환\u0007경로를\u0007줄일\u0007수\u0007있음 업을,\u0007간선은\u0007작업\u0007사이의\u0007전후\u0007의존\u0007관계를\u0007나타냄 •\u0007한\u0007사람에\u0007의하여\u0007통제할\u0007수\u0007있는\u0007비교적\u0007소규모\u0007문제에\u0007 •\u0007원형\u0007노드는\u0007각\u0007작업을\u0007의미하며\u0007각\u0007작업\u0007이름과\u0007소요\u0007 적합함 기간을\u0007표시하고,\u0007박스\u0007노드는\u0007이정표를\u0007의미하며\u0007박스\u0007 CPM 노드\u0007위에는\u0007예상\u0007완료\u0007시간을\u0007표시함 중앙 •\u0007책임 프로그래머 역할\u0007:\u0007요구\u0007분석\u0007및\u0007설계,\u0007중요한\u0007기술적\u0007 집중형 판단,\u0007프로그래머에게\u0007작업\u0007지시\u0007및\u0007배분\u0007등 •\u0007한\u0007이정표에서\u0007다른\u0007이정표에\u0007도달하려면\u0007이전의\u0007작업 이\u0007모두\u0007완료되어야\u0007함 팀 •\u0007프로그래머 역할\u0007:\u0007책임\u0007프로그래머의\u0007지시에\u0007따른\u0007원시\u0007 코드\u0007작성,\u0007테스트,\u0007디버깅,\u0007문서\u0007작성\u0007등 •\u0007프로젝트\u0007내에서\u0007각\u0007작업이\u0007수행되는\u0007시간과\u0007각\u0007작업\u0007사 이의\u0007관계를\u0007파악할\u0007수\u0007있음\u0007 • 프로그램 사서 역할\u0007:\u0007프로그램\u0007리스트,\u0007설계\u0007문서,\u0007테스트\u0007 계획\u0007등을\u0007관리 •\u0007경영층의\u0007과학적인\u0007의사\u0007결정을\u0007지원하며,\u0007효과적인\u0007프 로젝트의\u0007통제를\u0007가능하게\u0007해\u0007줌 •\u0007보조 프로그래머 역할\u0007:\u0007책임\u0007프로그래머의\u0007업무\u0007지원,\u0007여 러\u0007가지\u0007기술적인\u0007문제에\u0007대한\u0007자문,\u0007사용자,\u0007품질\u0007보증\u0007담 당자\u0007등의\u0007섭외,\u0007책임\u0007프로그래머\u0007감독하에\u0007분석,\u0007설계,\u0007구 현\u0007담당 핵심 12.5, 10.5, 08.9, 06.3, 05.9, 99.8 179 간트 차트(Gantt Chart) •\u0007분산형\u0007팀\u0007구성과\u0007중앙\u0007집중형\u0007팀\u0007구성을\u0007혼합한\u0007형태(혼 합형\u0007팀) • 프로젝트의 각 작업들이 언제 시작하고 종료되는지에 •\u00075~7명의\u0007초보\u0007프로그래머를\u0007작은\u0007그룹으로\u0007만들어\u0007각\u0007 계층 그룹을\u0007고급\u0007프로그래머가\u0007관리하게\u0007함 대한 작업 일정을 막대 도표를 이용하여 표시하는 프로 적팀 •\u0007경험자(고급\u0007프로그래머)와\u0007초보자를\u0007구별함 젝트 일정표로, 시간선(Time-Line) 차트라고도 한다. •\u0007프로젝트\u0007리더와\u0007고급\u0007프로그래머에게\u0007지휘\u0007권한을\u0007부여 •막 대로 표시하며, 수평 막대의 길이는 각 작업의 기간을 하고,\u0007의사\u0007교환은\u0007초급\u0007프로그래머와\u0007고급\u0007프로그래머 로\u0007분산함 나타낸다. • 중간 목표 미달성 시 이유와 기간을 예측할 수 있게 한다. •사 용자와의 문제점이나 예산의 초과 지출 등도 관리할 수 있게 한다. 68 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 66] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 07.5, 07.3, 06.9, 06.5, 05.5, 05.4, 05.3, 04.9, 04.3, 03.8, 02.5, 02.3, 01.3, 99.4 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, •\u0007가장\u0007일반적인\u0007검토\u0007방법으로\u0007소프트웨어\u0007기술자 181 품질 표준 들에\u0007의해\u0007수행되는\u0007소프트웨어\u0007품질\u0007보증\u0007활동 •\u0007정형\u0007 기술\u0007 검토\u0007 유형에는\u0007 검토\u0007 회의 • 명확하게 정의된 소프트웨어의 특성을 의미하며, 소프 (Walkthrough),\u0007검열(Inspections)\u0007등이\u0007있으며\u0007 트웨어의 품질을 평가하는 기준 항목이다. 이는\u0007모두\u0007회의\u0007형태로\u0007수행됨 •\u0007정형\u0007기술\u0007검토의\u0007목적 •종 류 \u0007\u0007\u0007\u0007-\u0007검토중인\u0007소프트웨어가\u0007해당\u0007요구사항과\u0007일 치하는지를\u0007검증함 종 류 의 미 \u0007\u0007\u0007\u0007-\u0007소프트웨어가\u0007미리\u0007정해진\u0007표준에\u0007따라\u0007표현 정확성(Correctness) 사용자의\u0007요구\u0007기능을\u0007충족시키는\u0007정도 되고\u0007있는지를\u0007확인하고,\u0007기능과\u0007로직에\u0007오류 가\u0007있는지\u0007확인함 정확하고\u0007일관된\u0007결과를\u0007얻기\u0007위해\u0007요구된\u0007 신뢰성(Reliability) 기능을\u0007오류\u0007없이\u0007수행하는\u0007정도 \u0007\u0007\u0007\u0007-\u0007소프트웨어가\u0007균일한\u0007방식으로\u0007개발되도록함 \u0007\u0007\u0007\u0007-\u0007프로젝트를\u0007보다\u0007용이하게\u0007관리하도록함 요구되는\u0007기능을\u0007수행하기\u0007위해\u0007필요한\u0007자원의\u0007 정형 기술 검토 효율성(Efficiency) •정형\u0007기술\u0007검토에\u0007대한\u0007지침\u0007사항 소요\u0007정도 (FTR) \u0007\u0007\u0007\u0007-제품의\u0007검토에만\u0007집중하라. 허용되지\u0007않는\u0007사용이나\u0007자료의\u0007변경을\u0007 무결성(Integrity) \u0007\u0007\u0007\u0007-의제를\u0007제한하여\u0007진행하라. 제어하는\u0007정도 \u0007\u0007\u0007\u0007-논쟁과\u0007반박을\u0007제한하라. 사용\u0007용이성\u0007 사용에\u0007필요한\u0007노력을\u0007최소화하고\u0007쉽게\u0007사용할\u0007 \u0007\u0007\u0007\u0007-\u0007문제\u0007영역을\u0007명확히\u0007표현하라. (Usability) 수\u0007있는\u0007정도(배우고\u0007사용하기\u0007쉬운\u0007정도) \u0007\u0007\u0007\u0007-해결책이나\u0007개선책에\u0007대해서는\u0007논하지\u0007말아라. 유지보수성 변경\u0007및\u0007오류\u0007사항의\u0007교정에\u0007대한\u0007노력을\u0007최소 \u0007\u0007\u0007\u0007-참가자의\u0007수를\u0007제한하고\u0007사전\u0007준비를\u0007강요하라. (Maintainability) 화하는\u0007정도 \u0007\u0007\u0007\u0007-\u0007검토될\u0007확률이\u0007있는\u0007각\u0007제품에\u0007대한\u0007체크\u0007리 스트를\u0007개발하라. 새로운\u0007요구사항에\u0007맞게\u0007얼마만큼\u0007쉽게\u0007수정할\u0007 유연성(Flexibility) \u0007\u0007\u0007\u0007-자원과\u0007시간\u0007일정을\u0007할당하라. 수\u0007있는가\u0007하는\u0007정도 \u0007\u0007\u0007\u0007-모든\u0007검토자들을\u0007위해\u0007의미있는\u0007훈련을\u0007행하라. 시험\u0007역량\u0007 의도된\u0007기능을\u0007수행하도록\u0007보장하기\u0007위해\u0007프로 \u0007\u0007\u0007\u0007-검토자들은\u0007사전에\u0007작성한\u0007메모들을\u0007공유하라. (Testability) 그램을\u0007시험할\u0007수\u0007있는\u0007정도 \u0007\u0007\u0007\u0007-검토의\u0007과정과\u0007결과를\u0007재검토하라. 다양한\u0007하드웨어\u0007환경에서도\u0007운용\u0007가능하도록\u0007 이식성(Portability) •\u0007소프트웨어\u0007개발의\u0007각\u0007단계에서\u0007개최하는\u0007기술\u0007 쉽게\u0007수정할\u0007수\u0007있는\u0007정도 평가\u0007회의로,\u0007소프트웨어\u0007구성\u0007요소와\u0007같은\u0007작 재사용성 전체나\u0007일부\u0007소프트웨어를\u0007다른\u0007목적으로\u0007 은\u0007단위를\u0007검토하는\u0007것 검토 회의 (Reusability) 사용할\u0007수\u0007있는가\u0007하는\u0007정도 •\u0007오류의\u0007조기\u0007검출을\u0007목적으로\u0007하며\u0007발견된\u0007오류 (Walkthrough) 는\u0007문서화하고,\u0007검토\u0007회의\u0007후에\u0007해결함 상호\u0007운용성 다른\u0007소프트웨어와\u0007정보를\u0007교환할\u0007수\u0007있는\u0007 •\u0007제품\u0007개발자가\u0007주최가\u0007되며,\u0007검토\u0007자료는\u0007사전 (Interoperability) 정도 에\u0007미리\u0007배포함 검열 검토\u0007회의를\u0007발전시킨\u0007형태로,\u0007소프트웨어\u0007개발\u0007 99.10 (Inspections, 단계에서\u0007산출된\u0007결과물의\u0007품질을\u0007평가하며\u0007이를\u0007 핵심 14.8, 14.3, 13.6, 13.3, 12.8, 12.5, 12.3, 11.6, 11.3, 10.5, 10.3, 09.8, 09.5, 08.9, 07.9, 06.9, 05.3, 04.9, 02.3, 01.6, 00.7, 심사) 개선시키는\u0007데\u0007사용함 182 품질 보증 / 정형 기술 검토 / 검토 회의 / 검열 •\u0007어떠한\u0007소프트웨어가\u0007이미\u0007설정된\u0007요구사항과\u0007 일치하는가를\u0007확인하는\u0007데\u0007필요한\u0007개발\u0007단계\u0007전 핵심 14.5, 13.6, 12.8, 11.3, 10.3, 09.8, 07.5, 07.3, 06.5, 05.4, 04.9, 04.5, 03.5, 02.5, 02.3, 00.7 183 위험 관리(Risk Analysis) 체에\u0007걸친\u0007계획적이고\u0007체계적인\u0007작업 •\u0007소프트웨어\u0007개발\u0007초기에\u0007소프트웨어의\u0007특성과\u0007 품질 보증 • 프로젝트 추진 과정에서 예상되는 각종 돌발 상황(위험) 요구사항을\u0007철저히\u0007파악하여\u0007품질\u0007목표를\u0007설정 하고,\u0007개발\u0007단계에서는\u0007정형\u0007기술\u0007검토를\u0007통하 을 미리 예상하고 이에 대한 적절한 대책을 수립하는 일 여\u0007품질\u0007목표의\u0007충족\u0007여부를\u0007점검하며,\u0007개발\u0007후 련의 활동이다. 에는\u0007디버깅과\u0007시험\u0007과정을\u0007거침 • 소프트웨어 개발 시 일반적인 위험 요소에는 인력 부족, 예산 관리, 일정 관리, 사용자 요구변경 등이 있으며, 이중 가장 대표적인 위험 요소는 사용자 요구 변경이다. •위 험은 불확실성과 손실을 내재하고 있으며, 위험 관리 는 이러한 위험의 불확실성을 감소시키고, 손실에 대비 하는 작업이다. 69 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 67] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •위 험 관리의 절차 핵심 11.3, 10.3, 07.3, 06.9, 06.3, 05.9, 05.4 185 요구사항 분석 위험 식별 알려지거나\u0007예측\u0007가능한\u0007위험\u0007요소를\u0007파악하는\u0007작업 요구사항 분석의 개요 •\u0007위험이\u0007현실화될\u0007가능성과\u0007실제\u0007발생하였을\u0007때의\u0007 • 소프트웨어 개발의 실제적인 첫 단계로 개발 대상에 문제들을\u0007분석하고\u0007영향력을\u0007파악하는\u0007위험\u0007추산 (Risk\u0007Estimation)\u0007작업을\u0007통해\u0007수행\u0007 대한 사용자의 요구사항을 이해하고 문서화(명세화)하 위험 분석 및 •\u0007위험\u0007추산을\u0007위해\u0007위험표(Risk\u0007Table)를\u0007작성하여\u0007 는 활동을 의미한다. 평가 활용함 •사 용자의 요구를 정확하게 추출하여 목표를 정하고, •\u0007위험표의 구성 요소\u0007:\u0007위험\u0007내용,\u0007위험\u0007범주,\u0007발생\u0007 확률,\u0007영향력,\u0007위험\u0007감시\u0007및\u0007조치 어떤 방식으로 해결할 것인지를 결정한다. 위험 관리 위험을\u0007예방하고\u0007위험\u0007발생\u0007시\u0007대책을\u0007준비하며\u0007문 •요 구사항 분석을 통한 결과는 소프트웨어 설계 단계에 계획 서화하는\u0007작업 서 필요한 기본적인 자료가 되므로 사용자의 요구사항 •\u0007위험 회피(Risk Avoidance) :\u0007위험\u0007관리에\u0007대한\u0007 을 정확하고 일관성있게 분석하여 문서화해야 한다. 최상의\u0007전략으로\u0007위험이\u0007발생될\u0007것을\u0007예상하고\u0007회 피하는\u0007것 •소 프트웨어 분석가에 의해 요구사항 분석이 수행되며, • 위험 감시(Risk Monitoring)\u0007:\u0007위험\u0007요소\u0007징후들에\u0007 이 작업 단계를 요구사항 분석 단계라고 한다. 위험 감시 및 대하여\u0007계속적으로\u0007인지하는\u0007것 조치 요구사항 분석 작업 •\u0007위험 관리(Risk Management) 및 비상 계획 (Contingency Plan) 수립\u0007:\u0007위험\u0007회피\u0007전략이\u0007실 패할\u0007경우\u0007위험에\u0007대해\u0007관리하고,\u0007대비책과\u0007비상\u0007 사용자와의\u0007면담,\u0007설문\u0007조사\u0007및\u0007협조,\u0007각종\u0007문서\u0007검 문제 인식 계획을\u0007수립함 토\u0007등을\u0007통하여\u0007사용자의\u0007요구사항을\u0007찾아냄 추출된\u0007요구사항에\u0007대한\u0007정보를\u0007평가하고\u0007여러\u0007가 평가와 종합 지\u0007해결책을\u0007종합함 핵심 14.3, 13.3, 12.3, 11.6, 11.3, 10.5, 09.8, 08.5, 08.3, 07.5, 06.9, 06.5, 05.4, 04.5, 04.3, 03.8, 02.9, 02.5, 01.9, 01.2, 00.3 평가와\u0007종합을\u0007바탕으로\u0007자료와\u0007제어의\u0007흐름,\u0007기능\u0007 184 형상 관리(SCM) 모델 제작 처리,\u0007동작\u0007행위,\u0007정보\u0007내용\u0007등을\u0007이해하기\u0007쉽도록\u0007 모델로\u0007작성함 • 소프트웨어 개발 과정에서 소프트웨어의 생산물을 확 요구사항\u0007분석\u0007명세서를\u0007작성하고,\u0007소프트웨어의\u0007 인하고 소프트웨어 통제, 변경 상태를 기록하고 보관 문서화와 검토 기능,\u0007성능,\u0007제약\u0007조건\u0007등에\u0007대하여\u0007기술하고\u0007검토함 하는 일련의 관리 작업이다. 요구사항 분석의 어려움 • 소프트웨어 변경의 원인을 알아내고 제어하며 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보하는 사용자와\u0007개발자의\u0007지식\u0007배경의\u0007다양화,\u0007용어\u0007 대화 장벽 작업이다. 불일치\u0007등으로\u0007의사소통\u0007곤란 •소 프트웨어 개발의 전 단계에 적용되는 활동으로, 유 소프트웨어\u0007체계화를\u0007위하여\u0007새로운\u0007개념이\u0007필요 지보수 단계에서 수행된다. 시스템의 복잡도 해지고,\u0007시스템\u0007규모와\u0007대상이\u0007광범위해짐에\u0007따라\u0007 난이도\u0007증가에\u0007의한\u0007소프트웨어의\u0007복잡화 • 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 요구의 변경 사용자\u0007생각의\u0007부정확성,\u0007생각의\u0007반복된\u0007변경 여러 문제점을 해결하여 방해 요인을 최소화하는 것을 중복\u0007현상,\u0007애매모호함,\u0007시험의\u0007어려움,\u0007과거와\u0007다 목적으로 한다. 요구 명세화의 른\u0007현재\u0007상황\u0007등의\u0007내포에\u0007따라\u0007요구\u0007명세서\u0007작성 어려움 • 소프트웨어 형상 항목 : 정의 단계의 문서, 개발 단계의 이\u0007어려움 문서와 프로그램, 프로그램 내의 자료 구조, 유지보수 요구사항 분석가의 자질 단계의 변경 사항 등 • 소프트웨어 개발에 많은 경험을 가지고 있어야 한다. •사 용자의 요구를 정확히 수용하고, 여러 환경을 이해해 야 한다. •설 계에 필요한 자료를 충분히 제공할 수 있어야 한다. •다 방면에 대한 해박한 지식을 가지고 있어야 한다. 70 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 68] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •시 간 배정과 계획 등을 빠른 시간 내에 파악할 수 있어 체계적이고 조직적으로 모아 개발자나 사용자가 편리 야 한다. 하게 사용할 수 있다. •하 드웨어, 소프트웨어를 포함한 컴퓨터에 대한 기술을 • 자료 사전 표기 기호 이해하고 있어야 한다. 기호 의 미 •고 객이 사용할 시스템을 만들어야 하므로 상대의 관점 (고객 관점)에서 문제를 파악할 수 있어야 한다. = 자료의\u0007정의\u0007:\u0007~로\u0007구성되어\u0007있다(is\u0007composed\u0007of) + 자료의\u0007연결\u0007:\u0007그리고(and) 05.5, 05.4, 04.9, 04.5, 04.3, 03.8, 03.5, 02.9, 02.3, 01.9, 01.6, 01.3, 00.10, 00.3 (\u0007\u0007) 자료의\u0007생략\u0007:\u0007생략\u0007가능한\u0007자료(Optional) 핵심 14.8, 14.5, 13.8, 13.6, 12.8, 12.3, 11.6, 11.3, 10.9, 10.5, 10.3, 09.3, 08.9, 08.3, 07.9, 07.5, 07.3, 06.9, 06.5, 06.3, 05.9, 186 자료 흐름도(DFD) [\u0007|\u0007] 자료의\u0007선택\u0007:\u0007또는(or) {\u0007\u0007\u0007} 자료의\u0007반복(Iteration\u0007of) •요 구사항 분석에서 자료의 흐름 및 변환 과정과 기능 을 도형 중심으로 기술하는 방법으로 버블(Bubble) 차 *\u0007\u0007\u0007* 자료의\u0007설명\u0007:\u0007주석(Comment) 트라고도 한다. •시 스템 안의 프로세스, 자료 저장소, 단말 간 자료의 핵심 06.9, 05.9, 04.9, 04.3, 02.9, 02.3, 01.3, 00.7 흐름을 나타내는 그래프로, 자료 흐름과 처리를 중심 188 HIPO 으로 하는 구조적 분석 기법에 이용된다. • 시스템의 분석 및 설계나 문서화할 때 사용되는 기법 •자 료 흐름도는 자료 흐름과 기능을 자세히 표현하기 으로 시스템 실행 과정인 입력, 처리, 출력의 기능을 위해 단계적으로 세분화된다. 나타낸다. • 단계(Level) 0의 자료 흐름도를 배경도라 하는데, 이 •기 본 시스템 모델은 입력, 처리, 출력으로 구성되며, 배경도를 통해 전체 시스템의 범위를 표현한다. 하향식 소프트웨어 개발을 위한 문서화 도구이다. • 각각의 프로세스에 대하여 개별적인 상세화 및 계층화 • 체계적인 문서 관리가 가능하고, 기호, 도표 등을 사용 가 가능하다. 하므로 보기 쉬우며 이해하기도 쉽다. • 자료 흐름도 구성 요소의 일반적 표기법 • 기능과 자료의 의존 관계를 동시에 표현할 수 있다. 기 호 의 미 표기법 • HIPO의 종류 자료를\u0007변환시키는\u0007시스템의\u0007한\u0007부분(처 프로세스 가시적 도표 시스템의\u0007전체적인\u0007기능과\u0007흐름을\u0007보여주 리\u0007과정)을\u0007나타내며,\u0007처리,\u0007기능,\u0007변환,\u0007버 (Process) (도식 목차) 는\u0007계층(Tree)\u0007구조도 블이라고도\u0007함\u0007 프로그램을\u0007구성하는\u0007기능을\u0007기술한\u0007것으 자료\u0007흐름(Flow) 자료의\u0007이동을\u0007나타냄\u0007\u0007 ▶ 총체적 도표 로\u0007입력,\u0007처리,\u0007출력에\u0007대한\u0007전반적인\u0007정보 (개요 도표, 총괄 도표) 자료\u0007저장소 시스템에서의\u0007자료\u0007저장소(파일,\u0007데이터 를\u0007제공하는\u0007도표 (Data\u0007Store) 베이스)를\u0007나타냄\u0007 세부적 도표 총체적\u0007도표에\u0007표시된\u0007기능을\u0007구성하는\u0007기 시스템과\u0007교신하는\u0007외부\u0007개체로,\u0007입력\u0007데 (상세 도표) 본\u0007요소들을\u0007상세히\u0007기술하는\u0007도표 단말 이터가\u0007만들어지고,\u0007출력\u0007데이터를\u0007받음 (Terminator) (정보의\u0007생산자와\u0007소비자)\u0007 핵심 04.3, 03.3, 00.10, 00.3, 99.10 189 구조적 설계의 주요 기본 원리 핵심 14.8, 14.5, 13.3, 12.5, 11.8, 11.6, 10.3, 09.8, 09.5, 09.3, 08.9, 08.3, 07.9, 07.5, 06.9, 04.3, 02.9, 01.6, 99.4 187 자료 사전(DD) 모듈화 소프트웨어를\u0007모듈\u0007단위로\u0007나누는\u0007것 (Modularity) • 자료 흐름도 상에 있는 자료를 더 자세히 정의하고 기 록한 것이며, 이처럼 데이터를 설명하는 데이터를 데이 터의 데이터 또는 메타 데이터(Meta Data)라고 한다. • 자료 흐름도에 시각적으로 표시된 자료에 대한 정보를 71 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 69] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 모듈 간과 외부 개체 간의 연결 복잡성을 줄이는 인터 •\u0007문제의\u0007세부\u0007사항을\u0007먼저\u0007설계하기보다는\u0007전체적이고\u0007 포괄적인\u0007개념을\u0007설계한\u0007후\u0007차례로\u0007세분화하여\u0007구체화 페이스를 가져야 한다. 시켜\u0007나가는\u0007설계\u0007방법 •요 구사항 분석에서 얻어진 정보를 이용하여 반복적인 •\u0007기능 추상화\u0007:\u0007입력\u0007자료를\u0007출력\u0007자료로\u0007변환하는\u0007과정 추상화 을\u0007추상화하는\u0007방법 방법으로 이루어져야 한다. (Abstraction) •제\u0007 어 추상화\u0007:\u0007제어의\u0007정확한\u0007메커니즘(절차,\u0007방법)을\u0007정 •모 듈의 기능을 예측할 수 있도록 정의한다. 의하지\u0007않고\u0007원하는\u0007효과를\u0007정하는\u0007데\u0007이용하는\u0007방법 •자\u0007 료 추상화\u0007:\u0007자료와\u0007자료에\u0007적용될\u0007수\u0007있는\u0007기능을\u0007함 •적 당한 모듈의 크기를 유지하고, 모듈 간의 상호 의존도 께\u0007정의함으로써\u0007자료\u0007객체를\u0007구성하는\u0007방법 (결합도)는 약하게, 모듈의 응집도는 강하게 설계한다. •\u0007한\u0007모듈\u0007내부에\u0007포함된\u0007절차와\u0007자료들의\u0007정보가\u0007감추 •이 식성을 고려한다. 어져\u0007다른\u0007모듈이\u0007접근하거나\u0007변경하지\u0007못하도록\u0007하는\u0007 정보 은닉 기법 (Information •\u0007모듈을\u0007독립적으로\u0007수행할\u0007수\u0007있고,\u0007하나의\u0007모듈이\u0007변 01.9, 01.6, 01.3 Hiding) 핵심 14.5, 14.3, 13.6, 12.5, 11.6, 11.3, 10.9, 10.5, 09.5, 08.9, 06.9, 06.5, 05.5, 05.4, 05.3, 04.9, 03.8, 03.5, 03.3, 02.9, 02.3, 경되더라도\u0007다른\u0007모듈에\u0007영향을\u0007주지\u0007않으므로\u0007수정,\u0007 191 결합도(Coupling) 시험,\u0007유지보수가\u0007용이함 •\u0007\u0007소프트웨어의\u0007구성\u0007요소인\u0007모듈의\u0007계층적\u0007구성을\u0007나타 •모듈 간에 상호 의존하는 정도를 나타낸다. 내는\u0007것(제어\u0007계층\u0007구조) •독 립적인 모듈이 되기 위해서는 각 모듈 간의 결합도 •\u0007프로그램의\u0007순서,\u0007선택,\u0007반복과\u0007같은\u0007소프트웨어의\u0007절 차적인\u0007처리\u0007과정을\u0007나타내지\u0007않음 가 약해야 하며 의존하는 모듈이 적어야 한다. •공\u0007 유도(Fan-In)\u0007:\u0007어떤\u0007모듈을\u0007제어(호출)하는\u0007모듈의\u0007 • 결합도의 종류(자료 결합도 < 스탬프 결합도 < 제어 결 프로그램 수 합도 < 외부 결합도 < 공통 결합도 < 내용 결합도) 구조 • 제어도(Fan-Out)\u0007:\u0007어떤\u0007모듈에\u0007의해\u0007제어(호출)되는\u0007 모듈의\u0007수 • 주종적 모듈(Superordinate)\u0007:\u0007다른\u0007모듈을\u0007제어(호출) •\u0007모듈\u0007간의\u0007인터페이스가\u0007자료\u0007요소로만\u0007구성될\u0007 하는\u0007모듈 자료 결합도 때의\u0007결합도 •종\u0007 속적 모듈(Subordinate)\u0007:\u0007어떤\u0007모듈에\u0007의해\u0007제어되 (Data •\u0007어떤\u0007모듈이\u0007다른\u0007모듈을\u0007호출하면서\u0007매개\u0007변수,\u0007 Coupling) 인수로\u0007데이터를\u0007넘겨주고,\u0007호출받은\u0007모듈은\u0007받 는\u0007모듈 은\u0007데이터에\u0007대한\u0007처리\u0007결과를\u0007다시\u0007돌려주는\u0007것 자료\u0007사이의\u0007논리적인\u0007관계를\u0007표현한\u0007것으로\u0007자료의\u0007 자료 구조 •\u0007모듈\u0007간의\u0007인터페이스로\u0007배열이나\u0007레코드\u0007등의\u0007 구성,\u0007결합\u0007정도,\u0007접근\u0007방법\u0007등을\u0007나타냄 자료\u0007구조가\u0007전달될\u0007때의\u0007결합도 스탬프(검인) •\u0007두\u0007모듈이\u0007동일한\u0007자료\u0007구조를\u0007조회하는\u0007경우의\u0007 결합도(Stamp 결합도이며\u0007자료\u0007구조의\u0007어떠한\u0007변화,\u0007즉\u0007포맷이 핵심 14.8, 13.8, 13.6, 13.3, 12.3, 11.8, 11.6, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 06.3, 04.5, 03.3, 02.9, 00.7, 00.3 Coupling) 나\u0007구조의\u0007변화는\u0007그것을\u0007조회하는\u0007모든\u0007모듈\u0007및\u0007 190 바람직한 설계의 특징 변화되는\u0007필드를\u0007실제로\u0007조회하지\u0007않는\u0007모듈에까 지도\u0007영향을\u0007미치게\u0007됨 • 설계는 소프트웨어 구조를 나타내야 한다. •\u0007어떤\u0007모듈이\u0007다른\u0007모듈\u0007내부의\u0007논리적인\u0007흐름을\u0007 제어하기\u0007위해\u0007제어\u0007신호를\u0007이용하여\u0007통신하거나\u0007 •전 체적이고 포괄적인 개념을 설계한 후 차례로 세분화 제어\u0007요소(Function\u0007Code,\u0007Switch,\u0007Tag,\u0007Flag)를\u0007 하여 구체화시켜나간다. 전달하는\u0007결합도 제어 결합도 •\u0007상위\u0007모듈이\u0007하위\u0007모듈의\u0007상세한\u0007처리\u0007절차를\u0007알 •요 구사항을 모두 구현해야 하고 유지보수가 용이해야 (Control 고\u0007있어\u0007이를\u0007통제한\u0007경우나\u0007처리\u0007기능이\u0007두\u0007모듈 한다. Coupling) 에\u0007분리되어\u0007설계된\u0007경우에\u0007발생함 •독 립적인 기능적 특성을 가진 요소(모듈)로 구성되어 •\u0007하위\u0007모듈에서\u0007상위\u0007모듈로\u0007제어\u0007신호가\u0007이동하 여\u0007상위\u0007모듈에게\u0007처리\u0007명령을\u0007부여하는\u0007권리\u0007전 야 한다. 도현상이\u0007발생함 • 모듈 구조, 즉 특정 기능 또는 부기능을 수행하는 논리 •\u0007어떤\u0007모듈에서\u0007외부로\u0007선언한\u0007데이터(변수)를\u0007다 외부 결합도 적 요소들로 분리되는 구조를 가져야 한다. 른\u0007모듈에서\u0007참조할\u0007때의\u0007결합도 (External •\u0007참조되는\u0007데이터의\u0007범위를\u0007각\u0007모듈에서\u0007제한할\u0007 •소 프트웨어 요소(모듈) 간의 효과적인 제어를 위해 설 Coupling) 수\u0007있음 계에서 계층적 자료 조직이 제시되어야 한다. • 자료와 프로시저에 대한 분명하고 분리된 표현을 포함 해야 한다. 72 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 70] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •\u0007공유되는\u0007공통\u0007데이터\u0007영역을\u0007여러\u0007모듈이\u0007사용 핵심 14.5, 11.3, 08.9, 07.5, 07.3, 06.3, 05.9, 04.5, 04.3, 03.3, 01.3, 99.8 193 효과적인 모듈화 설계 방안 공통 결합도 할\u0007때의\u0007결합도 (Common •\u0007공통\u0007데이터\u0007영역의\u0007내용을\u0007조금만\u0007변경하여도\u0007 •결 합도는 줄이고 응집도는 높여서 모듈의 독립성을 높 Coupling) 이를\u0007사용하는\u0007모든\u0007모듈에\u0007영향을\u0007미치므로\u0007모 듈의\u0007독립성을\u0007약하게\u0007만듦 인다. •\u0007한\u0007모듈이\u0007다른\u0007모듈의\u0007내부\u0007기능\u0007및\u0007그\u0007내부\u0007자 •모 듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지 내용 결합도 료를\u0007직접\u0007참조하거나\u0007수정할\u0007때의\u0007결합도 (Content 시킨다. •\u0007한\u0007모듈에서\u0007다른\u0007모듈의\u0007내부로\u0007제어가\u0007이동하 Coupling) 는\u0007경우에\u0007발생함 •복잡도와 중복성을 줄이고 일관성을 유지시킨다. •모 듈의 기능은 예측이 가능해야 하며 지나치게 제한적 99.10, 99.8, 99.4 이어서는 안 된다. 핵심 14.8, 14.3, 12.8, 12.5, 12.3, 10.9, 09.3, 08.5, 06.5, 05.9, 04.3, 03.8, 03.5, 03.3, 02.5, 01.6, 01.3, 00.10, 00.7, 00.3, 192 응집도(Cohesion) • 유지보수가 용이해야 한다. • 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하 •정 보 은닉 개념을 확장한 것으로 모듈 안의 요소들이 기 쉬운 크기로 분해한다. 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으 로 정의되어 있는 정도를 나타낸다. • 하나의 입구와 하나의 출구를 갖도록 해야 한다. •모 듈의 내부 요소에는 특정 작업을 수행하기 위한 명 •인 덱스 번호나 기능 코드들이 전반적인 처리 논리 구 령어, 명령어의 모임, 호출문 등이 있다. 조에 예기치 못한 영향을 끼치지 않도록 모듈 인터페 이스를 설계해야 한다. •독 립적인 모듈이 되기 위해서는 각 모듈의 응집도가 강해야 한다. • 응집도 종류(우연적 응집도 < 논리적 응집도 < 시간적 핵심 12.8, 09.5, 07.3, 05.5, 05.4, 03.8, 01.6, 00.7, 99.8 응집도 < 절차적 응집도 < 교환적 응집도 < 순차적 응 194 N-S 차트(Nassi-Schneiderman Chart) 집도 < 기능적 응집도) •논 리의 기술에 중점을 둔 도형을 이용한 표현 방법(박 기능적(Functional) 모듈\u0007내부의\u0007모든\u0007기능\u0007요소들이\u0007단일\u0007문제 스 다이어그램, Chapin Chart)이다. 응집도 와\u0007연관되어\u0007수행될\u0007경우의\u0007응집도 • 순차(연속, Sequence) 구조, 반복(While, Do ~ 모듈\u0007내의\u0007하나의\u0007활동으로부터\u0007나온\u0007출력\u0007 순차적(Sequential) Until) 구조, 선택(If~Then~Else) 구조, 다중 선택 데이터를\u0007그\u0007다음\u0007활동의\u0007입력\u0007데이터로\u0007사 응집도 (Case) 구조 등을 표현한다. 용할\u0007경우의\u0007응집도 •G OTO나 화살표를 사용하지 않으며, 선택과 반복 구 교환(통신)적 동일한\u0007입력과\u0007출력을\u0007사용하여\u0007서로\u0007다른\u0007 (Communication) 기능을\u0007수행하는\u0007구성\u0007요소들이\u0007모여\u0007있을\u0007 조를 시각적으로 표현한다. 응집도 경우의\u0007응집도 •조 건이 복합되어 있는 곳의 처리를 시각적으로 명확히 모듈이\u0007다수의\u0007관련\u0007기능을\u0007가질\u0007때\u0007모듈\u0007안 절차적(Procedural) 식별하는 데 적합하다. 의\u0007구성\u0007요소들이\u0007그\u0007기능을\u0007순차적으로\u0007수 응집도 행할\u0007경우의\u0007응집도 •이 해하기 쉽고, 코드 변환이 용이하다. 시간적(Temporal) 특정\u0007시간에\u0007처리되는\u0007몇\u0007개의\u0007기능을\u0007모아\u0007 • 읽기는 쉽지만 작성하기가 어려우며, 임의로 제어를 응집도 하나의\u0007모듈로\u0007작성할\u0007경우의\u0007응집도 전이하는 것이 불가능하다. 유사한\u0007성격을\u0007갖거나\u0007특정\u0007형태로\u0007분류되 논리적(Logical) 는\u0007처리\u0007요소들로\u0007하나의\u0007모듈이\u0007형성되는\u0007 응집도 경우의\u0007응집도 핵심 13.8, 07.5, 06.5, 05.5, 05.4, 05.3, 04.9, 02.3, 01.9, 99.10 195 구현 / 프로그래밍 언어 선정 기준 / 구조적 프로그래밍 우연적(Coincidental) 모듈\u0007내부의\u0007각\u0007구성\u0007요소들이\u0007서로\u0007관련\u0007없 응집도 는\u0007다른\u0007기능을\u0007수행하는\u0007경우의\u0007응집도 구현 설계 단계에서 생성된 설계 명세서를 컴퓨터가 알 수 있 는 모습으로 변환하는 과정으로 프로그래밍 또는 코딩 단계라고도 하며, 각 모듈을 특정 프로그래밍 언어를 이 73 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 71] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 용하여 원시 코드로 작성하고 문서화하는 작업이다. 조건 검사 프로그램\u0007모듈\u0007내에\u0007있는\u0007논리적\u0007조건을\u0007 (Condition Testing) 검사하는\u0007검사\u0007사례\u0007설계\u0007기법 프로그래밍 언어 선정 기준 루프 검사 프로그램의\u0007반복(Loop)\u0007구조에\u0007초점을\u0007 친밀감, 프로그램 구조, 언어의 능력, 프로그램의 길이, (Loop Testing) 맞춰\u0007실시하는\u0007검사\u0007사례\u0007설계\u0007기법 처리의 효율성, 이식성, 과거의 개발 실적, 대상 업무의 프로그램에서\u0007변수의\u0007정의와\u0007변수\u0007사용의\u0007 성격, 알고리즘과 계산상의 난이도, 소프트웨어의 수행 데이터 흐름 검사 위치에\u0007초점을\u0007맞춰\u0007실시하는\u0007검사\u0007사례\u0007 (Data Flow Testing) 환경, 자료 구조의 난이도, 개발 담당자의 경험과 지식 등 설계\u0007기법 구조적 프로그래밍 • Dijkstra에 의해 제안된 것으로, 신뢰성 있는 소프트웨 핵심 12.8, 10.9, 09.3, 08.9, 05.3, 04.5, 02.5 어의 생산과 코딩의 표준화 등을 위해 개발된 방법이다. 197 제어 흐름도 / 순환 복잡도 •구 조적 프로그래밍의 기본적인 제어 구조 제어 흐름도 제어\u0007흐름을\u0007표현하기\u0007위해\u0007사용되는\u0007그래프 순차(Sequence) 명령을\u0007순서적으로\u0007나열함 •\u0007한\u0007프로그램의\u0007논리적인\u0007복잡도를\u0007측정하기\u0007위한\u0007소 프트웨어의\u0007척도로,\u0007제어\u0007흐름도\u0007이론에\u0007기초를\u0007둠 선택(Selection) 특정\u0007논리에\u0007기초하여\u0007명령을\u0007선택함\u0007 •\u0007순환\u0007복잡도를\u0007이용하여\u0007계산된\u0007값은\u0007프로그램의\u0007독 반복(Iteration) 순환을\u0007제공함 립적인\u0007경로의\u0007수를\u0007정의하고,\u0007모든\u0007경로가\u0007한\u0007번\u0007이 순환 복잡도 상\u0007수행되었음을\u0007보장하기\u0007위해\u0007행해지는\u0007테스트\u0007횟 수의\u0007상한선을\u0007제공함 핵심 14.8, 14.5, 13.6, 12.5, 12.3, 11.3, 10.9, 08.3, 07.9, 07.5, 06.9, 06.5, 06.3, 05.9, 05.4, 04.9, 03.3, 01.9, 00.7, 99.8 •순\u0007 환 복잡도 계산(V(G))\u0007:\u0007영역\u0007수(경계된\u0007영역과\u0007그 196 화이트 박스 테스트(White Box Test) 래프\u0007외부의\u0007비경계\u0007영역의\u0007수)를\u0007계산하거나\u0007V(G)\u0007 =\u0007E\u0007-\u0007N\u0007+\u00072로\u0007계산(E는\u0007화살표\u0007수,\u0007N은\u0007노드\u0007수) •모 듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 검사하여 검사 사례를 설계하는 01.6, 01.3, 99.4 방법이다. 핵심 14.8, 14.3, 13.8, 13.3, 12.8, 11.8, 11.6, 10.9, 10.5, 10.3, 09.8, 08.9, 08.5, 07.9, 07.3, 05.5, 05.3, 04.5, 03.5, 02.9, 02.5, 198 블랙 박스 테스트 • 설계된 절차에 초점을 둔 구조적 테스트로, 프로시저 설계의 제어 구조를 사용하여 검사 사례를 설계하며, •소 프트웨어 인터페이스에서 실시되는 검사로, 소프트웨 테스트 과정의 초기에 적용된다. 어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 검사로, 기능 검사라고도 한다. • 모듈 안의 작동을 직접 관찰할 수 있다. •부 정확하거나 누락된 기능, 인터페이스 오류, 자료 구조 • 원시 코드의 모든 문장을 한 번 이상 수행함으로써 수 나 외부 데이터베이스 접근에 따른 오류, 행위나 성능 행된다. 오류, 초기화와 종료 오류 등을 발견하기 위해 사용되며 •프 로그램의 제어 구조에 따라 선택, 반복 등의 부분들 테스트 과정의 후반부에 적용된다. 을 수행함으로써 논리적 경로를 제어한다. •소 프트웨어 산물의 각 기능별로 적절한 정보 영역(입· •각 조건에서의 참과 거짓의 모든 논리적 결정이 적어 출력)을 정하여 적합한 입력에 대한 출력의 정확성을 점 도 한 번 이상 실행된다. 검한다. •논 리 흐름도, 루프 구조, 순환 복잡도에 관한 오류를 • 블랙 박스 테스트의 종류 찾을 수 있다. - 동치 분할 검사(Equivalence Partitioning Testing) • 종류 : 입력 자료에 초점을 맞춰 검사 사례를 만들고 검사 하는 방법으로, 프로그램의 입력 조건에 타당한 입 •\u0007Tom\u0007McCabe가\u0007제안한\u0007것으로\u0007대표적인\u0007 화이트\u0007박스\u0007테스트\u0007기법 력 자료와 타당하지 않은 입력 자료의 개수를 균등 기초 경로 검사 •\u0007검사\u0007사례\u0007설계자가\u0007절차적\u0007설계의\u0007 하게 하여 검사 사례를 정함 (Basic Path Testing) 논리적\u0007복잡성을\u0007측정할\u0007수\u0007있게\u0007해주고,\u0007 - 경계값 분석(Boundary Value Analysis) : 입력 자 이\u0007측정\u0007결과는\u0007실행\u0007경로의\u0007기초를\u0007 정의하는\u0007데\u0007치침으로\u0007사용됨 료에만 치중한 동치 분할 기법을 보완하기 위한 기 법으로, 입력 조건의 중간값보다 경계값에서 오류가 74 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 72] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 발생될 확률이 높다는 점을 이용하여 입력 조건의 검증(확인, 인수) 검사 경계값을 검사 사례로 선정하여 검사함 •소 프트웨어가 사용자의 요구사항을 충족시키는가에 - 원인-효과 그래프 검사(Cause-effect graphing 중점을 두고 검사하는 방법이다. testing) : 입력 데이터 간의 관계와 출력에 영향을 • 통합 검사가 끝난 후 전체가 하나의 소프트웨어 단위 미치는 상황을 체계적으로 분석하여 효용성 높은 검 로 통합되어 요구사항 명세서를 토대로 진행하며, 블 사 사례를 선정하여 검사하는 기법 랙 박스 테스트 기법을 사용한다. - 오류 예측 검사(Fault based testing) = Mutation • 검증 검사의 종류 Testing : 과거의 경험이나 확인자의 감각으로 검사 하는 기법 형상 소프트웨어\u0007구성\u0007요소,\u0007목록,\u0007유지보수를\u0007지원하기\u0007 검사(구성 위해\u0007필요한\u0007모든\u0007사항들이\u0007제대로\u0007표현되었는지를\u0007 - 비교 검사(Comparison Testing) : 여러 버전의 프 검토, 감사) 검사하는\u0007기법 로그램에 동일한 검사 자료를 제공하여 동일한 결과 •\u0007개발자의\u0007장소에서\u0007사용자가\u0007개발자\u0007앞에서\u0007행하 가 출력되는지 검사하는 기법 는\u0007검사\u0007기법 알파 검사 •\u0007통제된\u0007환경에서\u0007행해지며,\u0007오류와\u0007사용상의\u0007문제 점을\u0007사용자와\u0007개발자가\u0007함께\u0007확인하면서\u0007기록함 00.3, 99.10 핵심 14.5, 13.8, 13.6, 13.3, 12.3, 11.6, 10.9, 10.5, 10.3, 09.8, 06.5, 05.9, 05.5, 05.3, 04.5, 04.3, 03.5, 03.3, 02.5, 02.3, 00.10, •\u0007선정된\u0007최종\u0007사용자가\u0007여러\u0007명의\u0007사용자\u0007앞에서\u0007 199 검사 전략 수행하는\u0007검사\u0007기법 •\u0007실업무를\u0007가지고\u0007사용자가\u0007직접\u0007시험하는\u0007것으로,\u0007 베타 검사 (cid:2342)(cid:2333)(cid:3118)(cid:1)(cid:1173)(cid:3295) (cid:52) 개발자에\u0007의해\u0007제어되지\u0007않은\u0007상태에서\u0007검사가\u0007행 (cid:2563)(cid:1203)(cid:2190)(cid:3302) (cid:51) 해지며,\u0007발견된\u0007오류와\u0007사용상의\u0007문제점을\u0007기록하 (cid:2232)(cid:1157) (cid:37) 고\u0007개발자에게\u0007주기적으로\u0007보고함 (cid:3023)(cid:1624) (cid:36) (cid:54) (cid:1521)(cid:2596)(cid:1)(cid:1128)(cid:2190) (cid:42) (cid:3134)(cid:3300)(cid:1)(cid:1128)(cid:2190) 시스템 검사(System Test) (cid:55) (cid:1128)(cid:2768)(cid:1)(cid:1128)(cid:2190) •개 발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 (cid:52)(cid:53) (cid:2342)(cid:2333)(cid:3118)(cid:1)(cid:1128)(cid:2190) 수행되는가를 검사하는 것이다. • 시스템 검사의 종류 단위 검사 • 코딩이 이루어진 후 소프트웨어 설계의 최소 단위인 소프트웨어에\u0007여러\u0007가지\u0007결함을\u0007주어\u0007실패하도록\u0007한\u0007 복구 검사 모듈에 초점을 맞추어 검사하는 것이다. 후\u0007올바르게\u0007복구되는지를\u0007확인하는\u0007검사 • 화이트 박스 검사 기법을 사용하며, 인터페이스, 외부 시스템\u0007내에\u0007설치된\u0007보호\u0007도구가\u0007부적당한\u0007침투로부 보안 검사 터\u0007시스템을\u0007보호할\u0007수\u0007있는지를\u0007확인하는\u0007검사 적 I/O, 자료 구조, 경계 조건 등을 검사한다. 비정상적인\u0007상황에서\u0007소프트웨어를\u0007실행시키기\u0007위 하향식 통합 검사 강도 검사 한\u0007검사로\u0007비정상적인\u0007양,\u0007빈도\u0007등의\u0007자원을\u0007요구하 • 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하 는\u0007환경에서\u0007소프트웨어를\u0007실행시킴 면서 검사하는 기법이다. 통합된\u0007시스템에서\u0007소프트웨어의\u0007실행\u0007시간을\u0007검사 성능 검사 하기\u0007위한\u0007것으로,\u0007검사\u0007단계의\u0007전\u0007과정에\u0007걸쳐\u0007수 • 일시적으로 필요한 조건만을 가지는 임시로 제공되는 행됨 시험용 모듈 스터브(Stub)가 필요하다. 상향식 통합 검사 디버깅 • 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하 검사 단계에서 검사 사례에 의해 오류를 찾은 후 그 오류 면서 검사하는 기법이다. 를 수정하는 과정으로, 디버깅 접근법에는 맹목적 강요, 역추적, 원인 제거 등이 있다. • 가장 하위 단계의 모듈부터 통합 및 검사가 수행되므로 스터브(Stub)는 필요하지 않지만 하나의 주요 제어 모 듈과 관련된 종속 모듈의 그룹인 클러스터가 필요하다. 75 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 73] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 04.9, 03.8, 03.5, 02.9, 01.6, 01.3, 00.10, 00.7 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.3, 11.8, 11.6, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 07.9, 05.9, 05.5, 05.3, • 현실 세계를 그대로 모형화하므로 사용자와 개발자가 200 유지보수 쉽게 이해할 수 있다. •개 발된 소프트웨어의 품질을 항상 최상의 상태로 유지 • 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해 하기 위한 것으로 소프트웨어 개발 단계 중 가장 많은 결책으로 채택되어 사용되고 있다. 노력과 비용이 투입되는 단계이다. •소 프트웨어의 재사용 및 확장을 용이하게 함으로써 고 • 소프트웨어가 사용자에게 인수되고, 설치된 후 발생하 품질의 소프트웨어를 빠르게 개발할 수 있으며 유지보 는 모든 공학적 작업이다. 수가 쉽다. • 소프트웨어 유지보수를 용이하게 하려면 시험 용이성, •객 체지향 기법의 구성 요소 이해성, 수정 용이성, 이식성 등이 고려되어야 한다. •\u0007객체가\u0007가지고\u0007있는\u0007정보로\u0007속성이나\u0007상태,\u0007분류\u0007 • 유지보수의 유형 데이터 등을\u0007나타냄 •\u0007속성(Attribute),\u0007상태,\u0007변수,\u0007상수,\u0007자료\u0007구조라고도\u0007함 수정(Corrective) 시스템을\u0007운영하면서\u0007검사\u0007단계에서\u0007발견하지\u0007 보수=수리·교정· •\u0007객체가\u0007수행하는\u0007기능으로\u0007객체가\u0007갖는\u0007데이터(속 못한\u0007잠재적인\u0007오류를\u0007찾아\u0007수정하는\u0007활동 정정·하자 보수 성,\u0007상태)를\u0007처리하는\u0007알고리즘 객체 •\u0007객체의\u0007상태를\u0007참조하거나\u0007변경하는\u0007수단이\u0007되는\u0007 소프트웨어의\u0007수명\u0007기간\u0007중에\u0007운영체제나\u0007컴파 것으로,\u0007객체가\u0007메시지를\u0007받아\u0007실행해야\u0007할\u0007객체의\u0007 적응(Adaptive) 일러와\u0007같은\u0007프로그래밍\u0007환경\u0007변화와\u0007주변장치\u0007 함수 구체적인\u0007연산을\u0007정의함\u0007 보수=환경 적응, 또는\u0007다른\u0007시스템\u0007요소가\u0007향상되거나\u0007변경될\u0007 •\u0007메소드(Method,\u0007행위),\u0007서비스(Service),\u0007동작 조정 보수 때\u0007기존의\u0007소프트웨어에\u0007반영하기\u0007위하여\u0007수행 (Operation),\u0007연산이라고도\u0007함 하는\u0007활동 •\u0007기존의\u0007구조적\u0007기법에서의\u0007함수,\u0007프로시저에\u0007해당 •\u0007소프트웨어의\u0007본래\u0007기능에\u0007새로운\u0007기능을\u0007 하는\u0007연산\u0007기능 완전화 추가하거나\u0007성능을\u0007개선하기\u0007위해\u0007소프트웨 (Perfective) •\u0007공통된\u0007속성과\u0007연산(행위)을\u0007갖는\u0007객체의\u0007집합으로\u0007 어를\u0007확장시키는\u0007활동 보수=기능 개선, 객체의\u0007일반적인\u0007타입(Type)을\u0007의미함 •\u0007유지보수\u0007활동\u0007중\u0007가장\u0007큰\u0007업무\u0007및\u0007비용을\u0007 기능 보수 클래스 •\u0007각각의\u0007객체들이\u0007갖는\u0007속성과\u0007연산을\u0007정의하고\u0007있 차지하는\u0007활동 (Class) 는\u0007틀 장래의\u0007유지보수성\u0007또는\u0007신뢰성을\u0007개선하거나\u0007 •\u0007클래스에\u0007속하는\u0007각각의\u0007구체적인\u0007객체를\u0007인스턴 예방(Preventive) 소프트웨어의\u0007오류\u0007발생에\u0007대비하여\u0007미리\u0007 스(Instance)라고\u0007함 보수 예방\u0007수단을\u0007강구해\u0007두는\u0007활동 •\u0007객체들\u0007간에\u0007상호작용을\u0007하는\u0007데\u0007사용되는\u0007수단으 로\u0007객체에게\u0007어떤\u0007행위를\u0007하도록\u0007지시하는\u0007명령 메시지 •\u0007메시지의 구성 요소\u0007:\u0007메시지를\u0007받는\u0007객체(수신자) (Message) 핵심 04.9, 03.3, 01.9, 01.6 의\u0007이름,\u0007객체가\u0007수행할\u0007메소드\u0007이름,\u0007메소드를\u0007수 201 외계인 코드 행할\u0007때\u0007필요한\u0007인자(속성값) • 아주 오래 전에 개발되어 유지보수 작업이 매우 어려 05.5, 05.3, 04.9, 04.5, 04.3, 03.8, 02.9, 02.3, 01.9, 00.3 운 프로그램이다. 핵심 14.5, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.5, 09.8, 09.5, 08.9, 08.5, 08.3, 07.9, 07.5, 06.9, 06.5, 06.3, 203 객체지향 기법의 주요 기본 원칙 • 일반적으로 15년 전 또는 그 전에 개발된 프로그램을 의미하며, 프로그램 내에 문서화(Documentation)를 •\u0007데이터와\u0007데이터를\u0007처리하는\u0007함수를\u0007하나로\u0007묶 철저하게 해 두면 외계인 코드를 방지할 수 있다. 는\u0007것 •\u0007캡슐화된\u0007객체의\u0007세부\u0007내용이\u0007외부에\u0007은폐(정보\u0007 04.9, 04.5, 04.3, 03.5, 03.3, 02.9, 02.5, 01.6, 01.3, 00.10, 00.7 캡슐화 은폐)되어,\u0007변경이\u0007발생해도\u0007오류의\u0007파급\u0007효과 핵심 14.8, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.6, 11.3, 10.9, 10.5, 10.3, 08.5, 08.3, 07.9, 07.5, 07.3, 06.9, 06.5, 06.3, 05.4, (Encapsulation) 가\u0007적음 202 객체지향 기법 •\u0007캡슐화된\u0007객체들은\u0007재사용이\u0007용이함 •\u0007인터페이스가\u0007단순해지고\u0007객체\u0007간의\u0007결합도가\u0007 • 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 낮아짐 객체(Object)로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 작성할 수 있도록 하는 기법이다. 76 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 74] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •B ooch(부치) 방법 : 미시적(Micro) 개발 프로세스와 거 •\u0007캡슐화에서\u0007가장\u0007중요한\u0007개념으로\u0007다른\u0007객체에 정보 은닉(은폐) 게\u0007자신의\u0007정보를\u0007숨기고\u0007연산만을\u0007통하여\u0007접 시적(Macro) 개발 프로세스를 모두 사용하는 분석 방 (Information 근을\u0007허용하는\u0007것 법으로, 클래스와 객체들을 분석 및 식별하고 클래스 Hiding) •\u0007각\u0007객체의\u0007수정이\u0007다른\u0007객체에게\u0007주는\u0007고려되지\u0007\u0007 의 속성과 연산을 정의함 은\u0007영향(Side\u0007Effect)을\u0007최소화하는\u0007기술 •J acobson 방법 : Use Case를 강조하여 사용하는 분석 •\u0007이미\u0007정의된\u0007상위\u0007클래스(슈퍼\u0007클래스나\u0007부모\u0007 클래스)의\u0007모든\u0007속성과\u0007연산을\u0007하위\u0007클래스가\u0007 방법 물려받는\u0007것 •C oad와 Yourdon 방법 : E-R 다이어그램을 사용하여 •\u0007상속성을\u0007이용하면\u0007하위\u0007클래스는\u0007상위\u0007클래스 상속성 의\u0007모든\u0007속성과\u0007연산을\u0007자신의\u0007클래스\u0007내에서\u0007 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주 (Inheritance) 다시\u0007정의하지\u0007않고서도\u0007즉시\u0007자신의\u0007속성으로\u0007 제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 사용할\u0007수\u0007있음 연결 정의 등의 과정으로 구성하는 기법 •\u0007다중 상속성(Multiple Inheritance)\u0007:\u0007한\u0007개의\u0007클 래스가\u00072개\u0007이상의\u0007상위\u0007클래스로부터\u0007속성과\u0007 •W irfs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 연산을\u0007상속받는\u0007것 명세서를 평가해서 설계 작업까지 연속적으로 수행하 •\u0007불필요한\u0007부분을\u0007생략하고\u0007객체의\u0007속성\u0007중\u0007가장\u0007 는 기법 중요한\u0007것에만\u0007중점을\u0007두어\u0007개략화하는\u0007것,\u0007즉\u0007 모델화하는\u0007것 추상화 07.3, 06.9, 06.5, 06.3, 05.9, 05.5, 05.4, 05.3, 04.9, 03.8, 03.3, 02.5, 02.3, 01.9 •\u0007인간이\u0007복잡한\u0007문제를\u0007다루는\u0007데\u0007가장\u0007기본이\u0007 (Abstraction) 핵심 14.8, 14.5, 14.3, 13.8, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 되는\u0007방법으로,\u0007완전한\u0007시스템을\u0007구축하기\u0007전에\u0007 205 럼바우(Rumbaugh)의 분석 기법 그\u0007시스템과\u0007유사한\u0007모델을\u0007만들어서\u0007여러\u0007가 지\u0007요인들을\u0007테스트할\u0007수\u0007있음 •모 든 소프트웨어 구성 요소를 그래픽 표기법을 이용하 •\u0007메시지에\u0007의해\u0007객체(클래스)가\u0007연산을\u0007수행하게\u0007 여 모델링하는 기법이다. 될\u0007때\u0007하나의\u0007메시지에\u0007대해\u0007각\u0007객체(클래스)가\u0007 다형성 가지고\u0007있는\u0007고유한\u0007방법으로\u0007응답할\u0007수\u0007있는\u0007 •분 석 활동은 객체 모델링, 동적 모델링, 기능 모델링 (Polymorphism) 능력 순으로 이루어진다. •\u0007객체(클래스)들은\u0007동일한\u0007메소드명을\u0007이용하여\u0007 같은\u0007의미의\u0007응답을\u0007함 정보\u0007모델링이라고도\u0007하며,\u0007시스템에서\u0007요구되는\u0007 객체(Object) 객체를\u0007찾아내어\u0007속성과\u0007연산\u0007식별\u0007및\u0007객체들\u0007간의\u0007 모델링 관계를\u0007규정하여\u0007객체\u0007다이어그램으로\u0007표현한\u0007것 핵심 13.6, 12.8, 10.9, 10.3, 01.9, 00.7 상태도를\u0007이용하여\u0007시간의\u0007흐름에\u0007따른\u0007객체들\u0007사 204 객체지향 분석 동적(Dynamic) 이의\u0007제어\u0007흐름,\u0007상호\u0007작용,\u0007동작\u0007순서\u0007등의\u0007동적인\u0007 모델링 행위를\u0007표현한\u0007것 •사 용자의 요구사항을 분석하여 요구된 문제와 관련된 •\u0007자료\u0007흐름도(DFD)를\u0007이용하여\u0007다수의\u0007프로세스 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간 들간의\u0007자료\u0007흐름을\u0007중심으로\u0007처리\u0007과정을\u0007표현 의 관계 등을 정의하여 모델링하는 작업이다. 기능(Functional) 한\u0007것 모델링 •\u0007설계\u0007순서\u0007:\u0007입·출력\u0007결정\u0007→\u0007자료\u0007흐름도\u0007작성\u0007 •분 석가에게 주요한 모델링 구성 요소인 클래스, 객체, →\u0007기능을\u0007상세히\u0007기술\u0007→\u0007제약\u0007사항\u0007결정\u0007및\u0007최 속성, 연산들을 표현해서 문제를 모형화할 수 있게 해 소화 준다. •객 체지향 관점은 모형화 표기법의 전후 관계에서 객체 핵심 14.5, 11.8, 09.5, 09.3, 04.5, 02.5, 01.3, 99.4 의 분류, 속성들의 상속, 그리고 메시지의 통신 등을 206 객체지향 설계 결합한 것이다. •객 체지향 분석(OOA)을 사용해서 생성한 여러 가지 분 •객 체는 클래스로부터 인스턴스화되고, 이 클래스를 식 석 모델을 설계 모델로 변환하는 작업으로, 시스템 설 별하는 것이 객체지향 분석의 주요한 목적이다. 계와 객체 설계를 수행한다. 객체지향 분석의 방법론 •최 근 소프트웨어 제품의 전형적인 타입인 사용자 중 •R umbaugh(럼바우) 방법 : 가장 일반적으로 사용되는 방 심, 대화식 프로그램의 개발에 적합하다. 법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델 로 나누어 수행하는 방법 77 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 75] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •객 체지향 설계에서 가장 중요한 문제는 시스템을 구성 •\u0007객체,\u0007클래스,\u0007상속의\u0007개념을\u0007모두\u0007지원하는\u0007 하는 객체와 속성, 연산을 인식하는 것이다. 가장\u0007좋은\u0007언어 객체지향성 언어 •\u0007초기에\u0007발표된\u0007Simula로부터,\u0007Smalltalk,\u0007C++,\u0007 •객 체지향 설계를 문서화할 때 객체와 그들의 부객체 Objective\u0007C와\u0007같은\u0007언어가\u0007있음 (Sub-object)의 계층적 구조를 보여주는 계층 차트를 그리면 유용하다. 06.9, 06.5, 05.5, 05.4, 05.3, 04.5, 04.3, 03.8, 03.5, 03.3, 02.9, 01.3, 01.6, 99.10 •객 체는 순차적으로(Sequentially) 또는 동시적으로 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.3, 08.5, 08.3, 07.9, 07.5, 07.3, 208 소프트웨어의 재사용 (Concurrently) 구현될 수 있다. •객 체지향 설계의 설계 개념은 추상화, 정보 은닉, 기능 •이 미 개발된 인정받은 소프트웨어의 전체 혹은 일부분 독립성, 모듈화, 상속성을 바탕으로 하며 이 중 가장 을 다른 소프트웨어 개발이나 유지에 사용하는 것이다. 중요한 개념은 모듈화이다. • 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법 •객 체지향 설계에서는 현실 세계에서 사용하는 객체를 으로, 기존에 개발한 소프트웨어와 경험, 지식 등을 새 명사로, 연산이나 객체 서비스를 동사로 표현한다. 로운 소프트웨어에 적용한다. •객 체지향 설계를 위해서 럼바우의 객체지향 설계, 부 •클 래스, 객체 등의 소프트웨어 요소는 소프트웨어 재 치(Booch)의 객체지향 설계, 윌리엄 로렌슨(William 사용성을 크게 향상시켰다. Lorensen)의 객체지향 설계 방법 등이 제안되었으며 잠깐만요 ! 컴포넌트(Component) 이 중 일반적으로 럼바우의 객체지향 설계가 가장 많 객체들의\u0007모임,\u0007대규모\u0007재사용\u0007단위 이 사용된다. •재 사용이 가능한 요소 : 소스 코드(가장 많이 이용), 응용 • 객체지향 설계 단계 : 문제 정의 → 요구 명세화 → 객체 분야에 관한 지식, 논리적인 데이터 모형, 프로세스 구 연산자 정의 → 객체 인터페이스 결정 → 객체 구현 조, 시험 계획, 설계에 관한 결정, 시스템 구조에 관한 지식, 요구 분석 사항, 문서화, 전문적인 기술과 개발 경험, 품질 보증, 응용 분야 지식 등 핵심 05.4, 01.9 207 객체지향 프로그래밍 •소 프트웨어 부품(모듈)의 크기가 작고 일반적인 설계 일수록 재사용률이 높다. • 새로운 개념의 모듈 단위, 즉 객체라는 단위를 중심으 • 소프트웨어 재사용의 이점 : 개발 시간과 비용 단축, 소프 로 하여 프로그램을 개발하는 기법이다. 트웨어 품질 및 생산성 향상, 프로젝트 실패 위험 감 • 객체라는 단위를 이용하여 현실 세계에 가까운 방식으 소, 시스템 구축 방법에 대한 지식 공유, 시스템 명세, 로 프로그래밍한다. 설계, 코드 등 문서 공유 •현 실 세계에 가까운 방식이므로 이해하기 쉽고 조작하 • 재사용 도입의 문제점 기 쉬운 프로그램을 개발할 수 있다. - 어떤 것을 재사용할 것인지 선정해야 한다. •유 지보수가 쉽고 재사용 가능한 프로그램을 만들 수 있다. - 시스템에 공통적으로 사용되는 요소들을 발견해야 • 이미 개발된 프로그램을 이용해 빠르게 확장된 프로그 한다. 램을 개발할 수 있다. - 프로그램의 표준화가 부족하다. • 자연적인 모델링이 가능하고, 소프트웨어의 재사용률 - 새로운 개발 방법론을 도입하기 어렵다. 및 유지보수성이 향상된다. - 재사용을 위한 관리 및 지원이 부족하다. • 객체지향 프로그래밍 언어 - 기존 소프트웨어에 재사용 소프트웨어를 추가하기 어렵다. Ada,\u0007Actor와\u0007같이\u0007객체의\u0007개념만을\u0007지원하는\u0007 객체 기반 언어 언어 클래스 기반 언어 Clu와\u0007같이\u0007객체와\u0007클래스의\u0007개념을\u0007지원하는\u0007언어 78 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 76] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 06.3, 05.5, 03.8, 03.5, 02.9, 02.3, 01.9, 00.10, 99.4 05.9, 05.5, 05.4, 05.3, 04.9, 04.5, 03.8, 03.5, 02.9, 02.5, 02.3, 01.6, 01.3, 00.7 핵심 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 10.3, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.5, 07.3, 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 12.8, 12.5, 12.3, 10.9, 10.5, 10.3, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 07.3, 06.9, 06.3, 209 소프트웨어 재공학 210 CASE • 기존에 있던 소프트웨어를 파기하지 않고 새로운 요구에 • 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 맞도록 기존 시스템을 이용하여 기존 소프트웨어를 수정 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 보완하거나 새로운 기능을 추가하여 소프트웨어 성능을 전용 소프트웨어 도구를 사용하여 자동화하는 것이다. 향상시키는 것으로, 예방 유지보수 측면에서 문제를 해결 • 소프트웨어 생명 주기의 전체 단계를 연결해 주고 자 하는 것이다. 동화해 주는 통합된 도구를 제공해주는 기술이다. • 유지보수 비용이 소프트웨어 개발 비용의 대부분을 차지 • 소프트웨어 개발 도구와 방법론이 결합된 것으로, 정 하는 문제를 고려하여 기존 소프트웨어의 데이터와 기능 형화된 구조 및 방법(메커니즘)을 소프트웨어 개발에 들의 개조 및 개선을 통해 유지보수성과 품질을 향상시키 적용하여 생산성 향상을 구현하는 공학 기법이다. 려는 기술이다. • 소프트웨어 개발의 모든 단계에 걸쳐 일관된 방법론을 •유 지보수 생산성 향상을 통해 소프트웨어 위기를 해결하 지원한다. 는 방법이다. • CASE의 주요 기능 : 소프트웨어 생명주기 전 단계의 연 •소 프트웨어 재공학을 사용하면 위험 부담이 감소되고, 개 결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등 발 비용이 절감된다. • CASE 사용의 이점 : 소프트웨어 개발 기간 단축 및 비 용 절감, 품질 향상, 유지보수 용이, 생산성 향상, 재사 • 소프트웨어 재공학도 자동화된 도구를 사용하여 소프트 용성 향상, 개발 주기의 표준화, 개발 기법의 실용화, 웨어를 분석하고 수정하는 과정을 포함한다. 문서화 용이 등 주요 활동 •CASE 분류 •분 석(Analysis) : 기존 소프트웨어의 명세서를 확인하여 소 프트웨어의 동작을 이해하고, 재공학 대상을 선정하는 것 소프트웨어\u0007생명\u0007주기의\u0007전반부에서\u0007사용되는\u0007 상위(Upper) 것으로,\u0007문제를\u0007기술(Description)하고\u0007계획하며\u0007 •개 조(재구조, 재구성, Restructuring) CASE 요구\u0007분석과\u0007설계\u0007단계를\u0007지원하는\u0007CASE - 상대적으로 같은 추상적 수준에서 하나의 표현을 다른 소프트웨어\u0007생명\u0007주기의\u0007하반부에서\u0007사용되는\u0007 표현 형태로 바꾸는 것이다. 하위(Lower) 것으로\u0007코드의\u0007작성과\u0007테스트,\u0007문서화하는\u0007 CASE - 기존 소프트웨어의 구조를 향상시키기 위하여 코드를 과정을\u0007지원하는\u0007CASE 재구성하는 것으로 소프트웨어의 기능과 외적인 동작 통합(Intergrate) 소프트웨어\u0007생명\u0007주기에\u0007포함되는\u0007전체\u0007과정을\u0007 은 바뀌지 않는다. CASE 지원하기\u0007위한\u0007CASE •역 공학(Reverse Engineering) • 정보 저장소(CASE 정보 저장소) : 소프트웨어를 개발하 - 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 는 동안에 모아진 정보를 보관하여 관리하는 곳으로, 정 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재 보 저장소에 저장된 정보는 사용자, 도구, 응용 프로그 발견하거나 다시 만들어내는 작업이다. 램 등이 공동으로 사용할 수 있으며, 초기의 소프트웨어 - 일반적인 개발 단계(정공학)와 반대되는 의미로 기존 개발 환경에서는 사람이 정보 저장소 역할을 했지만 오 코드를 복구하는 방법이다. 늘날에는 데이터베이스가 정보 저장소 역할을 담당함 - 대상 소프트웨어가 있어야 하며 이로부터 작업이 시작 된다. - 역공학의 가장 간단하고 오래된 형태는 재문서화이다. •이 식(Migration) : 기존 소프트웨어를 다른 운영체제나 하 드웨어 환경에서 사용할 수 있도록 변환하는 작업임 • 재공학의 목표 : 복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거, 부작용의 발견 79 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 77] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 5과목·데이터 통신 • 아날로그와 디지털 신호 전송에 모두 사용한다. • 고주파 특성이 양호하며, 광대역 전송에 적합하다. 핵심 10.9, 02.5, 99.8 • CATV, 근거리 통신망(LAN), 장거리 전화 등에 다양 211 데이터 통신의 개요 하게 사용된다. • 데이터 통신 : 컴퓨터의 발달을 배경으로 하여 생겨난 것 광섬유 케이블(Optical Fiber Cable) 으로, 컴퓨터와 각종 통신기기 사이에서 디지털 형태로 • 유리를 원료로 하여 제작된 가느다란 광섬유를 여러 표현된 2진 정보(0과 1)를 송·수신하는 것을 말한다. 가닥 묶어서 케이블의 형태로 만든 것으로 광 케이블 데이터 통신 = 데이터 전송 기술 + 데이터 처리 기술 이라고도 한다. • 정보 통신 : 컴퓨터와 통신 기술의 결합에 의해 통신 처 • 데이터를 빛으로 바꾸어 빛의 반사 원리를 이용하여 리 기능과 정보 처리 기능은 물론 정보의 변환, 저장 과 전송한다. 정이 추가된 형태의 통신이다. • 유선 매체 중 가장 빠른 속도와 높은 주파수 대역폭을 정보 통신 = 전기 통신(정보 전송) + 컴퓨터(정보 처리) 제공한다. • 통신의 3요소 : 정보원, 수신원, 전송 매체(=통신 회선) • 대용량, 장거리 전송이 가능하다. •주 요 데이터 통신 시스템의 발달 과정 • 가늘고, 가벼워 설치가 용이하다. • 도청이 어려워 보안성이 뛰어나다. SAGE 최초의 데이터 통신 시스템 • 무유도, 무누화의 성질을 가진다. SABRE 최초의 상업용 데이터 통신 시스템 • 감쇠율이 적어 리피터의 설치 간격이 넓으므로 리피터 CTSS 최초의 시분할 시스템 의 소요가 적다. ARPANET 인터넷의 효시가 된 통신 시스템 • 설치 비용은 비싸지만 단위 비용은 저렴하다. •최초의 무선(라디오) 패킷 교환 시스템 ALOHA •회선 제어 방식 중 경쟁(Contention) 방식의 모체 • 광섬유 간의 연결이 어려워 설치 시 고도의 기술이 필 요하다. SNA 데이터 통신 시스템의 표준화가 시작 위성 마이크로파 • 지상에서 쏘아 올린 마이크로 주파수를 통신 위성을 핵심 14.5, 12.3, 06.9, 04.3, 00.7, 00.3, 99.8, 99.4 212 통신 회선 통해 변환, 증폭한 후 다른 주파수로 지상에 송신하는 방식으로, 위성 통신에 사용된다. 꼬임선(Twisted Pair Wire, 이중 나선) • 위성 통신에 사용하고 있는 주파수는 300~3,000MHz • 전기적 간섭 현상을 줄이기 위해서 균일하게 서로 감 인 UHF(Ultra High Frequency)나 3~30GHz인 겨있는 형태의 케이블이다. SHF(Super High Frequency)를 사용한다. • 가격이 저렴하고, 설치가 간편하다. • 위성 통신 시스템은 통신 위성, 지구국, 채널로 구성된다. • 거리, 대역폭, 데이터 전송률 면에서 제약이 많다. • 대역폭이 넓어 고속·대용량 통신이 가능하고, 통신 • 다른 전기적 신호의 간섭이나 잡음에 영향을 받기가 비용이 저렴하다. 쉽다. • 전송 지연 시간이 길고, 보안성이 취약하다. 동축 케이블(Coaxial Cable) • 통신 위성은 약 35,800Km 정도의 정지 궤도 상에 위 • 주파수 범위(대역폭)가 넓어서 데이터 전송률이 높다. 치하여 지구의 자전 속도로 운행한다. • 꼬임선에 비해 외부 간섭과 누화의 영향이 적다. • 위성 통신 시스템에서는 하나의 통신 위성에 여러 개 의 지구국이 접속하여 사용하므로, 통신 위성을 공동 • 신호의 감쇠 현상을 막기 위해 일정 간격마다 중계기 으로 사용하기 위한 다중 접속 방식이 필요하다. 를 설치해야 한다. - FDMA(Frequency Division Multiple Access) : 주 파수 대역을 일정 간격으로 분할하는 방식 80 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 78] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 - TDMA(Time Division Multiple Access) : 사용 시 핵심 06.9, 02.3, 00.3 215 아날로그 / 디지털 전송 간(Time Slot)을 분할하는 방식 - CDMA(Code Division Multiple Access) : 주파수나 • 전송 매체를 통해 전달되는 신호가 아날로그 형태 시간을 모두 공유하면서 각 데이터에 특별한 코드를 인 것 부여하는 방식으로, 산악 지형 또는 혼잡한 도심 지 아날로그 • 신호의 감쇠 현상이 심하므로 장거리 전송 시 증폭 전송 기에 의해 신호를 증폭하여 전송하며, 이때 신호에 역에서 통화 품질이 우수함 포함된 잡음까지도 같이 증폭되기 때문에 오류율이 높음 • 전송 매체를 통해 전달되는 신호가 디지털 형태인 것 핵심 04.9, 02.9, 01.9, 00.3 213 통신 제어장치(CCU) • 장거리 전송 시 중계기(리피터, Repeater)에 의해 원래의 신호 내용을 다시 복원한 다음 전송하는 방 식이기 때문에 잡음에 의한 오류율이 낮음 통신 제어장치의 기능 디지털 • 대역폭을 효율적으로 이용하여 더 많은 용량을 전 전송 통신 제어장치는 데이터 전송 회선과 주컴퓨터를 전기적 송할 수 있음 으로 결합하며, 데이터 신호의 직·병렬 변환을 통해 전 • 아날로그나 디지털 정보의 암호화를 쉽게 구현할 수 있음 송 문자를 조립 및 분해하는 장치로 컴퓨터를 대신해 데 • 전송 장비가 소형화되고 가격이 저렴해지고 있음 이터 전송에 관한 전반적인 제어 기능을 수행한다. 다중 접속 제어, 교환 접속 제어, 통신 방식 제어, 우회 전송 제어 중계 회선 설정(경로 설정) 핵심 14.3, 13.6, 12.5, 08.9, 08.5, 08.3, 04.5, 04.3, 03.3, 01.9, 01.3, 00.7, 99.10, 99.4 216 통신 방식 동기 제어, 오류 제어, 흐름 제어, 응답 제어, 정보 전 동기 및 송 단위의 정합, 데이터 신호의 직·병렬 변환, 투과 오류 제어 • 단방향(Simplex) 통신 : 한쪽 방향으로만 전송이 가능한 성, 정보 표시 형식의 변환, 우선권 제어 방식  라디오, TV 그 밖의 제어 정보 식별, 기밀 보호, 관리 기능 • 반이중(Half-Duplex) 통신 : 양방향 전송이 가능하지만 기능 동시에 양쪽 방향에서 전송할 수 없는 방식  무전기, 전처리기(FEP) 모뎀을 이용한 데이터 통신 호스트 컴퓨터와 단말기 사이에 고속 통신 회선으로 설 • 전이중(Full-Duplex) 통신 : 동시에 양방향 전송이 가능 치되며, 통신 회선 및 단말기 제어, 메시지의 조립과 분 한 방식으로, 전송량이 많고, 전송 매체의 용량이 클 해, 전송 메시지 검사 등을 수행하므로, 컴퓨터의 부담이 때 사용  전화, 전용선을 이용한 데이터 통신 적어진다. 00.10, 00.7 핵심 14.8, 14.5, 14.3, 13.6, 13.3, 12.5, 12.3, 11.3, 10.5, 10.3, 09.8, 08.3, 07.9, 07.5, 06.9, 04.9, 03.8, 02.9, 02.5, 02.3, 01.9, 217 비동기식 전송 / 동기식 전송 핵심 14.3, 06.3, 03.8, 99.8 214 주파수 / 대역폭 비동기식 전송 • 단위 시간(주로 1초) 내에 신호 파형이 반복되는 •한 문자를 나타내는 부호(문자 코드) 앞뒤에 Start Bit 횟수를 의미하는 것으로, 단위는 Hz임 와 Stop Bit를 붙여서 Byte와 Byte를 구별하여 전송 1 •단위 시간과의 관계 : f = (f:주파수, T:주기) T 하는 방식이다. •주요 데이터의 주파수 -음성 : 300 ~ 3,400Hz •시 작 비트, 전송 문자(정보 비트), 정지 비트로 구성된 주파수 -HF(High Frequence) : 3 ~ 30MHz 한 문자를 단위로 하여 전송하며, 오류 검출을 위한 패 (Frequency) -VHF(Very High Frequence) : 30 ~ 300MHz 리티 비트(Parity Bit)를 추가하기도 한다. - UHF(Ultra High Frequence) : 300 ~ 3,000MHz •시 작 비트는 이진수 0 값을 갖고 1비트 시간만큼 지속 - SHF(Super High Frequence) : 3,000 ~ 되며, 정지 비트는 이진수 1 값을 갖고 1, 1.5 혹은 2비 30,000MHz 트 시간만큼 지속된다. 대역폭 주파수의 변화 범위, 즉 상한 주파수와 하한 주파수 (Bandwidth) 의 차이 81 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 79] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •데 이터가 전송되지 않을 때 통신 회선은 휴지(Idle) 상 • 널(Null) 모뎀 : 모뎀을 사용하지 않고 RS-232C 커넥터 태가 되는데, 문자와 문자 사이의 휴지 시간(Idle 를 이용해 2대의 컴퓨터를 직접 접속해서 정보를 교환 Time)이 불규칙하다. 할 수 있게 하는 것으로 실제로는 모뎀이 사용되지 않지 만 컴퓨터의 입장에서는 모뎀을 사용하는 것과 같으므 • 2,000bps 이하의 저속, 단거리 전송에 사용한다. 로 모뎀이라고 표현함 • 문자마다 시작, 정지를 알리기 위한 비트가 2~3Bit씩 추가되므로, 전송 효율이 떨어진다. 동기식 전송 핵심 09.8, 07.3, 02.9, 01.6, 00.10 219 DSU(Digital Service Unit) • 미리 정해진 수만큼의 문자열을 한 블록(프레임)으로 만들어 일시에 전송하는 방식이다. •컴 퓨터나 단말장치로부터 전송되는 디지털 데이터를 디지털 회선에 적합한 디지털 신호로 변환하는 과정과 •프 레임 단위로 전송하므로 전송 속도가 빠르다. 그 반대의 과정을 수행한다. • 시작/종료 비트로 인한 오버헤드가 없고, 휴지 시간이 • 신호의 변조 과정이 없이 단순히 유니폴라(단극성) 신 없으므로, 전송 효율이 좋다. 호를 바이폴라(양극성) 신호로 변환하는 기능만 제공 • 주로 원거리 전송에 사용한다. 하기 때문에 모뎀에 비해 구조가 단순하다. •단 말기는 반드시 버퍼 기억장치를 내장해야 한다. • 디지털 데이터를 공중 데이터 교환망(PSDN)과 같은 • 비트 동기 방식과 블록 동기 방식이 있다. 디지털 통신망을 이용하여 전송할 때 사용된다. •수 신기가 데이터 블록의 시작과 끝을 정확히 인식하기 • 송·수신 기능과 타이밍 회복 기능을 DSU 자체에서 위한 프레임 레벨의 동기화가 필요하다. 수행한다. •블 록 동기 방식은 문자 동기 방식과 비트 동기 방식으 • 속도가 빠르고, 오류율이 낮다. 로 나뉜다. • SYN 등의 동기 문자(전송 제어 문자)에 의해 동기 문자 위주 핵심 14.5, 14.3, 12.8, 12.5, 10.9, 10.5, 09.8, 09.3, 08.9, 08.5, 08.3, 06.5, 05.9, 05.4, 05.3, 04.9, 04.3, 02.9, 00.7, 99.4 를 맞추는 방식 220 신호 변환 방식 - 디지털 변조(Keying) 동기 방식 • BSC 프로토콜에서 사용 • 데이터 블록의 처음과 끝에 8비트의 플래그 비트 •모 뎀(MODEM)을 이용하여 디지털 데이터를 아날로 비트 위주 (01111110)를 표시하여 동기를 맞추는 방식 그 신호로 변조하는 방식이다. 동기 방식 • HDLC, SDLC 프로토콜에서 사용 • 변조 방식 잠깐만요 ! 프레임(Frame) • 2진수 0과 1을 서로 다른 진폭의 신호로 변조 전송할 자료를 일정한 크기로 분리한 것으로, 동기식 전송의 전송 단위이며, 프레임은 데이터뿐만 아니라 행선지 코드, 동기를 위한 제 • 이 방식을 사용하는 모뎀은 구조가 간단하고, 가 진폭 편이 어 문자, 오류 검출을 위한 패리티나 CRC 등의 추가 정보로 구성됩 격이 저렴함 변조(ASK) 니다. • 신호 변동과 잡음에 약하여 데이터 전송용으로 거 의 사용되지 않음 • 2진수 0과 1을 서로 다른 주파수로 변조 핵심 06.5, 05.5, 01.6, 01.3 • 1,200bps 이하의 저속도 비동기식 모뎀에서 사용 218 모뎀(MODEM) 주파수 편이 됨 변조(FSK) • 이 방식을 사용하는 모뎀은 구조가 간단하고, 신 • 컴퓨터나 단말장치로부터 전송되는 디지털 데이터를 호 변동과 잡음에도 강함 아날로그 회선에 적합한 아날로그 신호로 변환하는 변조(MOdulation) 과정과 그 반대의 복조 (DEModulation) 과정을 수행한다. • 모뎀의 기능 : 변·복조 기능, 자동 응답 기능, 자동 호 출 기능, 자동 속도 조절 기능, 모뎀 시험(Loop Test) 기능 82 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 80] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •2진수 0과 1을 서로 다른 위상을 갖는 신호로 변조 부호화 양자화된 PCM 펄스의 진폭 크기를 2진수(1 또는 0) • 파형의 시작 위치를 다르게 하여 신호를 전송 (Encoding) 로 표시하는 과정 • 한 위상에 1비트(2위상), 2비트(4위상), 또는 3비트 복호화 수신된 디지털 신호(PCM 신호)를 PAM 신호로 되돌 위상 편이 (8위상)를 대응시켜 전송하므로, 속도를 증가시킬 (Decoding) 리는 단계 변조(PSK) 수 있음 여파화 PAM 신호를 원래의 입력 신호인 아날로그 신호로 • 중·고속의 동기식 모뎀에 많이 사용 (Filtering) 복원하는 과정 • 종류 : 2위상 편이 변조(DPSK), 4위상 편이 변조 (QDPSK), 8위상 편이 변조(ODPSK) • 반송파의 진폭과 위상을 상호 변환하여 신호를 얻 는 변조 방식 핵심 04.5, 03.5, 02.3, 99.8 직교 진폭 222 베이스밴드(Base Band) 전송 • 제한된 전송 대역 내에서 고속 전송(9,600bps)이 변조(QAM) 가능함 = 진폭 위상 • 컴퓨터나 단말장치 등에서 처리된 디지털 데이터를 다 • 9,600bps 모뎀의 표준 방식으로 권고됨 변조, 직교 른 주파수 대역으로 변조하지 않고 직류 펄스의 형태 • 신호의 진폭과 위상을 표시하는 신호의 구분점이 위상 변조 통신 회선의 잡음과 위상 변화에 대하여 우수한 그대로 전송하는 것으로, 기저대역 전송이라고도 한다. 특성을 지님 •신 호만 전송되기 때문에 전송 신호의 품질이 좋다. •직 류를 사용하므로 감쇠 등의 문제가 있어 장거리 전 00.10, 99.10, 99.8 핵심 14.8, 13.3, 12.8, 11.8, 11.3, 10.5, 10.3, 09.8, 09.3, 08.9, 08.5, 07.9, 06.5, 05.9, 05.5, 05.4, 05.3, 04.9, 04.3, 02.9, 01.3, 송에 적합하지 않다. 221 펄스 코드 변조(PCM) • 컴퓨터와 주변장치 간의 통신이나 LAN 등 비교적 가 • 화상, 음성, 동영상 비디오, 가상 현실 등과 같이 연속 까운 거리에서 사용된다. 적인 시간과 진폭을 가진 아날로그 데이터를 디지털 신호로 변조하는 방식으로, CODEC을 이용한다. 핵심 12.3, 11.6, 11.3, 10.9, 09.3, 08.3, 07.5, 05.9, 05.5, 03.5, 01.6, 01.3 •펄 스 코드 변조(PCM) 순서 : 송신 측(표본화 → 양자화 223 다중화기(Multiplexer) → 부호화) → 수신 측(복호화 → 여파화) • 하나의 통신 회선에 여러 대의 단말기가 동시에 접속 하여 사용할 수 있도록 하는 장치이다. • 음성, 영상 등의 연속적인 신호 파형을 일정 시간 간격으로 검출하는 단계 잠깐만요 ! 다중화(Multiplexing) • 샤논(Nyquist Shanon)의 표본화 이론 : 어떤 신 하나의 통신 회선을 다수의 단말기가 공유할 수 있도록 하는 것으로, 호 f가 의미를 지니는 최고 주파수보다 2배 이 (t) 다중화를 위한 장치에는 다중화기, 집중화기, 공동 이용기가 있습 상의 주파수로 균일한 시간 간격 동안 채집된다 니다. 표본화 면 이 채집된 데이터는 원래의 신호가 가진 모든 정보를 포함함 (Sampling) •고 속 통신 회선의 주파수나 시간을 일정한 간격으로 • 표본화에 의해 검출된 신호를 PAM 신호라고 하 나누어 각 단말기에 할당하는 방식으로 운영된다. 며, 아날로그 형태임 • 표본화 횟수 = 2배 × 최고 주파수 • 통신 회선을 공유함으로써 전송 효율을 높이고, 통신 1 회선의 수와 설치 비용을 줄일 수 있다. • 표본화 간격 = 표본화 횟수 •다 중화기는 주파수 분할 다중화기와 시분할 다중화기 • 표본화된 PAM 신호를 유한 개의 부호에 대한 대표 로 구분할 수 있다. 값으로 조정하는 과정 • 실수 형태의 PAM 신호를 반올림하여 이산적인 정 • 입력 회선의 수와 출력 회선의 수가 같다. 수형으로 만듦 •여 러 대의 단말기 속도의 합이 다중화된 하나의 통신 •양 자화 잡음 : 표본 측정값과 양자화 파형과의 오 양자화 차를 말하며, 주로 PCM 단국장치에서 발생 회선 속도와 같다(A + B + C = D). (Quantizing) • 양자화 잡음은 양자화 레벨을 세밀하게 함으로써 줄일 수 있으나, 이 경우 데이터의 양이 많아지고 전송 효율이 낮아짐 •양 자화 레벨 : PAM 신호를 부호화할 때 2진수로 표현할 수 있는 레벨(양자화 레벨 = 2표본당 전송 비트 수) 83 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 81] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 13.6, 08.5, 08.3, 07.9, 06.3, 05.9, 05.5, 05.4, 05.3, 04.5, 04.3, 03.5, 03.3, 02.9, 02.5, 01.9, 01.3, 00.7, 00.3 • 전송할 데이터가 있는 단말장치에만 시간 폭을 제공하 224 주파수 분할 다중화기(FDM) 므로, 전송 효율이 높음 • 동기식 시분할 다중화기보다 많은 수의 단말기들이 전 • 통신 회선의 주파수를 여러 개로 분할하여 여러 대의 송 매체에 접속할 수 있음 단말장치가 동시에 사용할 수 있도록 한 것이다. • 데이터 전송량이 많아질 경우 전송 지연이 생길 수 있음 •전 송 신호에 필요한 대역폭보다 통신 회선의 유효 대 비동기식 • 동기식 시분할 다중화기에 비해 접속에 소요되는 시 역폭이 큰 경우에 사용한다. 시분할 간이 김 다중화기 • 다중화기 자체에 변·복조 기능이 내장되어 있어 모뎀 • 주소 제어, 흐름 제어, 오류 제어 등의 기능을 하므로 (ATDM) 복잡한 제어 회로와 임시 기억장치가 필요하고, 가격 을 설치할 필요가 없다. 이 비쌈 •시 분할 다중화기에 비해 구조가 간단하고 가격이 저렴 • 지능 시분할 다중화기, 확률적 시분할 다중화기, 통계 하다. 적 시분할 다중화기라고도 함 • 다중화된 회선의 데이터 전송률은 접속장치들의 데이 •대 역폭을 나누어 사용하는 각 채널들 간의 상호 간섭을 터 전송률의 합보다 작음 방지하기 위한 보호 대역(Guard Band)이 필요하다. •보 호 대역(Guard Band) 사용으로 인한 대역폭의 낭 비가 초래된다. 핵심 02.3, 00.10, 00.3 226 역 다중화기(Inverse Multiplexer) • 저속(1,200Bps 이하)의 비동기식 전송, 멀티 포인트 방식, 아날로그 신호 전송에 적합하다. •광 대역 회선 대신에 2개의 음성 대역 회선을 이용하여 데이터를 전송할 수 있도록 하는 장치이다. 04.3, 03.8, 03.5, 02.5, 02.3, 00.10, 00.7, 99.10, 99.8 • 광대역 통신 회선을 사용하지 않고도 9,600bps 이상 핵심 14.3, 13.8, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 09.8, 09.3, 08.9, 08.5, 08.3, 07.5, 07.3, 06.5, 06.3, 05.9, 05.5, 05.4, 04.5, 225 시분할 다중화기(TDM) 의 광대역 속도를 얻을 수 있으므로, 통신 비용을 절감 할 수 있다. •통 신 회선의 대역폭을 일정한 시간 폭(Time Slot)으 • 하나의 통신 회선이 고장나더라고 나머지 하나의 회선 로 나누어 여러 대의 단말장치가 동시에 사용할 수 있 을 통해 1/2 속도로 전송을 계속 유지할 수 있다. 도록 한 것이다. • 여러 가지 변화에 대응해 다양한 전송 속도를 얻을 수 • 디지털 회선에서 주로 이용하며, 대부분의 데이터 통 있다. 신에 사용된다. • 다중화기의 내부 속도와 단말장치의 속도 차이를 보완 해 주는 버퍼가 필요하다. 핵심 06.9, 03.8, 01.6 227 집중화기(Concentrator) • 모든 단말장치에 균등한(고정된) 시간 폭을 제공함 • 하나 또는 소수의 회선에 여러 대의 단말기를 접속하 • 전송되는 데이터의 시간 폭을 정확히 맞추기 위한 동기 비트가 필요함 여 사용할 수 있도록 하는 장치이다. • 통신 회선의 데이터 전송률이 전송 디지털 신호의 • 실제 전송할 데이터가 있는 단말기에만 통신 회선을 할 동기식 데이터 전송률을 능가할 때 사용함 당하여 동적으로 통신 회선을 이용할 수 있도록 한다. 시분할 • 전송할 데이터가 없는 경우에도 시간 폭(Time Slot) 다중화기 이 제공되므로 효율성이 떨어짐 •한 개의 단말기가 통신 회선을 점유하면 다른 단말기 (STDM) • 송신 측에서는 입력된 데이터를 채널 별로 분리하 는 회선을 사용할 수가 없으므로, 다른 단말기의 자료 여 각각의 채널 버퍼에 저장하고, 이를 순차적으로 전 를 임시로 보관할 버퍼가 필요하다. 송함 • 다중화된 회선의 데이터 전송률은 접속장치들의 데 • m개의 입력 회선을 n개의 출력 회선으로 집중화하는 이터 전송률의 합과 같음 장치로, 입력 회선의 수가 출력 회선의 수보다 같거나 많다. • 여러 대의 단말기의 속도의 합이 통신 회선의 속도보 다 크거나 같다(A + B + C ≥ D). •회 선의 이용률이 낮고, 불규칙적인 전송에 적합하다. 84 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 82] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 01.6, 01.3, 00.10, 00.7 02.3, 99.8, 99.4 핵심 14.5, 13.6, 13.3, 09.8, 08.3, 07.9, 07.5, 07.3, 06.9, 06.3, 05.9, 05.5, 05.4, 05.3, 04.5, 03.8, 03.5, 02.9, 02.5, 02.3, 핵심 14.5, 14.3, 13.8, 13.3, 12.5, 12.3, 11.8, 10.9, 10.5, 09.5, 09.3, 08.5, 07.3, 06.9, 06.5, 06.3, 05.4, 05.3, 04.9, 04.5, 03.3, 228 통신 속도 230 전송 제어 문자 링크 관리, 프레임의 시작 및 끝의 구별과 오류 제어 등 • 1초 동안 몇 개의 신호 변화가 있었는가를 나타내는 것(단위 : Baud) 의 기능을 한다. 변조 속도 • 변조 속도(Baud) = 데이터 신호 속도(Bps) / 변조 시 상태 변화 수 문 자 기 능 •1초 동안 전송 가능한 비트의 수(단위 : Bps(Bit/Sec)) SYN(SYNchronous Idle) 문자 동기 신호 속도 • 데이터 신호 속도(Bps) = 변조 속도(Baud) × 변조 SOH(Start Of Heading) 헤딩의 시작 시 상태 변화 수 STX(Start of TeXt) 본문의 시작 및 헤딩의 종료 단위 시간에 전송되는 데이터의 양(문자, 블록, 비트, 전송 속도 단어 수 등) ETX(End of TeXt) 본문의 종료 베어러 데이터 신호에 동기 문자, 상태 신호 등을 합한 속도 ETB(End of Transmission 블록의 종료 속도 (단위 : Bps(Bit/Sec)) Block) EOT(End Of Transmission) 전송 종료 및 데이터 링크의 해제 잠깐만요 ! 변조 시 상태 변화 수 상대편에 데이터 링크 설정 및 모노 비트(Mono Bit) = 1비트, 디 비트(Di Bit) = 2비트, 트리 비트(Tri ENQ(ENQuiry) 응답 요구 Bit) = 3비트, 쿼드 비트(Quad Bit) = 4비트 전송 제어 문자 앞에 삽입하여 DLE(Data Link Escape) 전송 제어 문자임을 알림(문자의 03.8, 03.5, 03.3, 02.5, 02.3, 01.6, 01.3, 00.7, 00.3 투과성을 위해 삽입) 핵심 14.3, 12.8, 12.3, 10.5, 09.3, 08.9, 08.3, 07.9, 07.5, 07.3, 06.9, 06.5, 06.3, 05.9, 05.5, 05.3, 04.9, 04.5, 229 전송 제어의 기본 ACK(ACKnowledge) 수신된 메시지에 대한 긍정 응답 NAK • 전송 제어 : 데이터의 원활한 흐름을 위하여 입·출력 수신된 메시지에 대한 부정 응답 (Negative AcKnowledge) 제어, 회선 제어, 동기 제어, 오류 제어, 흐름 제어 등 을 수행하는 것 •O SI 7 참조 모델의 데이터 링크 계층(2계층)에서 수행 핵심 14.5, 14.3, 13.8, 13.6, 13.3, 11.8, 10.3, 09.8, 09.5, 08.9, 08.3, 07.9, 07.5, 06.9, 05.9, 05.5, 05.3, 04.9, 01.6, 00.10 231 HDLC(High-level Data Link Control)의 특징 하는 기능이다. • 전송 제어 절차 : 데이터 통신 회선의 접속 → 데이터 링 •비 트(Bit) 위주의 프로토콜로, 각 프레임에 데이터의 크 설정(확립) → 정보 메시지 전송 → 데이터 링크 종 흐름을 제어하고 오류를 검출할 수 있는 비트 열을 삽 결 → 데이터 통신 회선의 절단 입하여 전송한다. • 포인트 투 포인트 및 멀티 포인트, 루프 방식에서 모두 • 통신 회선과 단말기를 물리적으로 접속하는 사용 가능하다. 단계 데이터 통신 • 교환 회선을 이용한 포인트 투 포인트 방식이 •단 방향, 반이중, 전이중 통신을 모두 지원하며, 동기식 회선의 접속 나 멀티 포인트 방식으로 연결된 경우에 필요 전송 방식을 사용한다. 한 단계 • 오류 제어를 위해 Go-Back-N과 선택적 재전송 접속된 통신 회선상에서 송·수신 측 간의 확실 데이터 링크 한 데이터 전송을 수행하기 위해서 논리적 경로 (Selective Repeat) ARQ를 사용한다. 설정(확립) 를 구성하는 단계 • 흐름 제어를 위해 슬라이딩 윈도우 방식을 사용한다. 설정된 데이터 링크를 통해 데이터를 수신 측에 정보 메시지 •전 송 제어상의 제한을 받지 않고 자유로이 비트 정보를 전송하고, 오류 제어와 순서 제어를 수행하는 전송 단계 전송할 수 있는 것을 비트 투과성(투명성)이라고 한다. 데이터 링크 • 비트 투과성(투명성)을 보장하기 위한 기능으로 비트 송·수신 측 간의 논리적 경로를 해제하는 단계 종결(해제) 스터핑(Bit Stuffing)이 사용 된다. 데이터 통신 통신 회선과 단말기 간의 물리적 접속을 절단하 회선의 절단 는 단계 85 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 83] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 잠깐만요 ! 비트 스터핑(Bit Stuffing) • 전이중 통신을 하는 포인트 투 포인트 균형 비동기 • 플래그(Flag)를 제외한 모든 비트에 연속적으로 5개의 1이 입력 링크에서 사용 균형(평형) 되면 그 다음 여섯 번째에는 0을 강제로 추가(Stuffing)하여 송신합 • 혼합국끼리 허가 없이 언제나 전송할 수 있도 모드(ABM) 니다. 록 설정 • 프레임 내에 연속해서 6개의 1이 입력되면 플래그(Flag), 7개 이상 의 1이 연속해서 입력되면 오류 프레임으로 인식됩니다. • 전송 효율과 신뢰성이 높다. 핵심 13.6, 12.5, 11.8, 10.3, 08.9, 08.5, 07.9, 06.5, 04.3, 03.8, 02.9, 01.9, 01.6, 00.10, 00.3, 99.10 233 회선 제어 방식 • HDLC 프레임 구조 ◀ 헤더 ▶ ◀ 텍스트 ▶ ◀ 트레일러 ▶ • 회선 접속을 위해서 서로 경쟁하는 방식 • 송신 요구를 먼저 한 쪽이 송신권을 가짐 ◀ 8Bit ▶◀ 8Bit(확장가능) ▶ ◀ 8Bit ▶◀ 임의Bit ▶◀ 16/32Bit ▶◀ 8Bit ▶ 경쟁 • 포인트 투 포인트 방식에서 주로 사용 플래그 주소부 제어부 정보부 FCS 플래그 (Contention) • 데이터 링크가 설정되면 정보 전송이 종료되기 방식 전까지는 데이터 링크의 종결이 이루어지지 않 • 플래그(Flag) : 프레임의 시작과 끝을 나타내는 고유한 고 독점적으로 정보를 전송함 비트 패턴(01111110)으로 각 통화로의 혼선을 방지하기 • 대표적인 시스템으로는 ALOHA가 있음 위해 동기를 유지함 • 주컴퓨터에서 송·수신 제어권을 가지고 있는 방식으로 트래픽이 많은 멀티 포인트 방식에서 • FCS(프레임 검사 순서 필드) : 프레임 내용에 대한 오류 사용 검출을 위해 사용되는 부분으로, 일반적으로 CRC 코 • 폴링(Polling) : 주컴퓨터에서 단말기에게 전송 폴링/셀렉션 드가 사용 할 데이터가 있는지를 물어 전송할 데이터가 있 (Polling/ 다면 전송을 허가(Poll)하는 방식으로, 단말기에 Selection) 서 컴퓨터로 보낼 데이터가 있는 경우에 사용 00.10 방식 핵심 14.5, 13.8, 13.6, 13.3, 12.5, 12.3, 11.8, 11.6, 11.3, 10.9, 10.5, 09.8, 09.5, 09.3, 08.9, 08.3, 07.3, 06.5, 05.5, 05.3, 03.8, • 셀렉션(Selection) : 주컴퓨터가 단말기로 전송 232 HDLC의 프레임 및 전송 모드 할 데이터가 있는 경우 그 단말기가 받을 준비 가 되었는가를 묻고, 준비가 되어 있다면 주컴 • HDLC의 프레임 종류 퓨터에서 단말기로 데이터를 전송하는 방식 • 제어부가 ‘0’으로 시작하는 프레임 정보(I) 프레임 • 사용자 데이터를 전달하거나 피기백킹 핵심 14.5, 07.5, 06.3, 03.5, 03.3, 01.6, 00.3 (Information Frame) (Piggybacking) 기법을 통해 데이터에 234 오류의 발생 원인 대한 확인 응답을 보낼 때 사용 • 감쇠 : 전송 신호 세력이 전송 매체를 통과하는 과정에 감독(S) 프레임 • 제어부가 ‘10’으로 시작하는 프레임 서 거리에 따라 약해지는 현상 (Supervisor Frame) • 오류 제어와 흐름 제어를 위해 사용 •지 연 왜곡 : 하나의 전송 매체를 통해 여러 신호를 전달 비번호(U) 프레임 • 제어부가 ‘11’로 시작하는 프레임 (Unnumbered • 링크의 동작 모드 설정과 관리, 오류 했을 때 주파수에 따라 그 속도가 달라 생기는 오류 Frame) 회복을 수행함 • 상호 변조(간섭) 잡음 : 서로 다른 주파수들이 하나의 전 송 매체를 공유할 때 주파수 간의 합(合)이나 차(差)로 • HDLC의 데이터 전송 모드 : 데이터 전송 모드는 제어부 인해 새로운 주파수가 생성되는 잡음 에서 관리하는 U프레임에 의해 설정 •누 화 잡음 = 혼선 : 인접한 전송 매체의 전자기적 상호 유도 작용에 의해 생기는 잡음으로, 전화 통화중 다른 • 반이중 통신을 하는 포인트 투 포인트 또는 표준(정규) 멀티 포인트 불균형 링크 구성에 사용 전화의 내용이 함께 들리는 현상 응답 모드(NRM) • 종국은 주국의 허가(Poll)가 있을 때에만 송신 •충 격성 잡음 : 번개와 같은 외부적인 충격 또는 통신 시 • 전이중 통신을 하는 포인트 투 포인트 불균형 스템의 결함이나 파손 등의 기계적인 충격에 의해 생 링크 구성에 사용 비동기 응답 기는 잡음으로, 디지털 데이터를 전송하는 경우 중요 • 종국은 주국의 허가(Poll) 없이도 송신이 가능 모드(ARM) 하지만, 링크 설정이나 오류 복구 등의 제어 한 오류 발생 요인이 됨 기능은 주국만 함 86 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 84] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 03.3, 02.5, 01.9, 99.10, 99.8 • 시스템적 왜곡 : 전송 매체에서 언제든지 일어날 수 있 핵심 14.3, 13.6, 13.3, 12.8, 12.3, 11.8, 11.6, 11.3, 10.9, 10.3, 09.5, 08.9, 08.5, 08.3, 07.5, 07.3, 05.9, 05.4, 05.3, 04.3, 03.5, 237 오류 검출 방식 는 왜곡으로 손실, 감쇠, 하모닉 왜곡(신호의 감쇠가 진폭에 의해 달라지는 것) 등이 있음 • 전송 비트에 1비트의 검사 비트인 패리티 비트 (Parity Bit)를 추가하여 오류 검출 • 가장 간단한 방식이지만, 2개의 비트에 오류가 동 핵심 08.5, 06.5, 05.9, 03.8, 02.9 시에 발생하면 검출이 불가능함 235 전송 오류 제어 방식 패리티 • 오류를 검출만 할 수 있고, 수정은 하지 못함 검사 • 홀수/짝수 수직 패리티 체크와 홀수/짝수 수평 패 • 재전송 요구 없이 수신 측에서 스스로 오류 검출 리티 체크가 있음 과 수정을 하는 방식 • 짝수 수직 패리티 검사를 블록 합 검사(Block • 역채널이 필요 없고, 연속적인 데이터 흐름이 가 Sum Check) 라고도 한다. 전진(순방향) 능함 오류 수정 • 다항식 코드를 사용하여 오류를 검출하는 방식 • 데이터 비트 이외에 오류 검출 및 수정을 위한 비 (FEC) 트(잉여 비트)들이 추가로 전송되어야 하기 때문 • 동기식 전송에서 주로 사용함 에 전송 효율이 떨어짐 순환 중복 • HDLC 프레임의 FCS(프레임 검사 순서 필드)를 만 • 해밍 코드, 상승 코드 방식이 있음 검사(CRC) 드는 데 사용 • 집단 오류를 검출할 수 있고, 검출률이 높으므로 • 데이터 전송 과정에서 오류가 발생하면 송신 측 가장 많이 사용함 후진(역방향) 에 재전송을 요구하는 방식 오류 수정 • 패리티 검사, CRC, 블록 합 방식 등을 사용하여 • 수신 측에서 오류가 발생한 비트를 검출한 후 직접 (BEC) 오류를 검출하고, 오류 제어는 자동 반복 요청 수정하는 방식 (ARQ)에 의해 이루어짐 • 1비트의 오류만 수정이 가능하며, 정보 비트 외에 잉여 비트가 많이 필요함 해밍 코드 • 전송 비트 중 1, 2, 4, 8, 16, 32, 64, …, 2n번째를 오 02.3, 01.9, 01.6, 00.10, 00.3 류 검출을 위한 패리티 비트로 사용함 핵심 14.8, 14.5, 13.6, 13.3, 12.5, 11.8, 09.5, 08.5, 08.3, 07.3, 06.9, 06.5, 06.3, 05.4, 05.3, 04.5, 04.3, 03.5, 03.3, 02.9, 02.5, 236 자동 반복 요청(ARQ) • 해밍 거리(Hamming Distance) : 송신 비트와 수 신 비트 중 서로 다른 비트의 수(오류 비트 수) 오류 발생 시 수신 측은 오류 발생을 송신 측에 통보하고, 송 • 순차적 디코딩과 한계값 디코딩을 사용하여 오류 신 측은 오류 발생 블록을 재전송하는 모든 절차를 의미한다. 상승 코드 를 수정함 • 여러 비트의 오류를 수정할 수 있음 •송신 측에서 한 개의 블록을 전송한 후 수신 정지-대기(Stop- 측으로부터 응답을 기다리는 방식 and-Wait) ARQ • 구현 방법은 가장 단순하지만, 전송 효율이 핵심 14.5, 12.5, 12.3, 10.5, 10.3, 08.5, 08.3, 07.9, 07.3, 06.9, 05.4, 04.5, 04.3, 03.8, 03.3, 02.9, 01.9, 00.10, 00.7, 99.10 떨어짐 238 회선 교환 방식 •연속적으로 데이터 블록을 보내는 방식 •통 신을 원하는 두 지점을 교환기를 이용하여 물리적으로 • Go-Back-N ARQ : 오류가 발생한 블록 접속시키는 방식이다. 이후의 모든 블록을 재전송함 연속(Continuous) • 선택적 재전송(Selective Repeat) ARQ : •데 이터 전송 전에 먼저 물리적 통신 회선을 통한 연결이 ARQ 오류가 발생한 블록만을 재전송하는 방식으 필요하다. 로, 수신 측에서 데이터를 처리하기 전에 원 래 순서대로 조립해야 하므로, 더 복잡한 논 • 접속이 되고 나면 그 통신 회선은 전용 회선에 의한 통신 리회로와 큰 용량의 버퍼가 필요함 처럼 데이터가 전달된다(고정 대역 전송). • 데이터 블록의 길이를 채널의 상태에 따라 • 접속에는 긴 시간이 소요되나 일단 접속되면 교환기 내에 그때그때 동적으로 변경하는 방식으로, 전 적응적(Adaptive) 송 효율이 제일 좋음 서 전송 지연이 거의 없어 실시간 전송이 가능하다. ARQ • 제어회로가 복잡하고, 비용이 많이 들어 현 •데 이터 전송에 필요한 전체 시간이 축적 교환 방식에 비 재는 거의 사용되지 않음 해 길다. •데 이터가 전송되지 않는 동안에도 접속이 유지되기 때문 에 데이터 전송이 연속적이지 않은 경우 통신 회선이 낭 비된다. 87 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 85] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 •일 정한 데이터 전송률을 제공하므로 동일한 전송 속도가 • 메시지를 일정한 길이의 패킷으로 잘라서 전송하는 유지된다. 방식 • 패킷 교환망은 OSI 참조 모델의 네트워크 계층에 해 •전 송된 데이터의 오류 제어나 흐름 제어는 사용자에 의해 당함 수행된다. • 회선 이용률이 높음 •공 간 분할 교환 방식과 시분할 교환 방식으로 나뉘고, 시 • 수신 측에서 분할된 패킷을 재조립해야 함 • 응답 시간이 빠르므로, 대화형 응용이 가능함 분할 교환 방식에는 TDM 버스 교환 방식, 타임 슬롯 교 • 음성 전송보다 데이터 전송에 더 적합함 환 방식, 시간 다중화 교환 방식이 있다. • 가상 회선 방식과 데이터그램 방식이 있음 • 통신 과정 : 호(링크) 설정 → 데이터 전송 → 호(링크) 해제 • 전송에 실패한 패킷의 경우 재전송이 가능함 패킷 • 제어 신호 방식 교환 • 데이터의 전송 속도 조절이나 코드 변환이 가능함 방식 • 패킷 단위로 헤더를 추가하므로 패킷별 오버헤드가 발 생함 • 상대방과 통화하는 데 필요한 자원을 이용할 수 • 패킷(Packet) : 전송 혹은 다중화를 목적으로, 메시지 감시(관리) 있는지를 결정하고 알리는 데 사용되는 제어 신호 를 일정한 비트 수로 분할하여 송·수신 측 주소와 제 제어 신호 • 서비스 요청, 응답, 경보 및 휴지 상태 복귀 신호 어 정보 등을 부가하여 만든 데이터 블록 등의 기능 수행 • Clear Request Packet : 가상 회선 패킷 교환 방식에 주소 제어 상대방을 식별하고 경로를 배정하여 전화를 울리 서 모든 패킷을 전송한 다음 확립된 접속을 끝내기 위 신호 게 함 해 마지막으로 전송하는 패킷 • 패킷의 조립 및 분해 기능이 없는 비패킷형 단말기는 호 정보 신호음, 연결음, 통화중 신호음 등 호의 상태 정보를 PAD (Packet Assembler/Disassembler)에 의해서 패킷의 제어 신호 송신자에게 제공하는 역할 수행 조립 및 분해가 이루어짐 망 관리 통신망의 전체적인 운영, 유지, 고장 수리 등을 위해 제어 신호 사용 핵심 14.8, 14.5, 12.5, 11.6, 11.3, 10.9, 10.5, 10.3, 09.3, 07.5, 07.3, 05.9, 05.3, 02.9, 02.3, 01.3, 01.9 240 패킷 교환 방식의 종류 핵심 14.8, 12.8, 12.5, 10.3, 09.3, 08.3, 07.9, 07.5, 06.9, 04.9, 03.3, 99.10 239 축적 교환 방식 • 단말기 상호 간에 논리적인 가상 통신 회선을 미리 설정하여 송신지와 수신지 사이의 연결을 확립한 후 송신 측에서 전송한 데이터를 송신 측 교환기에 저장시 에 설정된 경로를 따라 패킷들을 순서적으로 운반하 켰다가 이를 다시 적절한 통신 경로를 선택하여 수신 측 는 방식 가상 회선 • 통신이 이루어지는 컴퓨터 사이에 데이터 전송의 안정, 터미널에 전송하는 방식이다. 방식 신뢰성이 보장됨 • 패킷의 송·수신 순서가 같음 • 교환기가 일단 송신 측의 메시지를 받아서 저장한 후 전송 순서가 되면 수신 측으로 전송하는 방식 • 통신 과정 : 호(Call) 설정 → 데이터 전송 → 호(Call) 해제 • 각 메시지마다 전송 경로를 결정하고, 수신 측 주소를 메시지 붙여서 전송함 • 연결 경로를 설정하지 않고 인접한 노드들의 트래픽 교환 • 전송 메시지는 추후 검색 및 속도나 코드 변환이 가 (전송량) 상황을 감안하여 각각의 패킷들을 순서에 상 방식 능함 데이터그램 관없이 독립적으로 운반하는 방식 • 전송 지연 시간이 매우 김 방식 • 패킷마다 전송 경로가 다르므로 송·수신 순서가 다를 • 응답 시간이 느려 대화형 데이터 전송에 부적절함 수 있음 • 소수의 패킷으로 구성된 짧은 데이터 전송에 적합함 88 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 86] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 핵심 14.8, 11.3, 07.5, 03.8, 02.3 네트워크 정보를 요구하지 않고, 송· 241 패킷 교환망의 기능 범람 경로 제어(Flooding) 수신처 사이에 존재하는 모든 경로로 패킷을 전송 • 패킷 다중화 : 동시에 다수의 상대 터미널과 통신을 수 임의 경로 제어 인접하는 교환기 중 하나를 임의로 선 행하도록 하는 기능 (Random Routing) 택하여 전송하는 방식 • 경로 제어(Routing) : 가장 효율적인 전송로를 선택하는 기능 •논 리 채널 : 송·수신 측 단말기 사이에서 논리 채널(가 핵심 14.8, 12.8, 06.3, 05.5, 04.9, 03.5, 03.3, 02.5, 01.6 243 트래픽 제어(Traffic Control) 상 회선)을 설정하는 기능 • 순서 제어 : 패킷의 송·수신 순서를 제어하는 기능 네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하 • 트래픽 제어(Traffic Control) : 전송되는 패킷의 흐름 또 는 기능이다. 는 그 양을 조절하기 위해 교착 상태(Dead Lock)의 방지, 흐름 제어 등을 수행함 흐름 제어(Flow Control) • 오류 제어 : 오류를 검출하고 정정하는 기능 네트워크 내의 원활한 흐름을 위해 송·수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능이다. 핵심 14.8, 13.8, 13.6, 11.8, 11.3, 10.9, 09.5, 07.9, 07.5, 07.3, 05.9, 04.5, 04.3, 03.5, 03.3, 02.5, 01.9, 01.6, 00.10 • 수신 측의 확인 신호(ACK)를 받은 후에 다 242 경로 제어(Routing) 정지-대기 음 패킷을 전송하는 방식 (Stop-and-Wait) • 한 번에 하나의 패킷만을 전송할 수 있음 • 송·수신 측 간의 전송 경로 중에서 최적의 패킷 교환 • 수신 측의 확인 신호를 받지 않더라도 미리 경로를 설정하는 기능이다. 정해진 패킷의 수만큼 연속적으로 전송하 는 방식 •경 로 설정 요소 : 성능 기준, 경로의 결정 시간과 장소, 슬라이딩 윈도 • 한 번에 여러 개의 패킷을 전송할 수 있어 정보 발생지, 경로 정보의 갱신 시간 (Sliding Window) 전송 효율이 좋음 • 경로 설정 프로토콜 • 윈도우 크기(Window Size) : 수신 측의 확 인 신호(ACK) 없이도 전송할 수 있는 패킷 • 하나의 자율 시스템(AS) 내의 라우팅에 사용되는 프로 의 개수로, 상황에 따라 변함 토콜 • RIP : 소규모 동종의 네트워크 내에서 효율적인 방법으로, 폭주(혼잡) 제어 IGP 최대 홉(Hop) 수를 15로 제한 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로 • OSPF : 홉(Hop) 수에 제한이 없어 대규모 네트워크에서 많이 사용되는 프로토콜로, 라우팅 정보에 변화가 있을 (Overflow)를 방지하는 기능을 한다. 때 변화된 정보만 네트워크 내의 모든 라우터에 알림 교착 상태 방지 자율 시스템(AS) 간의 라우팅, 즉 게이트웨이 간의 라우팅에 EGP 패킷이 같은 목적지를 갖지 않도록 할당하고, 교착 상태 사용되는 프로토콜 발생 시에는 교착 상태에 있는 한 단말장치를 선택하여 • 자율 시스템(AS) 간의 라우팅 프로토콜로, EGP의 단점을 패킷 버퍼를 폐기한다. 보완하기 위해 만들어짐 BGP • 초기에 BGP 라우터들이 연결된 때에는 전체 경로 제어표 를 교환하고, 이후에는 변화된 정보만을 교환함 핵심 07.9, 07.5, 06.9, 06.3, 05.9, 05.5, 05.4, 05.3, 03.8, 03.5, 01.6, 99.4 •경로 설정 방식 244 망(Network)의 구성 형태 고정 경로 제어(Static 성형(Star, 중앙 집중형) 네트워크 내의 모든 쌍에 대해서 경로 Routing) = 착국 부호 를 미리 정해 놓은 방식 • 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말기들 방식 이 연결되는 중앙 집중식의 네트워크 구성 형태이다. 적응 경로 제어 전송 경로를 동적으로 결정하는 방식 (Adaptive Routing) •단 말기의 추가와 제거가 쉽다. • 교환 노드의 수가 가장 적다. 89 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 87] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 링형(Ring, 루프형) •전 송 매체로 꼬임선, 동축 케이블, 광섬유 케이블 등을 사용한다. • 컴퓨터와 단말기들을 서로 이웃하는 것끼리 포인트 투 포인트 방식으로 연결시킨 형태이다. •망 의 구성 형태에 따라서 스타형, 버스형, 링형, 계층 (트리)형으로 분류된다. • 데이터는 단방향 또는 양방향으로 전송할 수 있으며, 단방향 링의 경우 컴퓨터, 단말기, 통신 회선 중 어느 • LAN의 계층 구조는 물리 계층과 데이터 링크 계층으 하나라도 고장나면 전체 통신망에 영향을 미친다. 로 나눠진다. 버스형(Bus) 물리 계층 OSI 7계층의 물리 계층과 동일한 기능을 제공 • 한 개의 통신 회선에 여러 대의 단말기가 연결되어 있 • 하위 계층인 매체 접근 제어(MAC) 계층과 는 형태이다. 상위 계층인 논리 링크 제어(LLC) 계층으로 •물 리적 구조가 간단하고, 단말기의 추가와 제거가 용 데이터 링크 계층 나뉨 • 매체 접근 제어(MAC) 방식의 종류 : CSMA, 이하다. CSMA/CD, 토큰 버스, 토큰 링 계층형(Tree, 분산형) • IEEE 802의 주요 표준 규격 •중 앙 컴퓨터와 일정 지역의 단말기까지는 하나의 통신 회선으로 연결시키고, 이웃하는 단말기는 일정 지역 내에 802.1 전체의 구성 802.5 토큰 링 방식 설치된 중간 단말기로부터 다시 연결시키는 형태이다. 802.2 논리 링크 제어 계층 802.6 도시형 통신망(MAN) • 분산 처리 시스템을 구성하는 방식이다. 802.3 CSMA/CD 방식 802.11 무선 LAN 망형(Mesh) 802.4 토큰 버스 방식 • 모든 지점의 컴퓨터와 단말기를 서로 연결한 형태로, 노드의 연결성이 높다. 핵심 14.3, 12.8, 12.5, 10.9, 10.5, 09.8, 07.9, 05.5, 04.9, 04.5, 03.5, 02.9, 02.3, 00.7, 00.3, 99.10 • 많은 단말기로부터 많은 양의 통신을 필요로 하는 경 246 CSMA/CD 방식 우에 유리하다. • 채널의 사용권을 서로 경쟁하여 확보하는 방식으로 노 •공 중 데이터 통신망에서 사용되며, 통신 회선의 총 경 드 간의 충돌을 허용하는 네트워크 접근 방식이다. 로가 가장 길다. • 통신 회선이 사용중이면 일정 시간 동안 대기하고, 통 • 통신 회선 장애 시 다른 경로를 통하여 데이터를 전송 신 회선상에 데이터가 없을 때에만 데이터를 송신하 할 수 있다. 며, 송신중에도 전송로의 상태를 계속 감시한다. •모 든 노드를 망형으로 연결할 때 필요한 회선 수(노드 • 전송 중에 충돌이 감지되면 패킷의 전송을 즉시 중단 n(n-1) = n)는 개이다. 2 하고 충돌이 발생한 사실을 모든 스테이션들이 알 수 있도록 간단한 통보 신호를 송신한다. 핵심 14.5, 13.8, 12.8, 12.3, 11.6, 11.3, 09.5, 09.3, 08.5, 07.3, 06.9, 06.5, 06.3, 05.9, 03.8, 03.3, 02.3, 01.9, 01.6, 00.10 •노 드 장애가 시스템 전체에 영향을 주지 않으며, 장애 245 LAN(근거리 통신망) 처리가 간단하다. • 광대역 통신망과는 달리 학교, 회사, 연구소 등 한 건물 •버 스형 또는 계층(트리)형 LAN에 가장 일반적으로 이 이나 일정 지역 내에서 컴퓨터나 단말기들을 고속 전송 용된다. 회선으로 연결하여 프로그램 파일 또는 주변장치를 공 •다 른 매체 접근 제어 방식에 비해 알고리즘(처리 기법) 유할 수 있도록 한 네트워크 형태이다. 이 간단하여 쉽게 구현할 수 있다. •단 일 기관의 소유, 제한된 지역 내의 통신이다. •일 정 길이 이하의 데이터를 송신할 경우 충돌을 검출 • 광대역 전송 매체의 사용으로 고속 통신이 가능하다. 할 수 없다. • 경로 선택이 필요 없고, 오류 발생률이 낮다. •전 송량이 적을 때 매우 효율적이고 신뢰성이 높다. •전 송량이 많아지면 충돌이 잦아져서 채널의 이용률이 떨어지고 전송 지연 시간이 급격히 증가한다. 90 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 88] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 충돌 발생 시 다른 노드에서는 데이터를 전송할 수 없 • 통신 처리 기능은 축적 교환 기능과 변환 기능으로 나 으며, 지연 시간을 예측하기 어렵다. 눠진다. • 충돌과 채널 경쟁을 위한 기법에는 non persistent, 전자 사서함, 데이터 교환, 동보 통신, 정시 1-persistent, p-persistent 기법이 있으며, 이중 가 축적 교환 기능 수집, 정시 배달 장 효율적인 1-persistent 기법이 주로 사용된다. 속도 변환, 프로토콜 변환, 코드 변환, 데이터 변환 기능 • CSMA/CD 방식을 사용하는 LAN을 이더넷(Ethernet) 형식(Format) 변환, 미디어 변환 이라고 한다. 잠깐만요 ! 프로토콜 변환 • CSMA/CD의 의미 서로 다른 네트워크 간에 또는 서로 다른 기종 간에 통신이 가능하도 록 통신 절차(회선 제어, 접속 등)를 변환하는 기능입니다. - CS(Carrier Sense) : 통신 회선이 사용중인지를 점검 - MA(Multiple Access) : 통신 회선이 비어 있으면 누 구든지 사용 가능 핵심 06.9, 06.3, 01.3, 00.7 248 ISDN(종합 정보 통신망) - CD(Collision Detection) : 데이터 프레임을 전송하 면서 충돌 여부를 조사 • 통신 방식 및 전송로가 모두 디지털 방식이다. • 이더넷 시스템의 규격 • 단일 통신망으로 음성, 문자, 영상 등의 다양한 서비스 를 종합적으로 제공한다. 10은 전송 속도가 10Mbps, BASE는 베이스밴드 10 BASE T 방식, T는 전송 매체로 꼬임선(Twisted Pair Wire) • 고속 통신이 가능하며, 확장성과 재배치성이 좋다. 케이블을 사용함을 나타냄 •2 개 이상의 단말장치를 제어할 수 있기 때문에 동시에 얇은 동축 케이블을 이용하며, 2는 한 세그먼트의 10 BASE 2 복수 통신을 할 수 있다. 최장 거리가 약 200m임을 나타냄 •통 신망의 중복 투자를 피할 수 있어 경제적이다. 굵은 동축 케이블을 이용하며, 5는 한 세그먼트의 10 BASE 5 최장 거리가 500m임을 나타냄 •O SI 참조 모델의 계층 구조를 따른다. 10 BASE F F는 광섬유 케이블을 이용하는 이더넷임을 나타냄 • 64Kbps 1회선 교환 서비스가 기본이다. 고속 100 BASE T라고도 불리는 이더넷의 고속 버전. • 통신망의 교환 접속 기능에는 회선 교환 방식과 패킷 이더넷 CSMA/CD를 사용하며, 100Mbps의 전송 속도를 교환 방식이 있다. (Fast 지원함 Ethernet) 기가비트 • CSMA/CD를 사용하며, 1Gbps의 전송 속도를 핵심 14.8, 13.8, 13.3, 12.3, 11.6, 10.3, 09.8, 09.3, 08.9, 08.5, 07.9, 04.9, 04.3, 03.8, 03.3, 02.9, 00.7 이더넷 지원 249 인터넷의 주소 체계 • 기존의 이더넷 및 고속 이더넷과 완벽한 호환성을 (Gigabit 지님 Ethernet) • IP 주소 : 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소로, 숫자로 8비트씩 4부분, 총 32비트 로 구성되며, A ~ E 클래스까지 총 5단계로 구성된다. 핵심 13.3, 12.8, 07.3, 06.5, 06.3, 05.5, 05.3, 04.9, 04.3, 03.5, 02.3, 01.9, 01.3, 00.3, 99.10 247 VAN(부가 가치 통신망) Class A 국가나 대형 통신망(16,777,216개 호스트) Class B 중대형 통신망(65,536개 호스트) •공 중 통신 사업자로부터 통신 회선을 임대하여 하나의 사설망을 구축하고 이를 통해 정보의 축적, 가공, 변환 Class C 소규모 통신망(256개 호스트) 처리 등 부가 가치를 첨가한 후 불특정 다수를 대상으 Class D 멀티캐스트 용 로 서비스를 제공하는 통신망이다. Class E 실험용 • 계층 구조 : 정보 처리 계층, 통신 처리 계층, 네트워크 • 서브넷 마스크 : 4바이트의 IP 주소 중 네트워크 주소와 계층, 기본 통신 계층 호스트 주소를 구분하기 위한 비트 • 기능 : 전송 기능, 교환 기능, 통신 처리 기능, 정보 처 리 기능 91 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 89] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • IPv6 : IPv4의 주소 부족 문제를 해결하기 위해 개발된 • 게이트웨이(Gateway) : 프로토콜 구조가 전혀 다른 네트 것으로, 16비트씩 8부분, 총 128비트로 구성되며, 각 부 워크의 연결을 수행하는 장비로, 세션 계층, 표현 계층, 분을 16진수로 표현하고, 콜론(:)으로 구분함 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행함 • IPv4를 IPv6로 전환하는 전략 - 듀얼 스택(Dual Stack) : 호스트에서 IPv4와 IPv6을 모두 처리할 수 있도록 두 개의 스택을 구성하는 것 핵심 12.8, 12.3, 09.8, 09.3, 06.9, 06.5, 06.3, 05.5, 05.4, 05.3, 04.5, 03.3, 01.6, 99.8 251 통신 프로토콜 - 터널링(Tunneling) : IPv6 망에서 인접한 IPv4 망을 거 쳐 다른 IPv6 망으로 통신할 때 IPv4 망에 터널을 만들 • 정의 : 서로 다른 기기들 간의 데이터 교환을 원활하게 어 IPv6 패킷이 통과할 수 있도록 하는 것으로 IPv4 망 수행할 수 있도록 표준화시켜 놓은 통신 규약 에 들어갈 때 캡슐화되고 나올 때 역캡슐화 됨 •기 본 요소 : 구문(Syntax), 의미(Semantics), 시간 - IPv4/IPv6 변환(Translation) (Timing) ▶ 헤더 변환(Header Translation) : IP 계층(네트 • 기능 : 단편화, 재결합, 캡슐화, 흐름 제어, 오류 제어, 워크 계층)에서 IPv6 패킷 헤더를 IPv4 패킷 헤 동기화, 순서 제어, 주소 지정, 다중화, 경로 제어, 전 더나 그 반대로 변환하는 방식 송 서비스(우선순위, 서비스 등급, 보안성) ▶ 전송 계층 릴레이(Relay) 방식 : 전송 계층에서 IPv6 패킷 헤더를 IPv4 패킷 헤더나 그 반대로 06.5, 06.3, 05.9, 05.4, 05.3, 04.9, 04.5, 04.3, 03.8, 03.5, 02.9, 02.5, 01.9, 01.3 핵심 14.5, 14.3, 13.8, 13.3, 12.8, 12.5, 12.3, 11.8, 11.3, 10.9, 10.5, 10.3, 09.8, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 07.3, 06.9, 변환하는 방식 252 OSI 참조 모델 ▶ 응용 계층 게이트웨이(Gateway) 방식 : 응용 계 • 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화 층에서 IPv6 패킷 헤더를 IPv4 패킷 헤더나 그 기구)에서 제안한 통신 규약(Protocol)이다. 반대로 변환하는 방식 • OSI 7계층 : 하위 계층(물리 계층 → 데이터 링크 계층 •도 메인 네임 : 숫자로 된 IP 주소를 사람이 이해하기 쉬 → 네트워크 계층) → 상위 계층(전송 계층 → 세션 계 운 문자 형태로 표현한 것으로, 호스트 컴퓨터명, 소속 층 → 표현 계층 → 응용 계층) 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성 • DNS(Domain Name System) : 문자로 된 도메인 네임을 • 전송에 필요한 두 장치 간의 실제 접속과 절 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하 물리 계층 단 등에 필요한 전송 매체의 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙 정의 는 시스템 (Physical Layer) •RS-232C 등 • 2개의 인접한 개방 시스템들 간에 신뢰성 있 핵심 12.5, 10.5, 08.5, 05.5, 05.4, 05.3, 04.5, 04.3, 03.5, 02.5, 01.9, 01.6, 01.3, 00.7, 00.3 데이터 링크 고 효율적인 정보 전송을 할 수 있도록 함 250 네트워크 관련 장비 계층(Data Link • 흐름 제어, 프레임 동기화, 오류 제어, 순서 Layer) 제어 • 허브(Hub) : 한 사무실이나 가까운 거리의 컴퓨터들을 연 • HDLC, LAPB, PPP, LLC 등 결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 재 • 개방 시스템들 간의 네트워크 연결 관리(네 생 기능을 하는 리피터의 역할도 포함함 트워크 연결을 설정, 유지, 해제), 데이터의 네트워크 계층 교환 및 중계 • 리피터(Repeater) : 물리 계층의 장비로, 전송되는 신호를 (Network Layer, • 경로 설정(Routing), 트래픽 제어, 패킷 정보 망 계층) 재생함 전송 • X.25, IP 등 • 브리지(Bridge) : 데이터 링크 계층의 장비로, LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연 • 종단 시스템(End-to-End) 간에 투명한 데 이터 전송을 가능하게 함 결함 전송 계층 (Transport • 전송 연결 설정, 데이터 전송, 연결 해제 기능 • 라우터(Router) : 네트워크 계층의 장비로, LAN과 LAN Layer) • 주소 설정, 다중화, 오류 제어, 흐름 제어 의 연결 및 경로 선택, 서로 다른 LAN이나 LAN과 • TCP, UDP 등 WAN을 연결함 92 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 90] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 05.9, 05.5, 05.4, 05.3, 04.9, 04.3, 03.5, 02.9, 02.5, 00.10, 00.3 핵심 14.8, 14.5, 14.3, 13.8, 13.6, 13.3, 12.8, 12.5, 12.3, 10.9, 10.5, 09.8, 09.5, 09.3, 08.9, 08.5, 08.3, 07.9, 07.5, 07.3, 06.9, • 송·수신 측 간의 관련성을 유지하고 대화 254 TCP/IP 제어를 담당 • 대화(회화) 구성 및 동기 제어, 데이터 교환 세션 계층 •인 터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터 관리 기능 (Session Layer) 를 주고받을 수 있도록 하는 표준 프로토콜이다. • 체크점(=동기점) : 오류가 있는 데이터의 회 복을 위해 사용하는 것으로 소동기점과 대동 •TCP/IP의 계층 기점이 있음 • 응용 계층으로부터 받은 데이터를 세션 계층 • 응용 프로그램 간의 데이터 송·수신 제공 응용 계층 표현 계층 에 맞게, 세션 계층에서 받은 데이터는 응용 • TELNET, FTP, SMTP, SNMP, HTTP, DNS, WAP 등 (Presentation 계층에 맞게 변환하는 기능 •호스트들 간의 신뢰성 있는 통신 제공 Layer) • 코드 변환, 데이터 암호화, 데이터 압축, 구문 전송 계층 검색, 정보 형식(포맷) 변환, 문맥 관리 기능 • TCP, UDP, RTP, RTCP 등 응용 계층 인터넷(네트 • 데이터 전송을 위한 주소 지정, 경로 설정 제공 사용자(응용 프로그램)가 OSI 환경에 접근할 (Application 워크) 계층 • IP, ICMP, IGMP, ARP, RARP 등 수 있도록 서비스를 제공함 Layer) 네트워크 •실제 데이터(프레임)를 송·수신하는 역할을 함 액세스 계층 • Ethernet, IEEE 802, HDLC, X.25, RS-232C, PPP 등 99.4, 00.10, 00.7 핵심 14.5, 14.3, 13.8, 12.8, 12.5, 12.3, 11.8, 11.6, 10.9, 10.5, 10.3, 09.8, 09.5, 08.9, 07.3, 06.3, 05.4, 04.9, 04.5, 02.9, 99.8, 잠깐만요 ! TCP/IP 계층 구조 253 X.25 x네트워크 액세스 계층을 물리 계층과 데이터 링크 계층으로 세분화 하여 물리 계층, 데이터 링크 계층, 인터넷 계층, 전송 계층, 응용 계 •패 킷 교환망을 통한 DCE와 DTE 간의 인터페이스를 층 이렇게 5계층으로 구분하기도 합니다. 제공한다. • 주요 프로토콜 •I TU-T에서 제정한 국제 표준 프로토콜로 우수한 호 환성을 가진다. • OSI 7계층의 트랜스포트(전송) 계층에 해당 •신뢰성과 효율성이 높고, 전송 품질이 우수하다. • 신뢰성(안정성) 있는 연결형 서비스를 제공함 • 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기 •연 결형 프로토콜로 흐름 제어, 오류 제어 등의 기능이 능을 제공함 있다. TCP • 스트림(Stream) 전송 기능을 제공함 •X .25의 계층 구조 • TCP 헤더에는 긴급 포인터, 순서 번호, 체크섬이 포 함 OSI X.25 • TCP 프로토콜을 사용하는 응용 계층 서비스 : FTP, SMTP, TELNET, DNS, HTTP 등 물리 계층 물리 계층 • OSI 7계층의 네트워크 계층에 해당 데이터 링크 계층 프레임 계층 • 데이터그램을 기반으로 하는 비연결형 서비스를 제 네트워크 계층 패킷 계층 공함 IP • 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공 • LAPB : HDLC의 원리를 이용한 비트 동기 제어 프로 함 토콜로, ITU-T에서 제정하였으며, X.25의 2계층에 • IP 헤더의 길이는 최소 20Byte에서 최대 60Byte임 서 사용함 • IP와 조합하여 통신중에 발생하는 오류의 처리와 전 송 경로 변경 등을 위한 제어 메시지를 관리하는 역 • 프레임 릴레이 : 기존의 X.25가 갖는 오버헤드를 제거 ICMP 할을 함 하여 고속 데이터 통신에 적합하도록 개선한 프로토콜 •헤더는 8Byte로 구성됨 • 패킷 교환을 위한 수행 절차 : 호 설정 → 데이터 전송 → 호스트의 IP 주소(논리 주소)를 호스트와 연결된 네트 호 해제 ARP 워크 접속장치의 물리적 주소(MAC Address)로 변환 함 RARP 물리적 주소를 IP 주소(논리 주소)로 변환함 93 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요",
    "[페이지 91] 시험에 정보처리기사 필기 나오는 것만 공부한다! 핵심 요약 시나공시리즈 • 실시간 전송 프로토콜(RTP)이 안정되게 기능을 유지 하도록 데이터 전송을 모니터링하고 최소한의 제어 와 인증 기능을 제공함 RTCP • RTCP 패킷은 32Bit로 구성됨 • 세션의 모든 참여자에게 컨트롤 패킷을 주기적으로 전송함 • 데이터 분배에 대한 피드백을 제공함 이동 단말이나 PDA 등 소형 무선 단말기에서 WAP 인터넷을 이용할 수 있도록 해주는 프로토콜 • 주로 두 개의 라우터를 접속할 때 사용되며, IETF의 표준 프로토콜임 PPP • 오류 검출 기능만 제공되며, 재전송을 통한 오류 복구와 흐름 제어 기능은 제공되지 않음 • 데이터 전송 전에는 연결을 설정하지 않는 비연결형 서비스를 제공함 • TCP에 비해 상대적으로 단순한 헤더 구조를 가지므 로, 오버헤드가 적음 UDP • 고속의 안정성 있는 전송 매체를 사용하여 빠른 속 (User 도를 필요로 하는 경우, 동시에 여러 사용자에게 데 Datagram 이터를 전달할 경우, 정기적으로 반복해서 전송할 Protocol) 경우에 사용함 • 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요 시되는 네트워크에서 사용됨 • UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum이 포함됨 94 www.sinagong.co.kr 나는 시험에 나오는 것만 공부한다! 독자의 1초까지 아껴주는 정성을 만나보세요"
  ],
  "created_at": "2025-03-30 21:01:37.932209",
  "total_chunks": 91
}